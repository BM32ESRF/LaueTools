# -*- coding: utf-8 -*-
"""
#  scripts and example Laue Pattern simulation based on lauecore.py  (new name of laue6.py)
#  J. S. Micha   micha [at] esrf [dot] fr
# version May 2019
#  from LaueTools package
#  http://sourceforge.net/projects/lauetools/

"""

__author__ = "Jean-Sebastien Micha, CRG-IF BM32 @ ESRF"
__version__ = '$Revision: 1717$'
import sys,os
sys.path.insert(1, os.path.join(sys.path[0], '..'))

import numpy as np
import time
import CrystalParameters as CP
from dict_LaueTools import dict_Rot, dict_Materials, dict_Vect, dict_Extinc, CST_ENERGYKEV, SIGN_OF_GAMMA
import generaltools as GT

import lauecore as LT
import IOLaueTools as IOLT
import LaueGeometry as LTGeo


DEFAULT_DETECTOR_DISTANCE = LT.DEFAULT_DETECTOR_DISTANCE
#--- -------------------  TESTS & EXAMPLES
def test_simulation():
    """
    test scenario
    """
    linestowrite = [['*********'],
                ['file .log generated by laue6.py'],
                ['at %s' % (time.asctime())],
                [' ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  == ']]

    #  SIMULATION Compute list of spots for each grains

    emin = 5
    emax = 25
    # What kind of 2D plot must be display#
    # 'xy' plot (xcam, ycam)  (X horizontal + along the x-ray ; Y horizontal + towards the GMT door; Z vertical + towards the ceilling)
    # 'XYcam' plot (xcam, ycam) Xmas
    # 'xytest' plot pour test orientation cam
    # '2thetachi' plot (2theta, chi)
    # 'directionq' plot (longitude, latitude) de q
    whatplot = '2thetachi'
    # detection geometry:
    # 'Z>0' top camera 'Y>0' side + 'Y<0' side - 'X<0' backreflection  'X>0' transmission
    kf_direction = 'Z>0'  # 'Z>0' 'Y>0' 'Y<0' 'X<0'

    # mat_UO2_He_103_1 = GT.OrientMatrix_fromGL(filename = 'UO2_He_103_1L.dat')
    mat_Id = np.eye(3)
    # mymat1 = fromelemangles_toMatrix([  1.73284101e-01 ,  3.89021368e-03 ,  4.53663032e+01])
    # mymat2 = fromelemangles_toMatrix([  0. ,  35.19 ,45.])
    # mattest= [[-0.72419551 , 0.09344237, -0.6832345 ], [-0.59410999 , 0.41294652,  0.69029595], [ 0.3465515 ,  0.90488673, -0.24714785]]
    # #mat_Cu = GT.OrientMatrix_fromGL(filename = 'matrixfromopenGL_311_c2.dat')
    # mat_Cu = np.eye(3)
    # matfromHough = fromelemangles_toMatrix([85., 68., 76.])
    # matfromHough = fromEULERangles_toMatrix([42., 13., 20.])
    grain1 = [mat_Id, 'dia', dict_Rot['Si_001'], 'Si']
    # grain2 = [mat_Id, 'dia', mymat2,'Si']
    # #grainUO2_103 = [vecteurref, [1, 1, 1],mat_UO2_He_103_1,'UO2']
    # grainHough = [mat_Id, 'fcc', matfromHough,'UO2']
    # graintest = [mat_Id, 'fcc', mattest,'UO2']

    # GRAIN Must Be Prepared !!! see CP.Prepare_Grain() or fill before dict_Material

    starting_time = time.time()

    # vec and indices of spots Z > 0 (vectors [x, y, z] array, miller indices [H, K, L] array)
    vecind = LT.getLaueSpots(CST_ENERGYKEV / emax,
                           CST_ENERGYKEV / emin,
                           [grain1],
                            linestowrite,
                            fileOK=0,
                            fastcompute=0,
                            kf_direction=kf_direction)
    pre_filename = 'totobill'

    # print "vecind",vecind
    # selecting RR nodes without harmonics (fastcompute = 1 loses the miller indices and RR positions associations for quicker computation)
    oncam_sansh = LT.filterLaueSpots(vecind,
                                fileOK=1,
                                fastcompute=0,
                                kf_direction=kf_direction,
                                detectordistance=DEFAULT_DETECTOR_DISTANCE,
                                HarmonicsRemoval=1,
                                linestowrite=linestowrite)
    # print "oncam_sansh",oncam_sansh

    # plot and save and write file of simulated Data
    # third input is a list whose each element corresponds to one grain list of spots object

    # loadind experimental data:
    data_filename = 'Ge_test.cor'
    data_2theta, data_chi, data_x, data_y, data_I = IOLT.readfile_cor(data_filename)

    # ----------  Time consumption information
    finishing_time = time.time()
    duration = finishing_time - starting_time
    print("Time duration for computation %.2f sec." % duration)

    LT.Plot_Laue(emin, emax, oncam_sansh, data_2theta, data_chi, data_filename,
                            removeharmonics=1,
                            kf_direction=kf_direction,
                            Plot_Data=1,
                            Display_label=0,
                            What_to_plot=whatplot,
                            saveplotOK=0,
                            WriteLogFile=1,
                            linestowrite=linestowrite)

    # logbook file edition
    IOLT.writefile_log(output_logfile_name=pre_filename + '.log',
                 linestowrite=linestowrite)

    return LT.CreateData_(oncam_sansh, outputname='tototable', pickledOK=0), \
            oncam_sansh


def test_speed():
    # ----------  Time consumption information
    Starting_time = time.time()

    Array2thetachi, Oncam = test_simulation()




emin = 5
emax = 15
kf_direction = 'Z>0'
data_filename = 'Ge_test.cor'  # experimental data

Id = np.eye(3)

if 0:
    grainSi = CP.Prepare_Grain('Si', OrientMatrix=dict_Rot['Si_001'])
    linestowrite = [[""]]

    grainSi[2] = GT.fromEULERangles_toMatrix([20., 10., 50.])

    print("\n*******************\nSimulation with fastcompute = 0")
    vecind = LT.getLaueSpots(CST_ENERGYKEV / emax, CST_ENERGYKEV / emin, [grainSi],
                                            linestowrite,
                                            fileOK=0,
                                            fastcompute=0,
                                            kf_direction=kf_direction,
                                            verbose=1)

    print("nb of spots with harmonics %d\n\n" % len(vecind[0][0]))

    print("\n*********\nSimulation with fastcompute = 1")

    vecindfast = LT.getLaueSpots(CST_ENERGYKEV / emax, CST_ENERGYKEV / emin, [grainSi],
                                            1,
                                            fileOK=0,
                                            fastcompute=1,
                                            kf_direction=kf_direction,
                                            verbose=1)


    print("nb of spots with harmonics fast method", len(vecindfast[0][0]))


    print("\n*******************\n --------  Harmonics removal -----------\n")

    oncam_sansh00 = LT.filterLaueSpots(vecind,
                                            fileOK=1,
                                            fastcompute=0,
                                            kf_direction=kf_direction,
                                            HarmonicsRemoval=1,
                                            linestowrite=linestowrite)

    print("after harm removal 00", len(oncam_sansh00[0]))

    oncam_sansh01 = LT.filterLaueSpots(vecind,
                                            fileOK=1,
                                            fastcompute=1,
                                            kf_direction=kf_direction,
                                            HarmonicsRemoval=1,
                                            linestowrite=linestowrite)

    print("after harm removal 01", len(oncam_sansh01[0]))

    oncam_sansh11 = LT.filterLaueSpots(vecindfast,
                                            fileOK=1,
                                            fastcompute=1,
                                            kf_direction=kf_direction,
                                            HarmonicsRemoval=1,
                                            linestowrite=linestowrite)

    print("after harm removal 11", len(oncam_sansh11[0]))


    # ------------------------
    print("\n*****************************\n rax compute\n")
    grainSi[2] = GT.fromEULERangles_toMatrix([20., 10., 50.])

    #res = get_2thetaChi_withoutHarmonics(grainSi, 5, 15)

if 1:  # some grains example
    inittime = time.time()
    
    emax = 50
    emin = 5
    
    elem1 = 'Ti'
    elem2 = 'Cu'

    kf_direction = 'Z>0'

    BmatTi = CP.calc_B_RR(dict_Materials['Ti'][1])

    BmatCu = CP.calc_B_RR(dict_Materials['Cu'][1])

    Umat = dict_Rot['OrientSurf111']

    grainTi = [BmatTi, 'no', Umat, 'Ti']

    grainCu = [BmatCu, 'fcc', Id, 'Cu']
    grainCu__ = [BmatCu, 'no', Id, 'Cu']

    dict_Materials['Cu2'] = ['Cu2', [5, 3.6, 3.6, 90, 90, 90], 'fcc']
    BmatCu2 = CP.calc_B_RR(dict_Materials['Cu2'][1])

    dict_Materials['Cu3'] = ['Cu3', [Id, Umat, Id, BmatCu2], 'fcc']  # Da, U, Dc, B

    grainCu2 = CP.Prepare_Grain('Cu2', OrientMatrix=Id)
    grainCu3 = CP.Prepare_Grain('Cu3', OrientMatrix='ihjiÄ¥iohio')

    grainSi1 = CP.Prepare_Grain('Cu', OrientMatrix=Id)
    grainSi2 = CP.Prepare_Grain('Si', OrientMatrix=dict_Rot['OrientSurf111'])
    
    grainAl2o3 = CP.Prepare_Grain('Al2O3', OrientMatrix=Id)

    # grains= [grainSi,grainCu3]
    grains = [grainSi1, grainCu3, grainAl2o3]

    print(grains)

    LT.simulatepattern(grains, emin, emax,
                    kf_direction, data_filename, Plot_Data=0, verbose=1,
                    HarmonicsRemoval=0)
    
    finaltime = time.time()
    
    print('computation time is ', finaltime - inittime)

if 0:
    # strain study: ---------------------------------------
    dict_Materials['Cu2'] = ['Cu2', [5, 3.6, 3.6, 90, 90, 90], 'fcc']
    BmatCu2 = CP.calc_B_RR(dict_Materials['Cu2'][1])

    Umat = dict_Rot['OrientSurf111']
    # Da, U, Dc, B
    dict_Materials['Cu3'] = ['Cu3', [Id, Umat, Id , BmatCu2], 'fcc']

    grains = []
    for k in list(range(-5, 6)):
        dict_Materials['Cu_%d' % k] = dict_Materials['Cu3']
        # set material label
        dict_Materials['Cu_%d' % k][0] = 'Cu_%d' % k
        # set deformation in absolute space
        dict_Materials['Cu_%d' % k][1][0] = [[1 + 0.01 * k, 0, 0],
                                           [0, 1, 0],
                                            [0, 0, 1.]]
        grains.append(CP.Prepare_Grain('Cu_%d' % k))

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                    Plot_Data=0)
    # -----------------------------------------------

if 0:

    Bmat = dict_Vect['543_909075']
    Umat = dict_Rot['OrientSurf001']
    Dc = [[1.02, 0.01, 0],
          [-.01, 0.98, 0.005],
            [0.001, -0.02, 1.01]]
    Dc = [[1.00, 0.00, 0],
          [-.00, 1.00, 0.000],
        [0.000, -0.00, 1.03]]

    dict_Materials['mycell'] = ['mycell', [Id, Umat, Id, Bmat], 'fcc']
    dict_Materials['mycell_strained'] = ['mycell_strained',
                                        [Id, Umat, Dc, Bmat],
                                        'fcc']

    mygrain = CP.Prepare_Grain('mycell')
    mygrain_s = CP.Prepare_Grain('mycell_strained')

    grains = [mygrain, mygrain_s]

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                    Plot_Data=0)

if 0:

    Bmat = dict_Vect['543_909075']
    Umat = dict_Rot['mat311c1']
    Dc = dict_Vect['shear4']

    dict_Materials['mycell_s'] = ['mycell_s', [Id, Umat, Dc, Bmat], 'fcc']
    dict_Materials['mycell'] = ['mycell', [Id, Umat, Id, Bmat], 'fcc']

    mygrain_s = CP.Prepare_Grain('mycell_s')
    mygrain = CP.Prepare_Grain('mycell')

    grains = [mygrain_s]


    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1)

if 0:
    emin = 5
    emax = 22
    kf_direction = 'X>0'  # transmission
    kf_direction = 'Z>0'  # reflection

    ResolutionAngstrom = 2.

    # overwriting dict_Materials['smallpro']
    dict_Materials['smallpro'] = ['smallpro',
                                    [20, 4.8, 49, 90, 90, 90],
                                    'no']
    mygrain = CP.Prepare_Grain('smallpro', OrientMatrix=dict_Rot['mat311c1'])
    mygrain = CP.Prepare_Grain('smallpro', OrientMatrix=Id)

    grains = [mygrain]

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1, detectordistance=69, ResolutionAngstrom=ResolutionAngstrom)

if 0:
    emin = 5
    emax = 30
    kf_direction = 'X>0'  # transmission
#        kf_direction = 'Z>0' # reflection

    ResolutionAngstrom = False

    # overwriting dict_Materials['smallpro']

    mat111alongx = np.dot(GT.matRot([1, 0, 0], -45.), GT.matRot([0, 0, 1], 45.))

    print("mat111alongx", mat111alongx)

    matmono = np.dot(GT.matRot([1, 0, 0], -1), mat111alongx)

    mygrain = CP.Prepare_Grain('Cu', OrientMatrix=matmono)

    grains = [mygrain]

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1, detectordistance=10,
                        ResolutionAngstrom=ResolutionAngstrom)

if 0:
    emin = 8
    emax = 25
    kf_direction = 'X<0'  # back reflection
#        kf_direction = 'Z>0' # reflection

    ResolutionAngstrom = False

    # overwriting dict_Materials['smallpro']

    matmono = np.dot(GT.matRot([0, 0, 1], 20), np.eye(3))

    mygrain = CP.Prepare_Grain('Si', OrientMatrix=matmono)

    grains = [mygrain]

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1, detectordistance=55,
                        ResolutionAngstrom=ResolutionAngstrom,
                        Display_label=0)

if 0:
    emin = 8
    emax = 25
    kf_direction = 'X<0'  # back reflection
#        kf_direction = 'Z>0' # reflection

    ResolutionAngstrom = False

    # overwriting dict_Materials['smallpro']




    matmother = np.dot(GT.matRot([0, 0, 1], -5), np.eye(3))
    matmisorient = np.dot(GT.matRot([-1, 1, 1], .1), matmother)

    maingrain = CP.Prepare_Grain('Si', OrientMatrix=matmother)

    mygrain = CP.Prepare_Grain('Si', OrientMatrix=matmisorient)

    grains = [maingrain, mygrain]

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1, detectordistance=55,
                        ResolutionAngstrom=ResolutionAngstrom,
                        Display_label=0)

if 0:
    emin = 5
    emax = 20
    kf_direction = [90, 45]
#        kf_direction = 'Z>0' # reflection

    ResolutionAngstrom = False

    # overwriting dict_Materials['smallpro']

    matmother = np.dot(GT.matRot([0, 0, 1], 0), np.eye(3))
#        matmisorient = np.dot(GT.matRot([-1, 1, 1], .1), matmother)

    maingrain = CP.Prepare_Grain('Si', OrientMatrix=matmother)

    grains = [maingrain, maingrain]

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1, detectordistance=70,
                        ResolutionAngstrom=ResolutionAngstrom,
                        Display_label=0)

if 0:
    emin = 5
    emax = 20
#        kf_direction = [0, 0]
    kf_direction = 'X>0'  #

    ResolutionAngstrom = False

    # overwriting dict_Materials['smallpro']

    matmother = np.dot(GT.matRot([0, 0, 1], 0), np.eye(3))
#        matmisorient = np.dot(GT.matRot([-1, 1, 1], .1), matmother)

    maingrain = CP.Prepare_Grain('Si', OrientMatrix=matmother)

    grains = [maingrain, maingrain]

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1, detectordistance=70,
                        ResolutionAngstrom=ResolutionAngstrom,
                        Display_label=0)



if 0:
    emin = 5
    emax = 22

    Detpos = 0  # 1 = 'top' 0 = 'trans'

    if Detpos == 1:
        # on top
        kf_direction = 'Z>0'  # reflection
        Detdist = 70  # mm
    elif Detpos == 0:
        # transmission
        kf_direction = 'X>0'  # transmission
        Detdist = 100  # mm

    ResolutionAngstrom = None

    # overwriting dict_Materials['smallpro']
    dict_Materials['smallpro'] = ['smallpro', [20, 4.8, 49, 90, 90, 90], 'no']
    mygrain = CP.Prepare_Grain('smallpro', OrientMatrix=dict_Rot['mat311c1'])
    mygrain = CP.Prepare_Grain('smallpro', OrientMatrix=Id)
    ResolutionAngstrom = 2.


    # mygrain = Prepare_Grain('Cu', OrientMatrix=Id)
    # ResolutionAngstrom = None

    grains = [mygrain]

    LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1,
                        detectordistance=Detdist,
                        ResolutionAngstrom=ResolutionAngstrom)

if 0:
    emin = 5
    emax = 22

    Detpos = 0  # 1 = 'top' 0 = 'trans'

    if Detpos == 1:
        # on top
        kf_direction = 'Z>0'  # reflection
        Detdist = 70  # mm
    elif Detpos == 0:
        # transmission
        kf_direction = 'X>0'  # transmission
        Detdist = 100.  # mm

    ResolutionAngstrom = None

    # overwriting dict_Materials['smallpro']
    dict_Materials['smallpro'] = ['smallpro', [20, 4.8, 49, 90, 90, 90], 'no']
    ResolutionAngstrom = 2.

    for ori in list(dict_Rot.keys())[2:3]:
        mygrain = CP.Prepare_Grain('smallpro', OrientMatrix=dict_Rot[ori])

        grains = [mygrain]

        mydata = LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1,
                        detectordistance=Detdist,
                        ResolutionAngstrom=ResolutionAngstrom)


    ard = np.array(mydata[0])

    import pylab as pp

    pp.figure(1)
    pp.scatter(ard[:, 0], ard[:, 1])

    xyd = np.array([[elem.Xcam, elem.Ycam] for elem in mydata[1][0]])

    pp.figure(2)
    pp.scatter(xyd[:, 0], xyd[:, 1])

    calib = [100., 1024., 1024., 90, 0.]

    SIGN_OF_GAMMA = 1
    xyd_fromfind2 = LTGeo.calc_xycam_from2thetachi(ard[:, 0], ard[:, 1], calib,
                         verbose=0,
                         pixelsize=165. / 2048,
                         dim=(2048, 2048),
                         signgam=SIGN_OF_GAMMA,
                         kf_direction=kf_direction)

    X, Y, theta = xyd_fromfind2


    pp.scatter(X, Y, c='r')

    pp.show()


if 0:
    emin = 50
    emax = 120

    Detpos = 0  # 1 = 'top' 0 = 'trans'

    if Detpos == 1:
        # on top
        kf_direction = 'Z>0'  # reflection
        Detdist = 70  # mm
    elif Detpos == 0:
        # transmission
        kf_direction = 'X>0'  # transmission
        Detdist = 100.  # mm

    ResolutionAngstrom = .5


    for ori in list(dict_Rot.keys())[2:3]:
        mygrain = CP.Prepare_Grain('Ni', OrientMatrix=dict_Rot[ori])

        grains = [mygrain]

        mydata = LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                        Plot_Data=0, verbose=1,
                        detectordistance=Detdist,
                        ResolutionAngstrom=ResolutionAngstrom)


    ard = np.array(mydata[0])

    print("mydata", mydata)

    import pylab as pp

    pp.figure(1)
    pp.scatter(ard[:, 0], ard[:, 1])

    xyd = np.array([[elem.Xcam, elem.Ycam] for elem in mydata[1][0]])

    miller = [elem.Millers for elem in mydata[1][0]]

    print(miller)

    pp.figure(2)
    pp.scatter(xyd[:, 0], xyd[:, 1])

    calib = [105.624, 1017.50, 996.62, -0.027, -116.282]
    pixelsize = 0.048

    SIGN_OF_GAMMA = 1
    xyd_fromfind2 = LTGeo.calc_xycam_from2thetachi(ard[:, 0], ard[:, 1], calib,
                         verbose=0,
                         pixelsize=pixelsize,
                         dim=(2048, 2048),
                         kf_direction=kf_direction,
                         signgam=SIGN_OF_GAMMA)

    X, Y, theta = xyd_fromfind2


    pp.scatter(X, Y, c='r')

    pp.show()

    f = open('Ni_fake_transmission.dat', 'w')
    f.write('X Y I from simulation\n')
    for k in list(range(len(X))):
        f.write('%s %s %s %s %s %s %s %s %s %s %s\n' % (X[k], Y[k], 65000 * (1 - .8 * k / len(X)), 65000 * (1 - .8 * k / len(X)), 1.47, 1.81, 82.460, -1.07, 1.78, 624.74, 64740))
    f.write('# %s pixelsize %s' % (str(calib), pixelsize))
    f.close()

if 0:  # Si 111 in transmission on ID15
    emin = 80
    emax = 100

    Detpos = 0  # 1 = 'top' 0 = 'trans'

    if Detpos == 1:
        # on top
        kf_direction = 'Z>0'  # reflection
        Detdist = 100  # mm
    elif Detpos == 0:
        # transmission
        kf_direction = 'X>0'  # transmission
        Detdist = 100.  # mm

    mattrans3 = [[0.998222982873332, 0.04592237603705288, -0.037973831023250665],
                 [0.0036229001244100726, 0.5893105150537007, 0.8078985031808321],
                 [0.05947899678171664, -0.8066004291012069, 0.5880969279936651]]
    mygrain = CP.Prepare_Grain('Si', OrientMatrix=dict_Rot['mat111alongx'])
    mygrain = CP.Prepare_Grain('Si', OrientMatrix=mattrans3)

    grains = [mygrain]

    mydata = LT.simulatepattern(grains, emin, emax, kf_direction, data_filename,
                             PlotLaueDiagram=0,
                    Plot_Data=0, verbose=1,
                    detectordistance=Detdist,
                    ResolutionAngstrom=None)

    # two theta chi
    ard = np.array(mydata[0])

    print("ard", ard)

    import pylab as pp

    pp.figure(1)
    pp.scatter(ard[:, 0], ard[:, 1])

    # pixel X Y position with default camera settings ...
#         xyd = np.array([[elem.Xcam, elem.Ycam] for elem in mydata[1][0]])
#
#         pp.figure(2)
#         pp.scatter(xyd[:, 0], xyd[:, 1])

    calib = [105., 1024., 1024., 0., 0.]

    SIGN_OF_GAMMA = 1
    xyd_fromfind2 = LTGeo.calc_xycam_from2thetachi(ard[:, 0], ard[:, 1], calib,
                         verbose=0,
                         pixelsize=0.048,
                         dim=(2048, 2048),
                         signgam=SIGN_OF_GAMMA,
                         kf_direction=kf_direction)

    X, Y, theta = xyd_fromfind2

    intensity = np.ones_like(X)

    IOLT.writefile_Peaklist("ID15transSi111", np.array([X, Y, intensity,
                                                               intensity,
                                                               intensity,
                                                               intensity,
                                                               intensity,
                                                               intensity,
                                                               intensity,
                                                               intensity,
                                                               intensity]).T)

    pp.figure(3)
    pp.scatter(X, Y, c='r')

    pp.show()



