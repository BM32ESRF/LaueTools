

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>LaueTools.imageprocessing &mdash; LaueTools  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> LaueTools
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getStarted.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../conventions.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../GUIs.html">Graphical User Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LaueToolsModules.html">LaueTools Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">LaueTools</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>LaueTools.imageprocessing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for LaueTools.imageprocessing</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">imageprocessing module is made to modify filter data array</span>

<span class="sd">More tools can be found in LaueTools package at sourceforge.net and gitlab.esrf.fr</span>
<span class="sd">March 2020</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Jean-Sebastien Micha, CRG-IF BM32 @ ESRF&quot;</span>

<span class="c1"># built-in modules</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># third party modules</span>

<span class="c1"># import scipy.interpolate as sci</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span> <span class="k">as</span> <span class="nn">ssd</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">PIL</span> <span class="k">import</span> <span class="n">Image</span>

    <span class="n">PIL_EXISTS</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Missing python module called PIL. Please install it if you need open some tiff &quot;</span>
            <span class="s2">&quot;images from vhr camera&quot;</span><span class="p">)</span>
    <span class="n">PIL_EXISTS</span> <span class="o">=</span> <span class="kc">False</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">pp</span>

<span class="c1"># lauetools modules</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">generaltools</span> <span class="k">as</span> <span class="n">GT</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">dict_LaueTools</span> <span class="k">as</span> <span class="n">DictLT</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">generaltools</span> <span class="k">as</span> <span class="nn">GT</span>
    <span class="kn">import</span> <span class="nn">dict_LaueTools</span> <span class="k">as</span> <span class="nn">DictLT</span>

<span class="n">listfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">curdir</span><span class="p">)</span>

<div class="viewcode-block" id="getindices2cropArray"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.getindices2cropArray">[docs]</a><span class="k">def</span> <span class="nf">getindices2cropArray</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">halfboxsizeROI</span><span class="p">,</span> <span class="n">arrayshape</span><span class="p">,</span> <span class="n">flipxycenter</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return array indices limits to crop array data</span>

<span class="sd">    :param center: iterable of 2 elements</span>
<span class="sd">             (x,y) pixel center of the ROI</span>
<span class="sd">    :param halfboxsizeROI: integer or iterable of 2 elements</span>
<span class="sd">                     half boxsize ROI in two dimensions</span>
<span class="sd">    :param arrayshape: iterable of 2 integers</span>
<span class="sd">                 maximal number of pixels in both directions</span>

<span class="sd">    :param flipxycenter: boolean</span>
<span class="sd">                   True: swap x and y of center with respect to others</span>
<span class="sd">                   parameters that remain fixed</span>
<span class="sd">    :return: imin, imax, jmin, jmax : 4 integers</span>
<span class="sd">                             4 indices allowing to slice a 2D np.ndarray</span>

<span class="sd">    .. todo::  merge with check_array_indices()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xpic</span><span class="p">,</span> <span class="n">ypic</span> <span class="o">=</span> <span class="n">center</span>
    <span class="k">if</span> <span class="n">flipxycenter</span><span class="p">:</span>
        <span class="n">ypic</span><span class="p">,</span> <span class="n">xpic</span> <span class="o">=</span> <span class="n">center</span>

    <span class="n">xpic</span><span class="p">,</span> <span class="n">ypic</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">xpic</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ypic</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">halfboxsizeROI</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">boxsizex</span><span class="p">,</span> <span class="n">boxsizey</span> <span class="o">=</span> <span class="n">halfboxsizeROI</span><span class="p">,</span> <span class="n">halfboxsizeROI</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">boxsizex</span><span class="p">,</span> <span class="n">boxsizey</span> <span class="o">=</span> <span class="n">halfboxsizeROI</span>

    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xpic</span> <span class="o">-</span> <span class="n">boxsizex</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xpic</span> <span class="o">+</span> <span class="n">boxsizex</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ypic</span> <span class="o">-</span> <span class="n">boxsizey</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ypic</span> <span class="o">+</span> <span class="n">boxsizey</span><span class="p">)</span>

    <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">=</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span>

    <span class="k">return</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span></div>


<div class="viewcode-block" id="check_array_indices"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.check_array_indices">[docs]</a><span class="k">def</span> <span class="nf">check_array_indices</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span><span class="p">,</span> <span class="n">framedim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return 4 indices for array slice compatible with framedim</span>

<span class="sd">    :param imin, imax, jmin, jmax: 4 integers</span>
<span class="sd">                            mini. and maxi. indices in both directions</span>
<span class="sd">    :param framedim: iterable of 2 integers</span>
<span class="sd">               shape of the array to be sliced by means of the 4 indices</span>

<span class="sd">    :return: imin, imax, jmin, jmax: 4 integers</span>
<span class="sd">                            mini. and maxi. indices in both directions</span>

<span class="sd">    .. todo:: merge with getindices2cropArray()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">framedim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;framedim is empty in check_array_indices()&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">imin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">jmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">jmin</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">imax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">framedim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">imax</span><span class="p">)</span>
    <span class="n">jmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">framedim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">jmax</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span></div>


<span class="c1">### Modify images</span>
<div class="viewcode-block" id="to8bits"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.to8bits">[docs]</a><span class="k">def</span> <span class="nf">to8bits</span><span class="p">(</span><span class="n">PILimage</span><span class="p">,</span> <span class="n">normalization_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    convert PIL image (16 bits) in 8 bits PIL image</span>

<span class="sd">    :return:    - [0]  8 bits image</span>
<span class="sd">                - [1] corresponding pixels value array</span>

<span class="sd">    .. todo:: since not used, may be deleted</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">imagesize</span> <span class="o">=</span> <span class="n">PILimage</span><span class="o">.</span><span class="n">size</span>
    <span class="n">image8bits</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="n">imagesize</span><span class="p">)</span>
    <span class="n">rawdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">PILimage</span><span class="o">.</span><span class="n">getdata</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">normalization_value</span><span class="p">:</span>
        <span class="n">normalization_value</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">rawdata</span><span class="p">)</span>
    <span class="n">datatoput</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rawdata</span> <span class="o">/</span> <span class="n">normalization_value</span> <span class="o">*</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
    <span class="n">image8bits</span><span class="o">.</span><span class="n">putdata</span><span class="p">(</span><span class="n">datatoput</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">image8bits</span><span class="p">,</span> <span class="n">datatoput</span></div>


<span class="c1"># --- -------------  getting data from images or ROI</span>
<div class="viewcode-block" id="diff_pix"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.diff_pix">[docs]</a><span class="k">def</span> <span class="nf">diff_pix</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">array_pix</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns</span>
<span class="sd">    index in array_pix which is the closest to pix if below the tolerance radius</span>

<span class="sd">    array_pix: array of 2d pixel points</span>
<span class="sd">    pix: one 2elements pixel point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">pix</span> <span class="o">-</span> <span class="n">array_pix</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">closepix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">closepix</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dist2</span><span class="p">[</span><span class="n">closepix</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">closepix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="minmax"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.minmax">[docs]</a><span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="n">D_array</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">,</span> <span class="n">framedim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span> <span class="n">withmaxpos</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extract min and max from a 2d array in a ROI</span>

<span class="sd">    Obsolete? Still used in LocalMaxima_ShiftArrays()</span>

<span class="sd">    Parameters</span>
<span class="sd">    D_array : 2D array</span>
<span class="sd">              data array</span>
<span class="sd">    center : iterable of 2 integers</span>
<span class="sd">             (x,y) pixel center</span>
<span class="sd">    boxsize : integer or iterable of 2 integers</span>
<span class="sd">              full boxsize defined in both directions</span>
<span class="sd">    framedim : iterable of 2 integers</span>
<span class="sd">               shape of D_array</span>

<span class="sd">    Return</span>
<span class="sd">    [min, max]: minimium and maximum pixel internsity in ROI</span>
<span class="sd">    [min, max],absolute_max_pos : if withmaxpos is True  add in output</span>
<span class="sd">                                  the absolute position of the largest pixel</span>

<span class="sd">    #TODO: replace by scipy.ndimage.extrema</span>
<span class="sd">    # see next functions below</span>
<span class="sd">    # framedim = from dictionary of CCDs</span>
<span class="sd">    D_array shape is flip(framedim)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boxsize</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">boxsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">boxsize</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">)</span>
    <span class="c1">#    print &quot;framedim in minmax&quot;, framedim</span>
    <span class="c1">#    print &quot;D_array.shape&quot;, D_array.shape</span>

    <span class="c1"># halfbox = int(boxsize / 2)</span>

    <span class="c1">#    xc, yc = center</span>
    <span class="c1">#    imin, imax, jmin, jmax = max(0, yc - halfbox), \</span>
    <span class="c1">#                            min(yc + halfbox, framedim[0]), \</span>
    <span class="c1">#                            max(0, xc - halfbox), \</span>
    <span class="c1">#                            min(framedim[1], xc + halfbox)</span>
    <span class="c1">#</span>
    <span class="c1">#    print &quot;imin, imax, jmin, jmax&quot;, imin, imax, jmin, jmax</span>
    <span class="n">framedim</span> <span class="o">=</span> <span class="n">framedim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">framedim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">=</span> <span class="n">getindices2cropArray</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">,</span> <span class="n">framedim</span><span class="p">,</span> <span class="n">flipxycenter</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">#    print &quot;imin, imax, jmin, jmax&quot;, imin, imax, jmin, jmax</span>

    <span class="n">fulldata</span> <span class="o">=</span> <span class="n">D_array</span>
    <span class="n">array_short</span> <span class="o">=</span> <span class="n">fulldata</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">:</span><span class="n">jmax</span><span class="p">]</span>

    <span class="n">mini_in_ROI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">array_short</span><span class="p">)</span>
    <span class="n">maxi_in_ROI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">array_short</span><span class="p">)</span>

    <span class="n">absolute_max_pos</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">maximum_position</span><span class="p">(</span><span class="n">array_short</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">withmaxpos</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mini_in_ROI</span><span class="p">,</span> <span class="n">maxi_in_ROI</span><span class="p">],</span> <span class="n">absolute_max_pos</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mini_in_ROI</span><span class="p">,</span> <span class="n">maxi_in_ROI</span><span class="p">]</span></div>


<div class="viewcode-block" id="getExtrema"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.getExtrema">[docs]</a><span class="k">def</span> <span class="nf">getExtrema</span><span class="p">(</span><span class="n">data2d</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">,</span> <span class="n">framedim</span><span class="p">,</span> <span class="n">ROIcoords</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">flipxycenter</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return  min max XYposmin, XYposmax values in ROI</span>

<span class="sd">    :param ROIcoords: 1 in local array indices coordinates</span>
<span class="sd">                0 in X,Y pixel CCD coordinates</span>
<span class="sd">    :param flipxycenter: boolean like</span>
<span class="sd">                   swap input center coordinates</span>
<span class="sd">    :param data2d: 2D array</span>
<span class="sd">             data array as read by :func:`readCCDimage`</span>

<span class="sd">    :return: min, max, XYposmin, XYposmax:</span>
<span class="sd">        - min : minimum pixel intensity</span>
<span class="sd">        - max : maximum pixel intensity</span>
<span class="sd">        - XYposmin : list of absolute pixel coordinates of lowest pixel</span>
<span class="sd">        - XYposmax : list of absolute pixel coordinates of largest pixel</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;center (peak list) in getExtrema is empty&quot;</span><span class="p">)</span>

    <span class="n">indicesborders</span> <span class="o">=</span> <span class="n">getindices2cropArray</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="p">[</span><span class="n">boxsize</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">],</span> <span class="n">framedim</span><span class="p">,</span>
                                                                        <span class="n">flipxycenter</span><span class="o">=</span><span class="n">flipxycenter</span><span class="p">)</span>
    <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">=</span> <span class="n">indicesborders</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;imin, imax, jmin, jmax&quot;</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span><span class="p">)</span>
    <span class="n">datacropped</span> <span class="o">=</span> <span class="n">data2d</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">:</span><span class="n">jmax</span><span class="p">]</span>

    <span class="c1"># mini, maxi, posmin, posmax</span>

    <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span><span class="p">,</span> <span class="n">posmin</span><span class="p">,</span> <span class="n">posmax</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">extrema</span><span class="p">(</span><span class="n">datacropped</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ROIcoords</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span><span class="p">,</span> <span class="n">posmin</span><span class="p">,</span> <span class="n">posmax</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_i</span><span class="p">,</span> <span class="n">max_j</span> <span class="o">=</span> <span class="n">posmax</span>
        <span class="n">min_i</span><span class="p">,</span> <span class="n">min_j</span> <span class="o">=</span> <span class="n">posmin</span>

        <span class="k">if</span> <span class="n">flipxycenter</span><span class="p">:</span>
            <span class="n">centery</span><span class="p">,</span> <span class="n">centerx</span> <span class="o">=</span> <span class="n">center</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centerx</span><span class="p">,</span> <span class="n">centery</span> <span class="o">=</span> <span class="n">center</span>
        <span class="c1">#        print &quot;local position of maximum i,j&quot;, max_i, max_j</span>

        <span class="n">globalXmax</span> <span class="o">=</span> <span class="n">max_j</span> <span class="o">+</span> <span class="n">centerx</span> <span class="o">-</span> <span class="n">boxsize</span>
        <span class="n">globalYmax</span> <span class="o">=</span> <span class="n">max_i</span> <span class="o">+</span> <span class="n">centery</span> <span class="o">-</span> <span class="n">boxsize</span>

        <span class="n">globalXmin</span> <span class="o">=</span> <span class="n">min_j</span> <span class="o">+</span> <span class="n">centerx</span> <span class="o">-</span> <span class="n">boxsize</span>
        <span class="n">globalYmin</span> <span class="o">=</span> <span class="n">min_i</span> <span class="o">+</span> <span class="n">centery</span> <span class="o">-</span> <span class="n">boxsize</span>

        <span class="c1">#        print &quot;Highest intensity %.f at (X,Y): (%d,%d) &quot; % (maxi, globalX, globalY)</span>
        <span class="k">if</span> <span class="n">flipxycenter</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span><span class="p">,</span> <span class="p">[</span><span class="n">globalYmin</span><span class="p">,</span> <span class="n">globalXmin</span><span class="p">],</span> <span class="p">[</span><span class="n">globalYmax</span><span class="p">,</span> <span class="n">globalXmax</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span><span class="p">,</span> <span class="p">[</span><span class="n">globalXmin</span><span class="p">,</span> <span class="n">globalYmin</span><span class="p">],</span> <span class="p">[</span><span class="n">globalXmax</span><span class="p">,</span> <span class="n">globalYmax</span><span class="p">]</span></div>

<div class="viewcode-block" id="getIntegratedIntensity"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.getIntegratedIntensity">[docs]</a><span class="k">def</span> <span class="nf">getIntegratedIntensity</span><span class="p">(</span><span class="n">data2d</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">,</span> <span class="n">framedim</span><span class="p">,</span>
                                                        <span class="n">thresholdlevel</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">flipxycenter</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return  crude estimate of integrated intensity of peak above a given relative threshold</span>

<span class="sd">    :param ROIcoords: 1 in local array indices coordinates</span>
<span class="sd">                0 in X,Y pixel CCD coordinates</span>
<span class="sd">    :param flipxycenter: boolean like</span>
<span class="sd">                   swap input center coordinates</span>
<span class="sd">    :param data2d: 2D array</span>
<span class="sd">             data array as read by :func:`readCCDimage`</span>

<span class="sd">    :param Thresholdlevel:  relative level above which pixel intensity must be taken into account</span>
<span class="sd">                I(p)- minimum&gt; Thresholdlevel* (maximum-minimum)</span>

<span class="sd">    :return: integrated intensity, minimum absolute intensity, nbpixels used for the summation</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">center</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;center (peak list) in getExtrema is empty&quot;</span><span class="p">)</span>

    <span class="n">indicesborders</span> <span class="o">=</span> <span class="n">getindices2cropArray</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="p">[</span><span class="n">boxsize</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">],</span> <span class="n">framedim</span><span class="p">,</span> <span class="n">flipxycenter</span><span class="o">=</span><span class="n">flipxycenter</span><span class="p">)</span>
    <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">=</span> <span class="n">indicesborders</span>

    <span class="c1">#     print &quot;imin, imax, jmin, jmax&quot;, imin, imax, jmin, jmax</span>
    <span class="n">datacropped</span> <span class="o">=</span> <span class="n">data2d</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">:</span><span class="n">jmax</span><span class="p">]</span>

    <span class="c1"># mini, maxi, posmin, posmax</span>
    <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">extrema</span><span class="p">(</span><span class="n">datacropped</span><span class="p">)</span>

    <span class="n">minimum_amplitude</span> <span class="o">=</span> <span class="n">thresholdlevel</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxi</span> <span class="o">-</span> <span class="n">mini</span><span class="p">)</span> <span class="o">+</span> <span class="n">mini</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;integration for pixel intensity higher than: &quot;</span><span class="p">,</span> <span class="n">minimum_amplitude</span><span class="p">)</span>
    <span class="n">pixelsabove</span> <span class="o">=</span> <span class="n">datacropped</span><span class="p">[</span><span class="n">datacropped</span> <span class="o">&gt;</span> <span class="n">minimum_amplitude</span><span class="p">]</span>
    <span class="n">nbpixels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pixelsabove</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb pixels above threshold  &quot;</span><span class="p">,</span> <span class="n">nbpixels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pixelsabove</span><span class="p">),</span> <span class="n">minimum_amplitude</span><span class="p">,</span> <span class="n">nbpixels</span></div>


<div class="viewcode-block" id="getMinMax"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.getMinMax">[docs]</a><span class="k">def</span> <span class="nf">getMinMax</span><span class="p">(</span><span class="n">data2d</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">,</span> <span class="n">framedim</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return min and max values in ROI</span>

<span class="sd">    Parameters:</span>

<span class="sd">    data2d : 2D array</span>
<span class="sd">             array as read by readCCDimage</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">getExtrema</span><span class="p">(</span><span class="n">data2d</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">,</span> <span class="n">framedim</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span></div>


<div class="viewcode-block" id="minmax_fast"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.minmax_fast">[docs]</a><span class="k">def</span> <span class="nf">minmax_fast</span><span class="p">(</span><span class="n">D_array</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">boxsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extract min (considered as background in boxsize) and intensity at center</span>
<span class="sd">    from a 2d array at different places (centers)</span>

<span class="sd">    centers is tuple a two array (  array([slow indices]),  array([fast indices]))</span>

<span class="sd">    return:</span>

<span class="sd">    [0] background values</span>
<span class="sd">    [1] intensity value</span>

<span class="sd">    used?</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">min_array</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">minimum_filter</span><span class="p">(</span><span class="n">D_array</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">boxsize</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">min_array</span><span class="p">[</span><span class="n">centers</span><span class="p">],</span> <span class="n">D_array</span><span class="p">[</span><span class="n">centers</span><span class="p">]]</span></div>





<span class="c1"># --- ------------- Mexican Hat 2D kernel</span>
<span class="k">def</span> <span class="nf">myfromfunction</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>


<div class="viewcode-block" id="normalize_shape"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.normalize_shape">[docs]</a><span class="k">def</span> <span class="nf">normalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return shape</span>
<span class="sd">    in case a scalar was given:</span>
<span class="sd">    return (shape,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shape</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span></div>


<div class="viewcode-block" id="LoG"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.LoG">[docs]</a><span class="k">def</span> <span class="nf">LoG</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">r0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peakVal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;note:</span>
<span class="sd">         returns *negative* Laplacian-of-Gaussian (aka. mexican hat)</span>
<span class="sd">         zero-point will be at sqrt(dim)*sigma</span>
<span class="sd">         integral is _always_ 0</span>
<span class="sd">         if peakVal is None:  uses &quot;mathematical&quot; &quot;gaussian derived&quot; norm</span>
<span class="sd">         if r0 is not None: specify radius of zero-point (IGNORE sigma !!)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of sigma or r0 have to be non-None&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of sigma or r0 can be non-None&quot;</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">dsd</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="n">dim</span>

    <span class="k">if</span> <span class="n">peakVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">peakVal</span> <span class="o">/</span> <span class="n">dsd</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">s2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">s2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">dsd</span> <span class="o">-</span> <span class="n">r2</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span></div>


<div class="viewcode-block" id="LoGArr"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.LoGArr">[docs]</a><span class="k">def</span> <span class="nf">LoGArr</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
                <span class="n">r0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">peakVal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">orig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">wrap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;returns n-dim Laplacian-of-Gaussian (aka. mexican hat)</span>
<span class="sd">    if peakVal   is not None</span>
<span class="sd">         result max is peakVal</span>
<span class="sd">    if r0 is not None: specify radius of zero-point (IGNORE sigma !!)</span>

<span class="sd">    credits: &quot;Sebastian Haase &lt;haase@msg.ucsf.edu&gt;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">normalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">radialArr</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">LoG</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">r0</span><span class="o">=</span><span class="n">r0</span><span class="p">,</span> <span class="n">peakVal</span><span class="o">=</span><span class="n">peakVal</span><span class="p">),</span>
                    <span class="n">orig</span><span class="p">,</span>
                    <span class="n">wrap</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="radialArr"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.radialArr">[docs]</a><span class="k">def</span> <span class="nf">radialArr</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">orig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;generates and returns radially symmetric function sampled in volume(image) of shape shape</span>
<span class="sd">    if orig is None the origin defaults to the center</span>
<span class="sd">    func is a 1D function with 1 paramater: r</span>

<span class="sd">    if shape is a scalar uses implicitely `(shape,)`</span>
<span class="sd">    wrap tells if functions is continued wrapping around image boundaries</span>
<span class="sd">    wrap can be True or False or a tuple same length as shape:</span>
<span class="sd">       then wrap is given for each axis sperately</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">normalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">orig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">oo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span>
            <span class="n">orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span> <span class="o">*</span> <span class="n">oo</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape and orig not same dimension&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrap</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrap tuple must be same length as shape&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">wrap</span> <span class="o">=</span> <span class="p">(</span><span class="n">wrap</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapIt</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span>
            <span class="n">nq</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="n">nq</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">q</span> <span class="o">-</span> <span class="n">nq</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">q</span>

    <span class="c1">#     if wrap:</span>
    <span class="c1">#         def wrapIt(q, nq):</span>
    <span class="c1">#             return np.where(q&gt;nq/2,q-nq, q)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         def wrapIt(q, nq):</span>
    <span class="c1">#             return q</span>

    <span class="c1">#     if len(shape) == 1:</span>
    <span class="c1">#         x0 = orig[0]  # 20060606: [0] prevents orig (as array) promoting its dtype (e.g. Float64) into result</span>
    <span class="c1">#         nx = shape[0]</span>
    <span class="c1">#         return myfromfunction(lambda x: func(wrapIt(np.absolute(x-x0),nx)), shape, dtype)</span>
    <span class="c1">#     elif len(shape) == 2:</span>
    <span class="c1">#         y0,x0 = orig</span>
    <span class="c1">#         ny,nx=shape</span>
    <span class="c1">#         return myfromfunction(lambda y,x: func(</span>
    <span class="c1">#                                              np.sqrt( \</span>
    <span class="c1">#             (wrapIt((x-x0),nx))**2 + (wrapIt((y-y0),ny))**2 ) ), shape, dtype)</span>
    <span class="c1">#     elif len(shape) == 3:</span>
    <span class="c1">#         z0,y0,x0 = orig</span>
    <span class="c1">#         nz,ny,nx=shape</span>
    <span class="c1">#         return myfromfunction(lambda z,y,x: func(</span>
    <span class="c1">#                                              np.sqrt( \</span>
    <span class="c1">#             (wrapIt((x-x0),nx))**2 + (wrapIt((y-y0),ny))**2 + (wrapIt((z-z0),nz))**2 ) ), shape, dtype)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 20060606: [0] prevents orig (as array) promoting its dtype (e.g. Float64) into result</span>
        <span class="k">return</span> <span class="n">myfromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">wrapIt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">))),</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">orig</span>
        <span class="k">return</span> <span class="n">myfromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">wrapIt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">wrapIt</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">),</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">z0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">orig</span>
        <span class="k">return</span> <span class="n">myfromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">wrapIt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">wrapIt</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">wrapIt</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="n">z0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only defined for dim &lt; 3 (#TODO)&quot;</span><span class="p">)</span></div>


<span class="c1"># --- --------------------  Local Maxima or Local Hot pixels search</span>
<div class="viewcode-block" id="LocalMaxima_ndimage"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.LocalMaxima_ndimage">[docs]</a><span class="k">def</span> <span class="nf">LocalMaxima_ndimage</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span>
                        <span class="n">peakVal</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                        <span class="n">boxsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                        <span class="n">central_radius</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                        <span class="n">threshold</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">returnfloatmeanpos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">autothresholdpercentage</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns (float) i,j positions in array of each blob</span>
<span class="sd">    (peak, spot, assembly of hot pixels or whatever)</span>

<span class="sd">    .. note:: used only in LocalMaxima_KernelConvolution</span>

<span class="sd">    inputs</span>

<span class="sd">    peakVal, boxsize, central_radius:</span>
<span class="sd">        parameters for numerical convolution with a mexican-hat-like kernel</span>

<span class="sd">    threshold:</span>
<span class="sd">        intensity threshold of filtered Data (by convolution with the kernel)</span>
<span class="sd">        above which blob signal will be considered</span>
<span class="sd">        if = 0 : take all blobs at the expense of processing time</span>

<span class="sd">    connectivity :</span>
<span class="sd">        1 for filled square 3*3 connectivity</span>
<span class="sd">        0 for 3*3 star like connectivity</span>

<span class="sd">    autothresholdpercentage :</span>
<span class="sd">        threshold in filtered image with respect to the maximum intensity in filtered image</span>

<span class="sd">    output:</span>
<span class="sd">    array (n,2): array of 2 indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">aa</span> <span class="o">=</span> <span class="n">ConvolvebyKernel</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">peakVal</span><span class="o">=</span><span class="n">peakVal</span><span class="p">,</span> <span class="n">boxsize</span><span class="o">=</span><span class="n">boxsize</span><span class="p">,</span> <span class="n">central_radius</span><span class="o">=</span><span class="n">central_radius</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Histogram after convolution with Mexican Hat&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">autothresholdpercentage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">thraa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aa</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">thraa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aa</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">autothresholdpercentage</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">aa</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">thraa</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">star</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">thraa</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">thraa</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>
    <span class="k">elif</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="n">ll</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">thraa</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>

    <span class="c1">#     meanpos = np.array(ndimage.measurements.center_of_mass(thraa,</span>
    <span class="c1">#                                                     ll,</span>
    <span class="c1">#                                                     np.arange(1, nf + 1)),</span>
    <span class="c1">#                                                     dtype=np.float)</span>

    <span class="n">meanpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">maximum_position</span><span class="p">(</span><span class="n">thraa</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
                                                                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">returnfloatmeanpos</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">meanpos</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">meanpos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConvolvebyKernel"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.ConvolvebyKernel">[docs]</a><span class="k">def</span> <span class="nf">ConvolvebyKernel</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">peakVal</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">boxsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">central_radius</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve Data array witn mexican-hat kernel</span>

<span class="sd">    inputs:</span>
<span class="sd">    Data                            : 2D array containing pixel intensities</span>
<span class="sd">    peakVal &gt; central_radius        : defines pixel distance from box center where weights are positive</span>
<span class="sd">                                    (in the middle) and negative farther to converge back to zero</span>
<span class="sd">    boxsize                            : size of the box</span>

<span class="sd">    ouput:</span>
<span class="sd">    array  (same shape as Data)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># from scipy import ndimage</span>

    <span class="c1"># outa = np.zeros(Data.shape)</span>
    <span class="c1"># ndimage.filters.gaussian_laplace(d,(5,5),output=outa)</span>

    <span class="c1"># whole_structure= createstructure(10, 10)-2*createstructure(10, 7)+4*createstructure(10, 5)</span>
    <span class="c1"># bb= ndimage.convolve(d,whole_structure)</span>

    <span class="c1"># bb=ndimage.morphology.white_tophat(Data,(boxsize,boxsize))</span>
    <span class="c1"># mexicanhat = array(LoGArr((10,10),r0=6,peakVal=4),dtype= int16)</span>

    <span class="n">mexicanhat</span> <span class="o">=</span> <span class="n">LoGArr</span><span class="p">((</span><span class="n">boxsize</span><span class="p">,</span> <span class="n">boxsize</span><span class="p">),</span> <span class="n">r0</span><span class="o">=</span><span class="n">central_radius</span><span class="p">,</span> <span class="n">peakVal</span><span class="o">=</span><span class="n">peakVal</span><span class="p">)</span>
    <span class="n">mexicanhat</span> <span class="o">=</span> <span class="n">mexicanhat</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mexicanhat</span><span class="p">)</span> <span class="o">/</span> <span class="n">mexicanhat</span><span class="o">.</span><span class="n">size</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">mexicanhat</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bb</span></div>


<div class="viewcode-block" id="LocalMaxima_KernelConvolution"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.LocalMaxima_KernelConvolution">[docs]</a><span class="k">def</span> <span class="nf">LocalMaxima_KernelConvolution</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">framedim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                            <span class="n">peakValConvolve</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">boxsizeConvolve</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">central_radiusConvolve</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">thresholdConvolve</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                            <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">IntensityThreshold</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                            <span class="n">boxsize_for_probing_minimal_value_background</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                            <span class="n">return_nb_raw_blobs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">peakposition_definition</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">):</span>  <span class="c1"># full side length</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return local maxima (blobs) position and amplitude in Data by using</span>
<span class="sd">    convolution with a mexican hat like kernel.</span>

<span class="sd">    Two Thresholds are used sequently:</span>
<span class="sd">        - thresholdConvolve : level under which intensity of kernel-convolved array is discarded</span>
<span class="sd">        - IntensityThreshold : level under which blob whose local intensity amplitude in raw array is discarded</span>

<span class="sd">    :param Data: 2D array containing pixel intensities</span>

<span class="sd">    :param peakValConvolve, boxsizeConvolve, central_radiusConvolve: convolution kernel parameters</span>

<span class="sd">    :param thresholdConvolve: minimum threshold (expressed in unit of convolved array intensity)</span>
<span class="sd">                        under which convoluted blob is rejected.It can be zero</span>
<span class="sd">                        (all blobs are accepted but time consuming)</span>
<span class="sd">    :param connectivity: shape of connectivity pattern to consider pixels belonging to the</span>
<span class="sd">                   same blob.</span>
<span class="sd">                       - 1: filled square  (1 pixel connected to 8 neighbours)</span>
<span class="sd">                       - 0: star (4 neighbours in vertical and horizontal direction)</span>

<span class="sd">    :param IntensityThreshold: minimum local blob amplitude to accept</span>

<span class="sd">    :param boxsize_for_probing_minimal_value_background: boxsize to evaluate the background</span>
<span class="sd">                                                        and the blob amplitude</span>

<span class="sd">    :param peakposition_definition: string (&#39;max&#39; or &#39;center&#39;)</span>
<span class="sd">                              key to assign to the blob position its hottest pixel position</span>
<span class="sd">                              or its center (no weight)</span>
<span class="sd">    :return:</span>
<span class="sd">        peakslist : array like (n,2)</span>
<span class="sd">                list of peaks position (pixel)</span>
<span class="sd">        Ipixmax : array like (n,1) of integer</span>
<span class="sd">             list of highest pixel intensity in the vicinity of each peak</span>
<span class="sd">        npeaks : integer</span>
<span class="sd">             nb of peaks (if return_nb_raw_blobs =1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;framedim in LocalMaxima_KernelConvolution&quot;</span><span class="p">,</span> <span class="n">framedim</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data.shape&quot;</span><span class="p">,</span> <span class="n">Data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">dataimage_ROI</span> <span class="o">=</span> <span class="n">Data</span>

    <span class="n">peak</span> <span class="o">=</span> <span class="n">LocalMaxima_ndimage</span><span class="p">(</span><span class="n">dataimage_ROI</span><span class="p">,</span>
                                <span class="n">peakVal</span><span class="o">=</span><span class="n">peakValConvolve</span><span class="p">,</span>
                                <span class="n">boxsize</span><span class="o">=</span><span class="n">boxsizeConvolve</span><span class="p">,</span>
                                <span class="n">central_radius</span><span class="o">=</span><span class="n">central_radiusConvolve</span><span class="p">,</span>
                                <span class="n">threshold</span><span class="o">=</span><span class="n">thresholdConvolve</span><span class="p">,</span>
                                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                                <span class="n">returnfloatmeanpos</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">peak</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">peak</span> <span class="o">=</span> <span class="p">(</span><span class="n">peak</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">peak</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">intensity_localmaxima</span> <span class="o">=</span> <span class="n">dataimage_ROI</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span>

    <span class="n">peaki</span> <span class="o">=</span> <span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">peakj</span> <span class="o">=</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># building an array of hot pixels (2 coordinates)</span>
    <span class="n">Yarray</span> <span class="o">=</span> <span class="n">peakj</span>
    <span class="n">Xarray</span> <span class="o">=</span> <span class="n">peaki</span>
    <span class="n">peaklist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xarray</span><span class="p">,</span> <span class="n">Yarray</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#    print &quot;peaklist&quot;, peaklist</span>
    <span class="c1">#     print &quot;%d local maxima have been found from convolution method&quot; % len(peaklist)</span>
    <span class="c1">#    print &quot;peaklist[:3]&quot;, peaklist[:3]</span>

    <span class="c1"># probing background and maximal intensity in boxsize</span>
    <span class="c1">#</span>
    <span class="n">ptp_boxsize</span> <span class="o">=</span> <span class="n">boxsize_for_probing_minimal_value_background</span>

    <span class="c1"># first method ---------------------------</span>
    <span class="n">tabptp</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># tab of min and max around each peak</span>
    <span class="n">tabposmax</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># # tab of position of hottest pixel close to that found after convolution</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaklist</span><span class="p">))):</span>
        <span class="c1">#        print &quot;k in LocalMaxima_KernelConvolution&quot;, k</span>
        <span class="c1">#        print &quot;dataimage_ROI.shape&quot;, dataimage_ROI.shape</span>
        <span class="n">minimaxi</span><span class="p">,</span> <span class="n">maxpos</span> <span class="o">=</span> <span class="n">minmax</span><span class="p">(</span><span class="n">dataimage_ROI</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ptp_boxsize</span><span class="p">,</span> <span class="n">framedim</span><span class="o">=</span><span class="n">framedim</span><span class="p">,</span> <span class="n">withmaxpos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tabptp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minimaxi</span><span class="p">)</span>
        <span class="c1">#         if minimaxi[1] &gt; 4000:</span>
        <span class="c1">#             print &quot;k, peaklist[k]&quot;, k, peaklist[k]</span>
        <span class="c1">#             print maxpos, minimaxi[1]</span>

        <span class="c1">#        mini, maxi, minpos, maxpos = getExtrema(dataimage_ROI, peaklist[k], ptp_boxsize, framedim,</span>
        <span class="c1">#                                                ROIcoords=0,</span>
        <span class="c1">#                                                flipxycenter=1)</span>
        <span class="c1">#</span>
        <span class="c1">#        tabptp.append([mini, maxi])</span>
        <span class="c1">#</span>
        <span class="c1">#        if maxi &gt; 4000:</span>
        <span class="c1">#            print &quot;k, peaklist[k]&quot;, k, peaklist[k]</span>
        <span class="c1">#            print maxpos, maxi</span>

        <span class="n">tabposmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxpos</span><span class="p">)</span>  <span class="c1"># # new</span>

    <span class="c1">#    # to test peaks position / framedim</span>
    <span class="c1">#    print minmax(dataimage_ROI,</span>
    <span class="c1">#                                 [2580, 2750],</span>
    <span class="c1">#                                ptp_boxsize,</span>
    <span class="c1">#                                framedim=framedim,</span>
    <span class="c1">#                                withmaxpos=1)</span>

    <span class="n">ar_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tabptp</span><span class="p">)</span>
    <span class="n">ar_posmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tabposmax</span><span class="p">)</span>  <span class="c1"># # new</span>

    <span class="c1">#     print &#39; ar_posmax[:3]&#39;, ar_posmax[:10]</span>
    <span class="c1">#     print &#39; ar_posmax[:3]&#39;, ar_posmax[10:20]</span>
    <span class="c1">#     print &#39; ar_posmax[:3]&#39;, ar_posmax[20:30]</span>

    <span class="c1">#     print &quot;saturation at&quot;, np.where(ar_ptp &gt; 65000.)</span>
    <span class="c1"># -------------------------------------------</span>

    <span class="c1"># second method ---------------</span>
    <span class="c1"># tabptp = minmax_fast(dataimage_ROI,</span>
    <span class="c1">#                 tuple(transpose(peaklist)),</span>
    <span class="c1">#                    boxsize=(boxsize_for_probing_minimal_value_background,</span>
    <span class="c1">#                                boxsize_for_probing_minimal_value_background))</span>
    <span class="c1"># ar_ptp = array(tabptp).T</span>
    <span class="c1"># ---------------------------------</span>

    <span class="c1"># ar_amp = np.subtract(ar_ptp[:,1],ar_ptp[:,0])</span>
    <span class="n">ar_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">intensity_localmaxima</span><span class="p">,</span> <span class="n">ar_ptp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">amp_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ar_amp</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">peaklist_sorted</span> <span class="o">=</span> <span class="n">peaklist</span><span class="p">[</span><span class="n">amp_rank</span><span class="p">]</span>
    <span class="n">ptp_sorted</span> <span class="o">=</span> <span class="n">ar_ptp</span><span class="p">[</span><span class="n">amp_rank</span><span class="p">]</span>
    <span class="n">amp_sorted</span> <span class="o">=</span> <span class="n">ar_amp</span><span class="p">[</span><span class="n">amp_rank</span><span class="p">]</span>
    <span class="n">posmax_sorted</span> <span class="o">=</span> <span class="n">ar_posmax</span><span class="p">[</span><span class="n">amp_rank</span><span class="p">]</span>  <span class="c1"># # new</span>
    <span class="c1"># thresholding on peak-to-peak amplitude</span>
    <span class="n">threshold_amp</span> <span class="o">=</span> <span class="n">IntensityThreshold</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">amp_sorted</span> <span class="o">&gt;</span> <span class="n">threshold_amp</span><span class="p">)</span>
    <span class="n">th_peaklist</span> <span class="o">=</span> <span class="n">peaklist_sorted</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
    <span class="n">th_ar_ptp</span> <span class="o">=</span> <span class="n">ptp_sorted</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
    <span class="n">th_ar_amp</span> <span class="o">=</span> <span class="n">amp_sorted</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
    <span class="n">th_ar_pos</span> <span class="o">=</span> <span class="n">posmax_sorted</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>  <span class="c1"># # new</span>

    <span class="c1">#     print &quot;th_ar_ptp&quot;, th_ar_ptp[:10]</span>

    <span class="c1">##### peak positions that will be returned are the hottest pixels</span>
    <span class="k">if</span> <span class="n">peakposition_definition</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
        <span class="n">th_peaklist</span> <span class="o">=</span> <span class="n">th_ar_pos</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># using th_peaklist which is float position</span>
        <span class="k">pass</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> local maxima found after thresholding above </span><span class="si">{}</span><span class="s2"> (amplitude above local background)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">th_ar_amp</span><span class="p">),</span> <span class="n">threshold_amp</span><span class="p">))</span>

    <span class="c1"># NEW --- from method array shift!</span>
    <span class="c1"># remove duplicates (close points), the most intense pixel is kept</span>
    <span class="c1"># minimum distance between hot pixel</span>
    <span class="c1"># it corresponds both to distance between peaks and peak size ...</span>
    <span class="n">pixeldistance</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># pixeldistance_remove_duplicates</span>

    <span class="n">purged_pklist</span><span class="p">,</span> <span class="n">index_todelete</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">purgeClosePoints2</span><span class="p">(</span><span class="n">th_peaklist</span><span class="p">,</span> <span class="n">pixeldistance</span><span class="p">)</span>

    <span class="n">purged_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">th_ar_amp</span><span class="p">,</span> <span class="n">index_todelete</span><span class="p">)</span>
    <span class="n">purged_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">th_ar_ptp</span><span class="p">,</span> <span class="n">index_todelete</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#     print &#39;shape of purged_ptp method conv.&#39;, purged_ptp.shape</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> local maxima found after removing duplicates (minimum intermaxima distance = </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">purged_amp</span><span class="p">),</span> <span class="n">pixeldistance</span><span class="p">))</span>

    <span class="c1"># print &quot;purged_pklist&quot;, purged_pklist</span>
    <span class="c1">#     print &quot;shape(purged_pklist)&quot;, np.shape(purged_pklist)</span>

    <span class="n">npeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">purged_pklist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># print np.shape(Data)</span>

    <span class="n">Ipixmax</span> <span class="o">=</span> <span class="n">purged_ptp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print &quot;Ipixmax = &quot;, Ipixmax</span>

    <span class="n">peakslist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">purged_pklist</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_nb_raw_blobs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">peakslist</span><span class="p">,</span> <span class="n">Ipixmax</span><span class="p">,</span> <span class="n">npeaks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">peakslist</span><span class="p">,</span> <span class="n">Ipixmax</span></div>

    <span class="c1"># NEW --- !</span>
    <span class="c1"># -----------------------</span>


<span class="c1">#     npeaks = np.shape(th_peaklist)[0]</span>
<span class="c1">#     Ipixmax = np.zeros(npeaks, dtype=int)</span>
<span class="c1">#     # print np.shape(Data)</span>
<span class="c1">#     for i in list(range(npeaks)):</span>
<span class="c1">#         # Ipixmax[i]=Data[th_peaklist[i,0],th_peaklist[i,1]]</span>
<span class="c1">#         Ipixmax[i] = th_ar_ptp[i][1]</span>
<span class="c1">#</span>
<span class="c1">#     if return_nb_raw_blobs == 1:</span>
<span class="c1">#         return np.fliplr(th_peaklist), Ipixmax, len(peaklist)</span>
<span class="c1">#     else:</span>
<span class="c1">#         return np.fliplr(th_peaklist), Ipixmax</span>


<div class="viewcode-block" id="LocalMaxima_ShiftArrays"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.LocalMaxima_ShiftArrays">[docs]</a><span class="k">def</span> <span class="nf">LocalMaxima_ShiftArrays</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">framedim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span> <span class="n">IntensityThreshold</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                                <span class="n">Saturation_value</span><span class="o">=</span><span class="mi">65535</span><span class="p">,</span>
                                <span class="n">boxsize_for_probing_minimal_value_background</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>  <span class="c1"># full side length</span>
                                <span class="n">nb_of_shift</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                                <span class="n">pixeldistance_remove_duplicates</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; blob search or local maxima search by shift array method (kind of derivative)</span>

<span class="sd">    .. warning:: Flat peak (= two neighbouring pixel with rigourouslty the same intensity)</span>
<span class="sd">            is not detected</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">NX</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">***********************************************************&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;networkx module is missing! Some functions may not work...</span><span class="se">\n</span><span class="s2">Please install it at http://networkx.github.io/&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;***********************************************************</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">xminfit2d</span><span class="p">,</span> <span class="n">xmaxfit2d</span><span class="p">,</span> <span class="n">yminfit2d</span><span class="p">,</span> <span class="n">ymaxfit2d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">framedim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">framedim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># warning i corresponds to y</span>
    <span class="c1"># j corresponds to x</span>
    <span class="c1"># change nom xminf2d =&gt; xminfit2d pour coherence avec le reste</span>

    <span class="n">imin</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span><span class="n">framedim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ymaxfit2d</span><span class="p">,</span>
                                <span class="n">framedim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">yminfit2d</span><span class="p">,</span>
                                <span class="n">xminfit2d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="n">xmaxfit2d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># dataimage_ROI=dataimage[imin:imax,jmin:jmax]# array index   i,j</span>
    <span class="c1"># # fit2d index:  X=j Y=2048-i</span>

    <span class="n">dataimage_ROI</span> <span class="o">=</span> <span class="n">Data</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;searching local maxima for non saturated consecutive pixels&quot;</span><span class="p">)</span>

    <span class="n">peak</span> <span class="o">=</span> <span class="n">localmaxima</span><span class="p">(</span><span class="n">dataimage_ROI</span><span class="p">,</span> <span class="n">nb_of_shift</span><span class="p">,</span> <span class="n">diags</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done...!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
    <span class="c1"># print &quot;execution time : %f  secondes&quot;%(ttt.time()-time_0)</span>

    <span class="n">intensity_localmaxima</span> <span class="o">=</span> <span class="n">dataimage_ROI</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span>
    <span class="c1"># print intensity_localmaxima</span>

    <span class="c1"># SATURATION handling ------------------------------</span>
    <span class="c1"># if the top of the local maximum has at least two pixels with the same intensity, this maximum is not detected</span>
    <span class="c1"># this generally the case for saturated peaks</span>
    <span class="c1"># saturation value : saturation above which we will take into account the pixel</span>
    <span class="c1"># this value may be lower than the 2^n bits value to handle unfortunately very flat weak peak with 2 neighbouring pixels</span>
    <span class="c1"># Saturation_value = 65535 for mccd</span>
    <span class="n">Size_of_pixelconnection</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saturation value for flat top peak handling&quot;</span><span class="p">,</span> <span class="n">Saturation_value</span><span class="p">)</span>
    <span class="n">sat_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dataimage_ROI</span> <span class="o">&gt;=</span> <span class="n">Saturation_value</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;positions of saturated pixels </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sat_pix</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of saturated pixels&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sat_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">sat_pix_mean</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># there is at least one peak above or equal to the Saturation_value threshold</span>
    <span class="c1"># loop over saturated pixels</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sat_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;positions of saturated pixels </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sat_pix</span><span class="p">)</span>

        <span class="c1"># use of graph algorithms</span>
        <span class="n">sat_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">sat_pix</span><span class="p">)</span>

        <span class="n">disttable_sat</span> <span class="o">=</span> <span class="n">ssd</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">sat_pix</span><span class="p">,</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
        <span class="n">sqdistmatrix_sat</span> <span class="o">=</span> <span class="n">ssd</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">disttable_sat</span><span class="p">)</span>
        <span class="c1"># building adjencymat</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">sqdistmatrix_sat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">indymat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sqdistmatrix_sat</span> <span class="o">&lt;</span> <span class="n">Size_of_pixelconnection</span><span class="p">,</span> <span class="n">sqdistmatrix_sat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">adjencymat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond2</span><span class="p">,</span> <span class="n">indymat</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># print &quot;before networkx&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;networkx version&quot;</span><span class="p">,</span> <span class="n">NX</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
        <span class="n">GGraw</span> <span class="o">=</span> <span class="n">NX</span><span class="o">.</span><span class="n">to_networkx_graph</span><span class="p">(</span><span class="n">adjencymat</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">NX</span><span class="o">.</span><span class="n">Graph</span><span class="p">())</span>
        <span class="n">list_of_cliques</span> <span class="o">=</span> <span class="n">NX</span><span class="o">.</span><span class="n">find_cliques</span><span class="p">(</span><span class="n">GGraw</span><span class="p">)</span>
        <span class="c1"># print &quot;after networkx&quot;</span>

        <span class="c1"># now find average pixel of each clique</span>
        <span class="n">sat_pix_mean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">clique</span> <span class="ow">in</span> <span class="n">list_of_cliques</span><span class="p">:</span>
            <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sat_pix</span><span class="p">[</span><span class="n">clique</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sat_pix_mean</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">ii</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">jj</span><span class="p">)])</span>

        <span class="n">sat_pix_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sat_pix_mean</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean position of saturated pixels blobs = </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sat_pix_mean</span><span class="p">)</span>

        <span class="c1"># if 0:  # of scipy.ndimage</span>

        <span class="c1">#     df = ndimage.gaussian_filter(dataimage_ROI, 10)</span>

        <span class="c1">#     # histo = np.histogram(df)</span>
        <span class="c1">#     # print &quot;histogram&quot;,histo</span>
        <span class="c1">#     # print &quot;maxinten&quot;,np.amax(df)</span>
        <span class="c1">#     threshold_for_measurements = (</span>
        <span class="c1">#         np.amax(df) / 10.0</span>
        <span class="c1">#     )  # histo[1][1]# 1000  pour CdTe # 50 pour Ge</span>

        <span class="c1">#     tG = np.where(df &gt; threshold_for_measurements, 1, 0)</span>
        <span class="c1">#     ll, nf = ndimage.label(tG)  # , structure = np.ones((3,3)))</span>
        <span class="c1">#     meanpos = np.array(</span>
        <span class="c1">#         ndimage.measurements.center_of_mass(tG, ll, np.arange(1, nf + 1)), dtype=float)</span>
        <span class="c1">#     # meanpos = np.fliplr(meanpos)  # this done later</span>

        <span class="c1">#     # print &quot;meanpos&quot;,meanpos</span>

        <span class="c1">#     sat_pix_mean = meanpos</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No pixel saturation&quot;</span><span class="p">)</span>
    <span class="c1"># SATURATION handling -(End) --------------------------------------------------------</span>

    <span class="c1"># x,y from localmaxima is a matter of convention</span>

    <span class="n">peaki</span> <span class="o">=</span> <span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">imin</span>
    <span class="n">peakj</span> <span class="o">=</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jmin</span>

    <span class="c1"># building an array of hot pixels (2 coordinates)</span>
    <span class="n">Yarray</span> <span class="o">=</span> <span class="n">peakj</span>
    <span class="n">Xarray</span> <span class="o">=</span> <span class="n">peaki</span>
    <span class="n">peaklist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xarray</span><span class="p">,</span> <span class="n">Yarray</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># print peaklistfit2D</span>
    <span class="c1"># print peaklist[100:150]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> local maxima have been found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaklist</span><span class="p">)))</span>

    <span class="c1"># probing background and maximal intensity in boxsize</span>
    <span class="c1">#</span>
    <span class="n">ptp_boxsize</span> <span class="o">=</span> <span class="n">boxsize_for_probing_minimal_value_background</span>

    <span class="n">tabptp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaklist</span><span class="p">))):</span>
        <span class="n">tabptp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minmax</span><span class="p">(</span><span class="n">dataimage_ROI</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ptp_boxsize</span><span class="p">,</span> <span class="n">framedim</span><span class="o">=</span><span class="n">framedim</span><span class="p">))</span>

    <span class="n">ar_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tabptp</span><span class="p">)</span>
    <span class="c1"># ar_amp = np.subtract(ar_ptp[:,1],ar_ptp[:,0])</span>
    <span class="n">ar_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">intensity_localmaxima</span><span class="p">,</span> <span class="n">ar_ptp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">amp_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ar_amp</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">peaklist_sorted</span> <span class="o">=</span> <span class="n">peaklist</span><span class="p">[</span><span class="n">amp_rank</span><span class="p">]</span>
    <span class="c1"># ptp_sorted = ar_ptp[amp_rank]</span>
    <span class="n">amp_sorted</span> <span class="o">=</span> <span class="n">ar_amp</span><span class="p">[</span><span class="n">amp_rank</span><span class="p">]</span>
    <span class="c1"># thresholding on peak-to-peak amplitude</span>
    <span class="n">threshold_amp</span> <span class="o">=</span> <span class="n">IntensityThreshold</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">amp_sorted</span> <span class="o">&gt;</span> <span class="n">threshold_amp</span><span class="p">)</span>
    <span class="n">th_peaklist</span> <span class="o">=</span> <span class="n">peaklist_sorted</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
    <span class="n">th_ar_amp</span> <span class="o">=</span> <span class="n">amp_sorted</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> local maxima found after thresholding above </span><span class="si">{}</span><span class="s2"> amplitude above local background&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">th_ar_amp</span><span class="p">),</span> <span class="n">threshold_amp</span><span class="p">))</span>

    <span class="c1"># remove duplicates (close points), the most intense pixel is kept</span>
    <span class="c1"># minimum distance between hot pixel</span>
    <span class="c1"># it corresponds both to distance between peaks and peak size ...</span>
    <span class="n">pixeldistance</span> <span class="o">=</span> <span class="n">pixeldistance_remove_duplicates</span>

    <span class="n">purged_pklist</span><span class="p">,</span> <span class="n">index_todelete</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">purgeClosePoints2</span><span class="p">(</span><span class="n">th_peaklist</span><span class="p">,</span> <span class="n">pixeldistance</span><span class="p">)</span>

    <span class="n">purged_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">th_ar_amp</span><span class="p">,</span> <span class="n">index_todelete</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> local maxima found after removing duplicates (minimum intermaxima distance = </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">purged_amp</span><span class="p">),</span> <span class="n">pixeldistance</span><span class="p">))</span>

    <span class="c1"># print &quot;execution time : %f  secondes&quot;%( ttt.time() - time_0)</span>

    <span class="c1"># merging different kind of peaks</span>
    <span class="k">if</span> <span class="n">sat_pix_mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merging saturated and normal peaks&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of saturated peaks : &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sat_pix_mean</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">purged_pklist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sat_pix_mean</span><span class="p">,</span> <span class="n">purged_pklist</span><span class="p">))</span>

    <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># check if there are still close hot pixels</span>
        <span class="n">disttable_c</span> <span class="o">=</span> <span class="n">ssd</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">purged_pklist</span><span class="p">,</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
        <span class="n">maxdistance_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">disttable_c</span><span class="p">)</span>
        <span class="n">sqdistmatrix_c</span> <span class="o">=</span> <span class="n">ssd</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">disttable_c</span><span class="p">)</span>
        <span class="n">distmatrix_c</span> <span class="o">=</span> <span class="n">sqdistmatrix_c</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">sqdistmatrix_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">maxdistance_c</span>
        <span class="c1"># must be (array([], dtype=int64), array([], dtype=int64))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;close hotpixels&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distmatrix_c</span> <span class="o">&lt;</span> <span class="n">pixeldistance</span><span class="p">))</span>
    <span class="c1"># print &quot;purged_pklist&quot;, purged_pklist</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;shape(purged_pklist)&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">purged_pklist</span><span class="p">))</span>
    <span class="n">npeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">purged_pklist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Ipixmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npeaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># print np.shape(Data)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">npeaks</span><span class="p">)):</span>
        <span class="n">Ipixmax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">purged_pklist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">purged_pklist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># print &quot;Ipixmax = &quot;, Ipixmax</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">purged_pklist</span><span class="p">),</span> <span class="n">Ipixmax</span></div>

<div class="viewcode-block" id="shiftarrays_accum"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.shiftarrays_accum">[docs]</a><span class="k">def</span> <span class="nf">shiftarrays_accum</span><span class="p">(</span><span class="n">Data_array</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">diags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    idem than shiftarrays() but with all intermediate shifted arrays</span>
<span class="sd">    1D</span>
<span class="sd">    returns 3 arrays corresponding to shifted arrays</span>
<span class="sd">    by n in two directions and original one</span>
<span class="sd">    2D</span>
<span class="sd">    returns 5 arrays corresponding to shifted arrays</span>
<span class="sd">    by n in two directions and original one</span>

<span class="sd">    these arrays are ready for comparison with eg np.greater</span>

<span class="sd">    Data_array must have shape (slowdim,fastdim) so that</span>
<span class="sd">    slowdim-2*n&gt;=1 and fastdim-2*n&gt;=1</span>
<span class="sd">    (ie central array with zero shift has some elements)</span>

<span class="sd">    TODO: replace append by a pre allocated array</span>

<span class="sd">    .. note:: readmccd.localmaxima is better</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shift value must be positive&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">diags</span><span class="p">:</span>
            <span class="n">shift_zero</span> <span class="o">=</span> <span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>

            <span class="n">allleft</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">allright</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">allup</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">alldown</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">alldiagleftdown</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># diag &quot;y=x&quot;</span>
            <span class="n">alldiagrightup</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># diag &quot;y=x&quot;</span>
            <span class="n">alldiagrightdown</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#  diah &quot;y=-x&quot;</span>
            <span class="n">alldiagleftup</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#  diah &quot;y=-x&quot;</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="n">allleft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span>
                <span class="n">alldown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">)])</span>
                <span class="n">alldiagrightdown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">)])</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">allright</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">),</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span>
                    <span class="n">allup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)])</span>
                    <span class="n">alldiagleftdown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">Data_array</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">),</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">)])</span>
                    <span class="n">alldiagleftup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">),</span> <span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)])</span>
                    <span class="n">alldiagrightup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">Data_array</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span> <span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)])</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># correct python array slicing at the end :   a[n:0]  would mean a[n:]</span>

                    <span class="n">allright</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:,</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span>
                    <span class="n">allup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:])</span>
                    <span class="n">alldiagleftdown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">)])</span>
                    <span class="n">alldiagleftup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:])</span>
                    <span class="n">alldiagrightup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span> <span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:])</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">shift_zero</span><span class="p">,</span>
                <span class="n">allleft</span><span class="p">,</span>
                <span class="n">allright</span><span class="p">,</span>
                <span class="n">alldown</span><span class="p">,</span>
                <span class="n">allup</span><span class="p">,</span>
                <span class="n">alldiagleftdown</span><span class="p">,</span>
                <span class="n">alldiagrightup</span><span class="p">,</span>
                <span class="n">alldiagrightdown</span><span class="p">,</span>
                <span class="n">alldiagleftup</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">shift_zero</span> <span class="o">=</span> <span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>

            <span class="n">allleft</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">allright</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">allup</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">alldown</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">allleft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[:</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span>
            <span class="n">alldown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">allleft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span>
                <span class="n">allright</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">),</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span>
                <span class="n">alldown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">)])</span>
                <span class="n">allup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)])</span>

            <span class="n">allright</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="p">:,</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span>
            <span class="n">allup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="p">:])</span>

            <span class="k">return</span> <span class="n">shift_zero</span><span class="p">,</span> <span class="n">allleft</span><span class="p">,</span> <span class="n">allright</span><span class="p">,</span> <span class="n">alldown</span><span class="p">,</span> <span class="n">allup</span>

    <span class="k">elif</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shift_zero</span> <span class="o">=</span> <span class="n">Data_array</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>
        <span class="n">allleft</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allright</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allleft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[:</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">allright</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)])</span>
            <span class="n">allleft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span><span class="p">)])</span>
        <span class="n">allright</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="p">:])</span>

        <span class="k">return</span> <span class="n">shift_zero</span><span class="p">,</span> <span class="n">allleft</span><span class="p">,</span> <span class="n">allright</span></div>

<div class="viewcode-block" id="LocalMaxima_from_thresholdarray"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.LocalMaxima_from_thresholdarray">[docs]</a><span class="k">def</span> <span class="nf">LocalMaxima_from_thresholdarray</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">IntensityThreshold</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">rois</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">framedim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return center of mass of each blobs composes by pixels above IntensityThreshold</span>

<span class="sd">    if Centers = list of (x,y, halfboxsizex, halfboxsizey)  perform only blob search in theses ROIs</span>

<span class="sd">    .. warning:: center of mass of blob where all intensities are set to 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&gt;&gt;&gt;&gt; Finding only peaks in </span><span class="si">%d</span><span class="s1"> ROIs.</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">rois</span><span class="p">))</span>
        <span class="n">listmeanpos_roi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">boxx</span><span class="p">,</span> <span class="n">boxy</span> <span class="ow">in</span> <span class="n">rois</span><span class="p">:</span>

            <span class="n">centerj</span><span class="p">,</span> <span class="n">centeri</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
            <span class="n">boxj</span><span class="p">,</span> <span class="n">boxi</span> <span class="o">=</span> <span class="n">boxx</span><span class="p">,</span> <span class="n">boxy</span>
            <span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">centeri</span> <span class="o">-</span> <span class="n">boxi</span><span class="p">,</span> <span class="n">centeri</span> <span class="o">+</span> <span class="n">boxi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">centerj</span> <span class="o">-</span> <span class="n">boxj</span><span class="p">,</span> <span class="n">centerj</span> <span class="o">+</span> <span class="n">boxj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># avoid to wrong indices when slicing the data</span>
            <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">=</span> <span class="n">check_array_indices</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span><span class="p">,</span>
                                                                    <span class="n">framedim</span><span class="o">=</span><span class="n">framedim</span><span class="p">)</span>
            <span class="c1"># print(&quot;imin, imax, jmin, jmax&quot;, imin, imax, jmin, jmax)</span>
            <span class="n">dataroi</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">imin</span> <span class="p">:</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span> <span class="p">:</span> <span class="n">jmax</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">------------------</span><span class="se">\n</span><span class="s2">x,y, boxx, boxy&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">boxx</span><span class="p">,</span> <span class="n">boxy</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max intensity in dataroi&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dataroi</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;min intensity in dataroi&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">dataroi</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;IntensityThreshold&#39;</span><span class="p">,</span> <span class="n">IntensityThreshold</span><span class="p">)</span>


            <span class="c1"># other way equivalent</span>
            <span class="c1"># print(&quot;framedim in LocalMaxima_from_thresholdarray&quot;, framedim)</span>
            <span class="c1"># framedim = framedim[1], framedim[0]</span>

            <span class="c1"># i1, i2, j1, j2 = getindices2cropArray((x,y), (boxx, boxy), framedim)</span>
            <span class="c1"># #        print &quot;i1, i2, j1, j2-----&quot;, i1, i2, j1, j2</span>
            <span class="c1"># dataroi = Data[i1:i2, j1:j2]</span>

            <span class="c1"># # for spot near border, replace by zeros array</span>
            <span class="c1"># if i2 - i1 != boxy * 2 or j2 - j1 != boxx * 2:</span>
            <span class="c1">#     dataroi = np.zeros((boxy * 2 + 1, boxx * 2 + 1))</span>
            <span class="c1"># print(&#39;max intensity in dataroi  2  :  &#39;, np.amax(dataroi))</span>

            <span class="c1"># blob seach in dataroi</span>
            <span class="n">thrData_for_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dataroi</span> <span class="o">&gt;</span> <span class="n">IntensityThreshold</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">ll</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">thrData_for_label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sad! No blobs there in this roi...&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">meanpos_roi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">maximum_position</span><span class="p">(</span><span class="n">dataroi</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">meanpos_roi</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">meanpos_roi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">meanpos_roi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">meanpos_roi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">meanpos_roi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;meanpos_roi  =&gt;&#39;</span><span class="p">,</span> <span class="n">meanpos_roi</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">meanpos_roi</span><span class="p">:</span>
                <span class="n">listmeanpos_roi</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="n">boxx</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">boxy</span><span class="p">])</span>

        <span class="n">meanpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listmeanpos_roi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;meanpos&#39;</span><span class="p">,</span> <span class="n">meanpos</span><span class="p">)</span>

    <span class="c1"># single ROI is whole Data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">thrData_for_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Data</span> <span class="o">&gt;</span> <span class="n">IntensityThreshold</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1">#     thrData = np.where(Data &gt; IntensityThreshold, Data, 0)</span>

        <span class="c1">#    star = array([[0,1,0],[1,1,1],[0,1,0]])</span>
        <span class="c1"># ll, nf = ndimage.label(thrData_for_label, structure=np.ones((3,3)))</span>
        <span class="c1"># ll, nf = ndimage.label(thrData_for_label, structure=star)</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">thrData_for_label</span><span class="p">)</span>

        <span class="c1">#     print &quot;nb of blobs in LocalMaxima_from_thresholdarray()&quot;, nf</span>

        <span class="k">if</span> <span class="n">nf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">meanpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">maximum_position</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">meanpos</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">meanpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">meanpos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">meanpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">meanpos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">meanpos</span></div>


<div class="viewcode-block" id="localmaxima"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.localmaxima">[docs]</a><span class="k">def</span> <span class="nf">localmaxima</span><span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">diags</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from DataArray 2D  returns (array([i1,i2,...,ip]),array([j1,j2,...,jp]))</span>
<span class="sd">    of indices where pixels value is higher in two direction up to n pixels</span>

<span class="sd">    this tuple can be easily used after in the following manner:</span>
<span class="sd">    DataArray[tupleresult] is an array of the intensity of the hottest pixels in array</span>

<span class="sd">    in similar way with only four cardinal directions neighbouring (found in the web):</span>
<span class="sd">    import numpy as N</span>
<span class="sd">    def local_minima(array2d):</span>
<span class="sd">        return ((array2d &lt;= np.roll(array2d,  1, 0)) &amp;</span>
<span class="sd">                (array2d &lt;= np.roll(array2d, -1, 0)) &amp;</span>
<span class="sd">                (array2d &lt;= np.roll(array2d,  1, 1)) &amp;</span>
<span class="sd">                (array2d &lt;= np.roll(array2d, -1, 1)))</span>

<span class="sd">    WARNING: flat top peak are not detected !!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">DataArray</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">diags</span><span class="p">:</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">alll</span><span class="p">,</span> <span class="n">allr</span><span class="p">,</span> <span class="n">alld</span><span class="p">,</span> <span class="n">allu</span><span class="p">,</span> <span class="n">diag11</span><span class="p">,</span> <span class="n">diag12</span><span class="p">,</span> <span class="n">diag21</span><span class="p">,</span> <span class="n">diag22</span> <span class="o">=</span> <span class="n">shiftarrays_accum</span><span class="p">(</span>
            <span class="n">DataArray</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">diags</span><span class="o">=</span><span class="n">diags</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">alll</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">alll</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">allr</span> <span class="o">+</span> <span class="n">alld</span> <span class="o">+</span> <span class="n">allu</span> <span class="o">+</span> <span class="n">diag11</span> <span class="o">+</span> <span class="n">diag12</span> <span class="o">+</span> <span class="n">diag21</span> <span class="o">+</span> <span class="n">diag22</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">alll</span><span class="p">,</span> <span class="n">allr</span><span class="p">,</span> <span class="n">alld</span><span class="p">,</span> <span class="n">allu</span> <span class="o">=</span> <span class="n">shiftarrays_accum</span><span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">diags</span><span class="o">=</span><span class="n">diags</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">alll</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">alll</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">allr</span> <span class="o">+</span> <span class="n">alld</span> <span class="o">+</span> <span class="n">allu</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>

    <span class="n">peaklist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>  <span class="c1"># in c frame index</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;value local max&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">peaklist</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;value from original array &quot;</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaklist</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">)])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;positions of local maxima in original frame index&quot;</span><span class="p">,</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaklist</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">),)</span>

    <span class="c1"># first slow index array , then second fast index array</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaklist</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span></div>


<span class="c1"># --- ----  Filtering and background removal function</span>
<div class="viewcode-block" id="gauss_kern"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.gauss_kern">[docs]</a><span class="k">def</span> <span class="nf">gauss_kern</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">sizey</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a normalized 2D gauss kernel array for convolutions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sizey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sizey</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sizey</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sizey</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">size</span> <span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">sizey</span><span class="p">:</span> <span class="n">sizey</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sizey</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="blur_image"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.blur_image">[docs]</a><span class="k">def</span> <span class="nf">blur_image</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    blurs the image by convolving with a gaussian kernel of typical</span>
<span class="sd">        size n. The optional keyword argument ny allows for a different</span>
<span class="sd">        size in the y direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">gauss_kern</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">sizey</span><span class="o">=</span><span class="n">ny</span><span class="p">)</span>
    <span class="n">improc</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">improc</span></div>


<div class="viewcode-block" id="blurCCD"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.blurCCD">[docs]</a><span class="k">def</span> <span class="nf">blurCCD</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    apply a blur filter to image ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">framedim</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">minipix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">tab</span> <span class="o">=</span> <span class="n">minipix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">framedim</span><span class="p">)</span>

    <span class="n">blurredpart</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">tab</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">blurredpart</span>
    <span class="k">return</span> <span class="n">tab</span></div>


<div class="viewcode-block" id="circularMask"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.circularMask">[docs]</a><span class="k">def</span> <span class="nf">circularMask</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">arrayshape</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return a boolean ndarray of elem in array inside a mask</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">II</span><span class="p">,</span> <span class="n">JJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">arrayshape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">arrayshape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">II</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">JJ</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">cond</span></div>


<div class="viewcode-block" id="compute_autobackground_image"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.compute_autobackground_image">[docs]</a><span class="k">def</span> <span class="nf">compute_autobackground_image</span><span class="p">(</span><span class="n">dataimage</span><span class="p">,</span> <span class="n">boxsizefilter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return 2D array of filtered data array</span>
<span class="sd">    :param dataimage: array of image data</span>
<span class="sd">    :type dataimage: 2D array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bkgimage</span> <span class="o">=</span> <span class="n">filter_minimum</span><span class="p">(</span><span class="n">dataimage</span><span class="p">,</span> <span class="n">boxsize</span><span class="o">=</span><span class="n">boxsizefilter</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bkgimage</span></div>


<div class="viewcode-block" id="computefilteredimage"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.computefilteredimage">[docs]</a><span class="k">def</span> <span class="nf">computefilteredimage</span><span class="p">(</span><span class="n">dataimage</span><span class="p">,</span> <span class="n">bkg_image</span><span class="p">,</span> <span class="n">CCDlabel</span><span class="p">,</span> <span class="n">kernelsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">formulaexpression</span><span class="o">=</span><span class="s2">&quot;A-B&quot;</span><span class="p">,</span>
                                                        <span class="n">usemask</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return 2D array of initial image data without background given by bkg_image data</span>

<span class="sd">    usemask        : True  then substract bkg image on masked raw data</span>
<span class="sd">                    False  apply formula on all pixels (no mask)</span>

<span class="sd">    :param dataimage: array of image data</span>
<span class="sd">    :type dataimage: 2D array</span>
<span class="sd">    :param bkg_image: array of filtered image data (background)</span>
<span class="sd">    :type bkg_image: 2D array</span>
<span class="sd">    :param CCDlabel: key for CCD dictionary</span>
<span class="sd">    :type CCDlabel: string</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">framedim</span> <span class="o">=</span> <span class="n">DictLT</span><span class="o">.</span><span class="n">dict_CCD</span><span class="p">[</span><span class="n">CCDlabel</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">SaturationLevel</span> <span class="o">=</span> <span class="n">DictLT</span><span class="o">.</span><span class="n">dict_CCD</span><span class="p">[</span><span class="n">CCDlabel</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">dataformat</span> <span class="o">=</span> <span class="n">DictLT</span><span class="o">.</span><span class="n">dict_CCD</span><span class="p">[</span><span class="n">CCDlabel</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;framedim in computefilteredimage &quot;</span><span class="p">,</span> <span class="n">framedim</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CCDlabel in computefilteredimage &quot;</span><span class="p">,</span> <span class="n">CCDlabel</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1">#     if CCDlabel in (&#39;EDF&#39;,):</span>
    <span class="c1">#         return dataimage</span>

    <span class="c1">#     if framedim not in ((2048, 2048), [2048, 2048]):</span>
    <span class="c1">#         raise ValueError, &quot;Background removal still implemented for non squared camera &quot;</span>
    <span class="c1"># computing substraction on whole array</span>
    <span class="k">if</span> <span class="n">CCDlabel</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;sCMOS&quot;</span><span class="p">,</span> <span class="s2">&quot;sCMOS_fliplr&quot;</span><span class="p">):</span>
        <span class="n">usemask</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
        <span class="c1"># mask parameter to avoid high intensity steps at border:</span>
        <span class="c1"># TODO: to compute for all CCD types</span>
        <span class="c1">#     center, mask_radius, minvalue = (1024, 1024), 1010, 0</span>

        <span class="c1"># radius of the mask a bit smaller than real radius avoiding circular intensity step</span>

        <span class="n">mask_radius</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">framedim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">framedim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">15</span>
        <span class="n">center</span><span class="p">,</span> <span class="n">minvalue</span> <span class="o">=</span> <span class="p">(</span><span class="n">framedim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">framedim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mask_radius&quot;</span><span class="p">,</span> <span class="n">mask_radius</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>

        <span class="n">dataarray2D_without_background</span> <span class="o">=</span> <span class="n">filterimage</span><span class="p">(</span><span class="n">dataimage</span><span class="p">,</span> <span class="n">framedim</span><span class="p">,</span>
                                                    <span class="n">blurredimage</span><span class="o">=</span><span class="n">bkg_image</span><span class="p">,</span>
                                                    <span class="n">kernelsize</span><span class="o">=</span><span class="n">kernelsize</span><span class="p">,</span>
                                                    <span class="n">mask_parameters</span><span class="o">=</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">mask_radius</span><span class="p">,</span> <span class="n">minvalue</span><span class="p">),</span>
                                                    <span class="n">clipvalues</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SaturationLevel</span><span class="p">),</span>
                                                    <span class="n">imageformat</span><span class="o">=</span><span class="n">dataformat</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">dataarray2D_without_background</span> <span class="o">=</span> <span class="n">applyformula_on_images</span><span class="p">(</span><span class="n">dataimage</span><span class="p">,</span> <span class="n">bkg_image</span><span class="p">,</span>
                                                            <span class="n">formulaexpression</span><span class="o">=</span><span class="n">formulaexpression</span><span class="p">,</span>
                                                            <span class="n">SaturationLevel</span><span class="o">=</span><span class="n">SaturationLevel</span><span class="p">,</span>
                                                            <span class="n">clipintensities</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataarray2D_without_background</span></div>


<div class="viewcode-block" id="filterimage"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.filterimage">[docs]</a><span class="k">def</span> <span class="nf">filterimage</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="n">framedim</span><span class="p">,</span> <span class="n">blurredimage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">kernelsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                        <span class="n">mask_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">clipvalues</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">imageformat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute a difference of images inside a region defined by a mask</span>

<span class="sd">    :param blurredimage:    ndarray image to substract to image_array</span>
<span class="sd">    :param kernelsize:    pixel size of gaussian kernel if blurredimage is None</span>

<span class="sd">    :param mask_parameters: circular mask parameter: center=(x,y), radius, value outside mask</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">blurredimage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dblur</span> <span class="o">=</span> <span class="n">blurCCD</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="n">kernelsize</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dblur</span> <span class="o">=</span> <span class="n">blurredimage</span>

    <span class="k">if</span> <span class="n">clipvalues</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">minival</span><span class="p">,</span> <span class="n">maxival</span> <span class="o">=</span> <span class="n">clipvalues</span>
        <span class="n">tab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image_array</span> <span class="o">-</span> <span class="n">dblur</span><span class="p">,</span> <span class="n">minival</span><span class="p">,</span> <span class="n">maxival</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tab</span> <span class="o">=</span> <span class="n">image_array</span> <span class="o">-</span> <span class="n">dblur</span>

    <span class="k">if</span> <span class="n">mask_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">minvalue</span> <span class="o">=</span> <span class="n">mask_parameters</span>
        <span class="k">if</span> <span class="n">minvalue</span> <span class="o">==</span> <span class="s2">&quot;minvalue&quot;</span><span class="p">:</span>
            <span class="n">minivalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">image_array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minivalue</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">maskcd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">circularMask</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">framedim</span><span class="p">),</span> <span class="n">tab</span><span class="p">,</span> <span class="n">minivalue</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">maskcd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">imageformat</span><span class="p">)</span></div>


<div class="viewcode-block" id="rebin2Darray"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.rebin2Darray">[docs]</a><span class="k">def</span> <span class="nf">rebin2Darray</span><span class="p">(</span><span class="n">inputarray</span><span class="p">,</span> <span class="n">bin_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    rebin 2D array by applying an operator to define the value of one element from the other</span>

<span class="sd">    :param operator: mean, min, max, sum</span>
<span class="sd">    :param bin_dims: side sizes of binning. (2,3) means 2X3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">inputarray</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">binr</span><span class="p">,</span> <span class="n">binc</span> <span class="o">=</span> <span class="n">bin_dims</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span>
    <span class="k">if</span> <span class="n">rows</span> <span class="o">%</span> <span class="n">binr</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cols</span> <span class="o">%</span> <span class="n">binc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">inputarray</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rows</span> <span class="o">//</span> <span class="n">binr</span><span class="p">,</span> <span class="n">binr</span><span class="p">,</span> <span class="n">cols</span> <span class="o">//</span> <span class="n">binc</span><span class="p">,</span> <span class="n">binc</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;array and binning size are not compatible&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="blurCCD_with_binning"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.blurCCD_with_binning">[docs]</a><span class="k">def</span> <span class="nf">blurCCD_with_binning</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    blur the array by rebinning before and after aplying the filter</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># framedim = im.shape</span>
    <span class="n">imrebin</span> <span class="o">=</span> <span class="n">rebin2Darray</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">bin_dims</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">imrebin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">dblur</span> <span class="o">=</span> <span class="n">blurCCD</span><span class="p">(</span><span class="n">imrebin</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">dblur</span><span class="p">,</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="filter_minimum"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.filter_minimum">[docs]</a><span class="k">def</span> <span class="nf">filter_minimum</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">boxsize</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; return filtered image using minimum filter&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">minimum_filter</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">boxsize</span><span class="p">)</span></div>


<div class="viewcode-block" id="remove_minimum_background"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.remove_minimum_background">[docs]</a><span class="k">def</span> <span class="nf">remove_minimum_background</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">boxsize</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    remove to image array the array resulting from minimum_filter</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">im</span> <span class="o">-</span> <span class="n">filter_minimum</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">boxsize</span><span class="o">=</span><span class="n">boxsize</span><span class="p">)</span></div>

<span class="c1"># --- -------------- Plot image and peaks</span>
<div class="viewcode-block" id="plot_image_markers"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.plot_image_markers">[docs]</a><span class="k">def</span> <span class="nf">plot_image_markers</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">markerpos</span><span class="p">,</span> <span class="n">position_definition</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    plot 2D array (image) with markers at first two columns of (markerpos)</span>

<span class="sd">    .. note:: used in LaueHDF5. Could be better implementation in some notebooks</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

    <span class="n">numrows</span><span class="p">,</span> <span class="n">numcols</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="nf">format_coord</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return string with x, y values &quot;&quot;&quot;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">numcols</span> <span class="ow">and</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">numrows</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
            <span class="k">return</span> <span class="s2">&quot;x = </span><span class="si">{:.4f}</span><span class="s2">, y = </span><span class="si">{:.4f}</span><span class="s2">, z = </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;x = </span><span class="si">{:.4f}</span><span class="s2">, y = </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">format_coord</span> <span class="o">=</span> <span class="n">format_coord</span>

    <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="k">import</span> <span class="n">Circle</span>

    <span class="c1"># correction only to fitdata peak position to the display</span>
    <span class="k">if</span> <span class="n">position_definition</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">PointToPlot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">markerpos</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">PointToPlot</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">markerpos</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">po</span> <span class="ow">in</span> <span class="n">PointToPlot</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]:</span>

        <span class="n">large_circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">po</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
        <span class="n">center_circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">po</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">large_circle</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">center_circle</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="applyformula_on_images"><a class="viewcode-back" href="../../PeakSearch.html#LaueTools.imageprocessing.applyformula_on_images">[docs]</a><span class="k">def</span> <span class="nf">applyformula_on_images</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">formulaexpression</span><span class="o">=</span><span class="s2">&quot;A-B&quot;</span><span class="p">,</span> <span class="n">SaturationLevel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                            <span class="n">clipintensities</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate image data array from math expression</span>

<span class="sd">    :param A, B: ndarray  of the same shape</span>

<span class="sd">    :param SaturationLevel:  saturation level of intensity</span>

<span class="sd">    :param clipintensities:   clip resulting intensities to zero and saturation value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input arrays in applyformula_on_images() have not the same shape.&quot;</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="c1">#        nbpix = A.shape[0] * A.shape[1]</span>
    <span class="c1">#        resformula = np.zeros_like(A)</span>
    <span class="c1">#        resformula.dtype = &#39;int32&#39;</span>

    <span class="c1">#        A.dtype = &#39;int32&#39;</span>
    <span class="c1">#        B.dtype = &#39;int32&#39;</span>
    <span class="n">resformula</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">formulaexpression</span><span class="p">)</span>
    <span class="c1">#        print resformula.dtype</span>
    <span class="n">newarray</span> <span class="o">=</span> <span class="n">resformula</span>

    <span class="k">if</span> <span class="n">clipintensities</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">SaturationLevel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">newarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">resformula</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SaturationLevel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;saturation level is unknown to clip data for large intensity!</span><span class="se">\n</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;Missing argument in applyformula_on_images()&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newarray</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, J.S. Micha, O. Robach., S. Tardif

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>