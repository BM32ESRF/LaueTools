

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>LaueTools.LaueGeometry &mdash; LaueTools  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> LaueTools
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getStarted.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../conventions.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../GUIs.html">Graphical User Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LaueToolsModules.html">LaueTools Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">LaueTools</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>LaueTools.LaueGeometry</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for LaueTools.LaueGeometry</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module of lauetools project to compute Laue spots position on CCD camera.</span>
<span class="sd">It handles detection and source geometry.</span>

<span class="sd">.. warning::</span>
<span class="sd">    The frame (LT2) considered in this package (with y axis parallel to the incoming beam) in not the LaueTools frame (for which x is parallel to the incoming beam)</span>

<span class="sd">JS Micha June 2019</span>

<span class="sd">* Vectors Definitions</span>
<span class="sd">    - **q** momentum transfer vector from resp. incoming and outgoing wave vector **ki** and **kf**, :math:`q=kf-ki`</span>

<span class="sd">    - When a Laue spot exists, **q** is equal to the one node of the reciprocal lattice given by **G*** vector</span>

<span class="sd">    - **G*** is perpendicular to atomic planes defined by the three Miller indices h,k,l</span>
<span class="sd">        such as **G***=h**a*** + k**b*** +l**c*** where **a***, **b***, and **c*** are the unit cell lattice basis vectors.</span>

<span class="sd">    - **kf**: scattered beam vector whose corresponding unit vector is **uf**</span>

<span class="sd">    - **ki** incoming beam vector, **ui** corresponding unit vector</span>

<span class="sd">* Laboratory Frame LT2</span>
<span class="sd">    - I: origin</span>

<span class="sd">    - z vertical up perpendicular to CCD plane (top camera geometry)</span>

<span class="sd">    - y along X-ray horizontal</span>

<span class="sd">    - x towards wall behind horizontal</span>

<span class="sd">    - O: origin of pixel CCD frame in detecting plane</span>

<span class="sd">    - **j** // **ui** incoming beam unit vector</span>

<span class="sd">    - z axis is defined by the CCD camera position. z axis is perpendicular to CCD plane</span>
<span class="sd">        such as IO belongs to the plane Iyz</span>
<span class="sd">    - bet: angle between **IO** and **k**</span>

<span class="sd">    - **i**= **j**^**k** (when entering the BM32 hutch **i** is approximately towards the wall</span>
<span class="sd">        (in CCD on top geometry and beam coming from the right)</span>
<span class="sd">    - M: point lying in CCD plane corresponding to Laue spot</span>

<span class="sd">    - **uf** is the unit vector relative to vector **IM**</span>

<span class="sd">**kf** is also a vector collinear to **IM** with a length of R=1/wavelength=E/12.398 [keV]</span>
<span class="sd">with wavelength and Energy of the corresponding bragg&#39;s reflections.</span>

<span class="sd">I is the point from which calibration parameters (CCD position) are deduced (from a perfectly known crystal structure Laue pattern)</span>
<span class="sd">Iprime is an other source of emission (posI or offset in functions)</span>

<span class="sd">:math:`2 \theta` is the scattering angle between **ui** and **uf**, i.e.</span>

<span class="sd">:math:`\cos(2 \theta)=u_i.u_f`</span>

<span class="sd">.. math::</span>

<span class="sd">    {\bf k_f} = ( -\sin 2 \theta \sin \chi, \cos 2\theta, \sin 2\theta \cos \chi)</span>

<span class="sd">    {\bf k_i} = (0, 1, 0)</span>

<span class="sd">Energy= 12.398*  q**2/(2* **q**.**ui**)=12.398 * q**2/ (-2 sin theta)</span>

<span class="sd">*Calibration parameters (CCD position and detection geometry)*</span>
<span class="sd">    - calib: list of the 5 calibration parameters [dd,xcen,ycen,xbet,xgam]</span>
<span class="sd">    - dd: norm of **IO**  [mm]</span>
<span class="sd">    - xcen,ycen [pixel unit]: pixels values in CCD frame of point O with respect to Oprime where</span>
<span class="sd">        Oprime is the origin of CCD pixels frame (at a corner of the CCD array)</span>
<span class="sd">    - xbet: angle between **IO** and **k** [degree]</span>
<span class="sd">    - xgam: azimutal rotation angle around z axis. Angle between CCD array axes</span>
<span class="sd">        and (**i**,**j**) after rotation by xbet [degree].</span>

<span class="sd">*sample frame*</span>

<span class="sd">Origin is I and unit frame vectors (**is**, **js**, **ks**) are derived</span>
<span class="sd">from absolute frame by the rotation (axis= - **i**, angle= wo) where wo is the angle between **js** and **j**</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">P</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">findorient</span> <span class="k">as</span> <span class="n">FindO</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">generaltools</span> <span class="k">as</span> <span class="n">GT</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">IOLaueTools</span> <span class="k">as</span> <span class="n">IOLT</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">CrystalParameters</span> <span class="k">as</span> <span class="n">CP</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">dict_LaueTools</span> <span class="k">as</span> <span class="n">DictLT</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">findorient</span> <span class="k">as</span> <span class="nn">FindO</span>
    <span class="kn">import</span> <span class="nn">generaltools</span> <span class="k">as</span> <span class="nn">GT</span>
    <span class="kn">import</span> <span class="nn">IOLaueTools</span> <span class="k">as</span> <span class="nn">IOLT</span>
    <span class="kn">import</span> <span class="nn">CrystalParameters</span> <span class="k">as</span> <span class="nn">CP</span>
    <span class="kn">import</span> <span class="nn">dict_LaueTools</span> <span class="k">as</span> <span class="nn">DictLT</span>

<span class="c1"># -----------  CONSTANTS ------------------</span>
<span class="n">RECTPIX</span> <span class="o">=</span> <span class="n">DictLT</span><span class="o">.</span><span class="n">RECTPIX</span>  <span class="c1"># see above  camera skewness</span>

<span class="n">PI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">DEG</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">/</span> <span class="mf">180.0</span>

<span class="n">CST_CONV_LAMBDA_KEV</span> <span class="o">=</span> <span class="n">DictLT</span><span class="o">.</span><span class="n">CST_ENERGYKEV</span>

<span class="c1"># --- -----   old function  ---------------</span>
<span class="n">norme</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">norme_vec</span>

<span class="c1"># --- -------- geometrical functions relating 2theta, chi, pixel X, pixel Y, detector plane ----</span>
<div class="viewcode-block" id="calc_uflab"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.calc_uflab">[docs]</a><span class="k">def</span> <span class="nf">calc_uflab</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">detectorplaneparameters</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnAngles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                    <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                    <span class="n">rectpix</span><span class="o">=</span><span class="n">RECTPIX</span><span class="p">,</span>
                                                                    <span class="n">kf_direction</span><span class="o">=</span><span class="s2">&quot;Z&gt;0&quot;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes unit vector :math:`{\bf u_f}=\frac{\bf k_f}{\|k_f\|}` in laboratory frame of scattered beam :math:`k_f`</span>
<span class="sd">    (angle scattering angles 2theta and chi) from X, Y pixel Laue spot position</span>

<span class="sd">    Unit vector uf correspond to normalized kf vector: q = kf - ki</span>
<span class="sd">    from lists of X and Y Laue spots pixels positions on detector</span>

<span class="sd">    :param xcam: list of pixel X position</span>
<span class="sd">    :type xcam: list of floats</span>
<span class="sd">    :param ycam: list of pixel Y position</span>
<span class="sd">    :type ycam: list of floats</span>
<span class="sd">    :param detectorplaneparameters: list of 5 calibration parameters</span>

<span class="sd">    :param offset: float, offset in position along incoming beam of source of scattered rays</span>
<span class="sd">                if positive: offset in sample depth</span>
<span class="sd">                units: mm</span>

<span class="sd">    :returns:</span>
<span class="sd">        * if returnAngles=1   : twicetheta, chi   *(default)*</span>
<span class="sd">        * if returnAngles!=1  : uflab, IMlab</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">calib</span> <span class="o">=</span> <span class="n">detectorplaneparameters</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">detect</span><span class="p">,</span> <span class="n">xcen</span><span class="p">,</span> <span class="n">ycen</span><span class="p">,</span> <span class="n">xbet</span><span class="p">,</span> <span class="n">xgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calib</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="c1">#    print &quot;pixelsize in calc_uflab &quot;, pixelsize</span>

    <span class="c1"># transmission geometry</span>
    <span class="k">if</span> <span class="n">kf_direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;X&gt;0&quot;</span><span class="p">,):</span>
        <span class="k">return</span> <span class="n">calc_uflab_trans</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span>
                                <span class="n">ycam</span><span class="p">,</span>
                                <span class="n">calib</span><span class="p">,</span>
                                <span class="n">returnAngles</span><span class="o">=</span><span class="n">returnAngles</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                <span class="n">rectpix</span><span class="o">=</span><span class="n">rectpix</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;X&lt;0&quot;</span><span class="p">,):</span>
        <span class="k">return</span> <span class="n">calc_uflab_back</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span>
                                <span class="n">ycam</span><span class="p">,</span>
                                <span class="n">calib</span><span class="p">,</span>
                                <span class="n">returnAngles</span><span class="o">=</span><span class="n">returnAngles</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                <span class="n">rectpix</span><span class="o">=</span><span class="n">rectpix</span><span class="p">)</span>
    <span class="c1"># 2theta=90 deg reflection geometry (top side+ and side -)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Z&gt;0&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&gt;0&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&lt;0&quot;</span><span class="p">):</span>
        <span class="n">cosbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
        <span class="n">sinbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kf_direction = </span><span class="si">%s</span><span class="s2"> not implemented in calc_uflab&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">))</span>

    <span class="n">cosgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span> <span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">singam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span> <span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="n">xcam1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xcam</span><span class="p">)</span> <span class="o">-</span> <span class="n">xcen</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixelsize</span>
    <span class="n">ycam1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ycam</span><span class="p">)</span> <span class="o">-</span> <span class="n">ycen</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixelsize</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">rectpix</span><span class="p">)</span>

    <span class="n">xca0</span> <span class="o">=</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">xcam1</span> <span class="o">-</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">ycam1</span>
    <span class="n">yca0</span> <span class="o">=</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">xcam1</span> <span class="o">+</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">ycam1</span>

    <span class="c1"># I impact point on sample (location of x-ray scattering or emission)</span>
    <span class="c1"># O centre of origin of pixel CCD</span>
    <span class="c1"># M belong to CCD plane</span>
    <span class="c1"># IM is parallel to kf</span>
    <span class="c1"># frame is not Lauetools&#39;one</span>
    <span class="c1"># since here:  y // ki</span>

    <span class="c1"># IOlab = detect * array([0.0, cosbeta, sinbeta])</span>
    <span class="c1"># warning : cos and sin are exchanged due to definition above</span>
    <span class="c1"># cosbeta = np.cos(PI / 2.0 - xbet * DEG)  just above !!!!</span>
    <span class="n">xO</span><span class="p">,</span> <span class="n">yO</span><span class="p">,</span> <span class="n">zO</span> <span class="o">=</span> <span class="n">detect</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cosbeta</span><span class="p">,</span> <span class="n">sinbeta</span><span class="p">])</span>

    <span class="c1"># OMlab = array([xca0, yca0*sinbeta, -yca0*cosbeta])</span>
    <span class="n">xOM</span> <span class="o">=</span> <span class="n">xca0</span>
    <span class="n">yOM</span> <span class="o">=</span> <span class="n">yca0</span> <span class="o">*</span> <span class="n">sinbeta</span>
    <span class="n">zOM</span> <span class="o">=</span> <span class="o">-</span><span class="n">yca0</span> <span class="o">*</span> <span class="n">cosbeta</span>

    <span class="c1"># IMlab = IOlab + OMlab</span>
    <span class="n">xM</span> <span class="o">=</span> <span class="n">xO</span> <span class="o">+</span> <span class="n">xOM</span>
    <span class="n">yM</span> <span class="o">=</span> <span class="n">yO</span> <span class="o">+</span> <span class="n">yOM</span>
    <span class="n">zM</span> <span class="o">=</span> <span class="n">zO</span> <span class="o">+</span> <span class="n">zOM</span>
    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xM</span><span class="p">,</span> <span class="n">yM</span><span class="p">,</span> <span class="n">zM</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># norm of IM vector</span>
    <span class="c1"># nIMlab=sqrt(dot(IMlab,IMlab))</span>
    <span class="n">nIMlab</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xM</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yM</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">zM</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># print transpose(array([xM,yM,zM])) # vector joining source and pt on CCD in abs frame</span>
    <span class="c1"># print nIMlab #distance source pt on CCD (mm)</span>

    <span class="n">uflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xM</span><span class="p">,</span> <span class="n">yM</span><span class="p">,</span> <span class="n">zM</span><span class="p">])</span> <span class="o">/</span> <span class="n">nIMlab</span><span class="p">)</span>

    <span class="c1">#     print &quot;uflab w/o source offset&quot;,uflab</span>

    <span class="k">if</span> <span class="n">offset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="c1"># with source offset along y (&gt;0 if along the beam and in sample depth)</span>
        <span class="c1"># ufprimelab = unit(IpMlab) = unit(IpIlab+IMlab)</span>
        <span class="n">IpMlab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">IMlab</span>
        <span class="n">normedIpM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IpMlab</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">IpMlab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">ufprime</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">IpMlab</span> <span class="o">/</span> <span class="n">normedIpM</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ufprime, uflab with source offset&quot;</span><span class="p">,</span> <span class="n">ufprime</span><span class="p">)</span>

        <span class="n">uflab</span> <span class="o">=</span> <span class="n">ufprime</span>

    <span class="c1"># calculus of scattering angles</span>
    <span class="n">EPS</span> <span class="o">=</span> <span class="mf">1e-17</span>
    <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="o">-</span><span class="n">uflab</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">uflab</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">EPS</span><span class="p">))</span> <span class="o">/</span> <span class="n">DEG</span>  <span class="c1"># JSM convention</span>
    <span class="c1">#     chiXMAS = np.arctan(uflab[:, 0] / np.sqrt(uflab[:, 1] ** 2 + uflab[:, 2] ** 2)) / DEG</span>
    <span class="c1">#     chiXMAS2 = np.arctan(np.sqrt(uflab[:, 0] ** 2 + uflab[:, 1] ** 2) / uflab[:, 2]) / DEG</span>

    <span class="n">twicetheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">uflab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;chi_JSM&quot;</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
        <span class="c1">#         print &quot;chi_XMAS&quot;, chiXMAS</span>
        <span class="c1">#         print &quot;chi_XMAS2&quot;, chiXMAS2</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2theta&quot;</span><span class="p">,</span> <span class="n">twicetheta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">returnAngles</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">uflab</span><span class="p">,</span> <span class="n">IMlab</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># default return</span>
        <span class="k">return</span> <span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span></div>


<div class="viewcode-block" id="calc_uflab_trans"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.calc_uflab_trans">[docs]</a><span class="k">def</span> <span class="nf">calc_uflab_trans</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">returnAngles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                        <span class="n">rectpix</span><span class="o">=</span><span class="n">RECTPIX</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute :math:`2 \theta` and :math:`\chi` scattering angles or **uf** and **kf** vectors</span>
<span class="sd">    from lists of X and Y Laue spots positions</span>
<span class="sd">    in TRANSMISSION geometry</span>

<span class="sd">    :param xcam: list of pixel X position</span>
<span class="sd">    :type xcam: list of floats</span>
<span class="sd">    :param ycam: list of pixel Y position</span>
<span class="sd">    :type ycam: list of floats</span>
<span class="sd">    :param calib: list of 5 calibration parameters</span>

<span class="sd">    :returns:</span>
<span class="sd">        - if returnAngles=1   : twicetheta, chi   *(default)*</span>
<span class="sd">        - if returnAngles!=1  : uflab, IMlab</span>

<span class="sd">    # TODO: add offset like in reflection geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;transmission GEOMETRY&quot;</span><span class="p">)</span>
    <span class="n">detect</span><span class="p">,</span> <span class="n">xcen</span><span class="p">,</span> <span class="n">ycen</span><span class="p">,</span> <span class="n">xbet</span><span class="p">,</span> <span class="n">xgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calib</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="c1">#    print &quot;pixelsize in calc_uflab &quot;, pixelsize</span>

    <span class="c1"># TODO: this is strange beta defintion is different...</span>
    <span class="c1"># but it has been checked by data from Poitiers</span>
    <span class="c1"># cosbeta definition differs from</span>
    <span class="c1"># cosbeta = np.cos(PI / 2.0 - xbet * DEG)</span>
    <span class="c1"># sinbeta = np.sin(PI / 2.0 - xbet * DEG)</span>
    <span class="c1"># of top reflection geometry ...</span>
    <span class="n">cosbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">sinbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>   <span class="c1"># negative</span>

    <span class="n">cosgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span> <span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">singam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span> <span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>  <span class="c1"># negative</span>

    <span class="n">xcam1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xcam</span><span class="p">)</span> <span class="o">-</span> <span class="n">xcen</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixelsize</span>
    <span class="n">ycam1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ycam</span><span class="p">)</span> <span class="o">-</span> <span class="n">ycen</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixelsize</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">rectpix</span><span class="p">)</span>

    <span class="n">xca0</span> <span class="o">=</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">xcam1</span> <span class="o">-</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">ycam1</span>
    <span class="n">yca0</span> <span class="o">=</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">xcam1</span> <span class="o">+</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">ycam1</span>

    <span class="c1"># I centre</span>
    <span class="c1"># O centre of origin of pixel CCD</span>
    <span class="c1"># M belong to CCD plane</span>
    <span class="c1"># IM is parallel to kf</span>

    <span class="c1"># IOlab = detect * array([0.0, cosbeta, sinbeta])</span>
    <span class="n">xO</span><span class="p">,</span> <span class="n">yO</span><span class="p">,</span> <span class="n">zO</span> <span class="o">=</span> <span class="n">detect</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cosbeta</span><span class="p">,</span> <span class="n">sinbeta</span><span class="p">])</span>

    <span class="c1"># OMlab = array([xca0, yca0*sinbeta, -yca0*cosbeta])</span>
    <span class="n">xOM</span> <span class="o">=</span> <span class="n">xca0</span>
    <span class="n">yOM</span> <span class="o">=</span> <span class="n">yca0</span> <span class="o">*</span> <span class="n">sinbeta</span>
    <span class="n">zOM</span> <span class="o">=</span> <span class="o">-</span><span class="n">yca0</span> <span class="o">*</span> <span class="n">cosbeta</span>

    <span class="c1"># IMlab = IOlab + OMlab</span>
    <span class="n">xM</span> <span class="o">=</span> <span class="n">xO</span> <span class="o">+</span> <span class="n">xOM</span>
    <span class="n">yM</span> <span class="o">=</span> <span class="n">yO</span> <span class="o">+</span> <span class="n">yOM</span>
    <span class="n">zM</span> <span class="o">=</span> <span class="n">zO</span> <span class="o">+</span> <span class="n">zOM</span>
    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xM</span><span class="p">,</span> <span class="n">yM</span><span class="p">,</span> <span class="n">zM</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># norm of IM vector</span>
    <span class="c1"># nIMlab=sqrt(dot(IMlab,IMlab))</span>
    <span class="n">nIMlab</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xM</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yM</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">zM</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># print transpose(array([xM,yM,zM])) # vector joining source and pt on CCD in abs frame</span>
    <span class="c1"># print nIMlab #distance source pt on CCD (mm)</span>

    <span class="n">uflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xM</span><span class="p">,</span> <span class="n">yM</span><span class="p">,</span> <span class="n">zM</span><span class="p">])</span> <span class="o">/</span> <span class="n">nIMlab</span><span class="p">)</span>
    <span class="c1"># print &quot;uflab&quot;,uflab</span>
    <span class="n">EPS</span> <span class="o">=</span> <span class="mf">1e-17</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;transmission mode &quot;</span><span class="p">,</span> <span class="n">uflab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">xM</span><span class="p">,</span> <span class="n">zM</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span>
    <span class="n">twicetheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">uflab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>
    <span class="c1">#     chiXMAS = np.arctan(uflab[:, 0] / np.sqrt(uflab[:, 1] ** 2 + uflab[:, 2] ** 2)) / DEG</span>
    <span class="c1">#     chiXMAS2 = np.arctan(np.sqrt(uflab[:, 0] ** 2 + uflab[:, 1] ** 2) / uflab[:, 2]) / DEG</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;chi_JSM&quot;</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2theta&quot;</span><span class="p">,</span> <span class="n">twicetheta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">returnAngles</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">uflab</span><span class="p">,</span> <span class="n">IMlab</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># default return</span>
        <span class="k">return</span> <span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span></div>

<span class="k">def</span> <span class="nf">calc_uflab_back</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">returnAngles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                        <span class="n">rectpix</span><span class="o">=</span><span class="n">RECTPIX</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute :math:`2 \theta` and :math:`\chi` scattering angles or **uf** and **kf** vectors</span>
<span class="sd">    from lists of X and Y Laue spots positions</span>
<span class="sd">    in back reflection geometry</span>

<span class="sd">    :param xcam: list of pixel X position</span>
<span class="sd">    :type xcam: list of floats</span>
<span class="sd">    :param ycam: list of pixel Y position</span>
<span class="sd">    :type ycam: list of floats</span>
<span class="sd">    :param calib: list of 5 calibration parameters</span>

<span class="sd">    :returns:</span>
<span class="sd">        - if returnAngles=1   : twicetheta, chi   *(default)*</span>
<span class="sd">        - if returnAngles!=1  : uflab, IMlab</span>

<span class="sd">    # TODO: add offset like in reflection geometry and merge with transmission geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Back reflection GEOMETRY&quot;</span><span class="p">)</span>
    <span class="n">detect</span><span class="p">,</span> <span class="n">xcen</span><span class="p">,</span> <span class="n">ycen</span><span class="p">,</span> <span class="n">xbet</span><span class="p">,</span> <span class="n">xgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calib</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="c1">#    print &quot;pixelsize in calc_uflab &quot;, pixelsize</span>

    <span class="n">cosbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">sinbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="n">cosgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span> <span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">singam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span> <span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>  <span class="c1"># negative</span>

    <span class="n">xcam1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xcam</span><span class="p">)</span> <span class="o">-</span> <span class="n">xcen</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixelsize</span>
    <span class="n">ycam1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ycam</span><span class="p">)</span> <span class="o">-</span> <span class="n">ycen</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixelsize</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">rectpix</span><span class="p">)</span>

    <span class="n">xca0</span> <span class="o">=</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">xcam1</span> <span class="o">-</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">ycam1</span>
    <span class="n">yca0</span> <span class="o">=</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">xcam1</span> <span class="o">+</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">ycam1</span>

    <span class="c1"># I centre</span>
    <span class="c1"># O centre of origin of pixel CCD plane array</span>
    <span class="c1"># M belong to CCD plane</span>
    <span class="c1"># IM is parallel to kf (or uf = kf/||kf||)</span>

    <span class="c1"># IOlab = detect * array([0.0, -cosbeta, sinbeta])</span>
    <span class="n">xO</span><span class="p">,</span> <span class="n">yO</span><span class="p">,</span> <span class="n">zO</span> <span class="o">=</span> <span class="n">detect</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">cosbeta</span><span class="p">,</span> <span class="n">sinbeta</span><span class="p">])</span>

    <span class="c1"># OMlab = array([xca0, yca0*sinbeta, yca0*cosbeta])</span>
    <span class="n">xOM</span> <span class="o">=</span> <span class="n">xca0</span>
    <span class="n">yOM</span> <span class="o">=</span> <span class="n">yca0</span> <span class="o">*</span> <span class="n">sinbeta</span>
    <span class="n">zOM</span> <span class="o">=</span> <span class="n">yca0</span> <span class="o">*</span> <span class="n">cosbeta</span>

    <span class="c1"># IMlab = IOlab + OMlab</span>
    <span class="n">xM</span> <span class="o">=</span> <span class="n">xO</span> <span class="o">+</span> <span class="n">xOM</span>
    <span class="n">yM</span> <span class="o">=</span> <span class="n">yO</span> <span class="o">+</span> <span class="n">yOM</span>
    <span class="n">zM</span> <span class="o">=</span> <span class="n">zO</span> <span class="o">+</span> <span class="n">zOM</span>
    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xM</span><span class="p">,</span> <span class="n">yM</span><span class="p">,</span> <span class="n">zM</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># norm of IM vector</span>
    <span class="c1"># nIMlab=sqrt(dot(IMlab,IMlab))</span>
    <span class="n">nIMlab</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xM</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yM</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">zM</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># print transpose(array([xM,yM,zM])) # vector joining source and pt on CCD in abs frame</span>
    <span class="c1"># print nIMlab #distance source pt on CCD (mm)</span>

    <span class="n">uflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xM</span><span class="p">,</span> <span class="n">yM</span><span class="p">,</span> <span class="n">zM</span><span class="p">])</span> <span class="o">/</span> <span class="n">nIMlab</span><span class="p">)</span>
    <span class="c1"># print &quot;uflab&quot;,uflab</span>
    <span class="n">EPS</span> <span class="o">=</span> <span class="mf">1e-17</span>

    <span class="c1"># print(&quot;back reflection mode &quot;, uflab)</span>

    <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">xM</span><span class="p">,</span> <span class="n">zM</span> <span class="o">+</span> <span class="n">EPS</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span>
    <span class="n">twicetheta</span> <span class="o">=</span> <span class="mi">180</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="o">-</span><span class="n">uflab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>
    <span class="c1">#     chiXMAS = np.arctan(uflab[:, 0] / np.sqrt(uflab[:, 1] ** 2 + uflab[:, 2] ** 2)) / DEG</span>
    <span class="c1">#     chiXMAS2 = np.arctan(np.sqrt(uflab[:, 0] ** 2 + uflab[:, 1] ** 2) / uflab[:, 2]) / DEG</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;chi_JSM&quot;</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2theta&quot;</span><span class="p">,</span> <span class="n">twicetheta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">returnAngles</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">uflab</span><span class="p">,</span> <span class="n">IMlab</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># default return</span>
        <span class="k">return</span> <span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span>

<span class="k">def</span> <span class="nf">OM_from_uf</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D vector position of point OM in detector frame plane in pixels</span>
<span class="sd">    alias function to calc_xycam</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">calc_xycam</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="n">energy</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IprimeM_from_uf</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">posI</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from:</span>
<span class="sd">    uflab</span>
<span class="sd">    posI= IIprime = position (3elemts vector) of source with respect to I (calibrated emission source) in millimeter</span>

<span class="sd">    returns:</span>
<span class="sd">    IprimeM vector joining shifted source emission to point M lying on CCD</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">calc_xycam</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">posI</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">returnIpM</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="calc_xycam"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.calc_xycam">[docs]</a><span class="k">def</span> <span class="nf">calc_xycam</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnIpM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mf">2048.</span><span class="p">,</span>
                                                                        <span class="n">rectpix</span><span class="o">=</span><span class="n">RECTPIX</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Laue spots position x and y in pixels units in CCD frame</span>
<span class="sd">    from unit scattered vector uf expressed in Lab. frame</span>

<span class="sd">    computes coordinates of point M on CCD from point source and **uflab**.</span>
<span class="sd">    Point Ip (source Iprime of x-ray scattered beams)</span>
<span class="sd">    (for each Laue spot **uflab** is the unit vector of **IpM**)</span>
<span class="sd">    Point Ip is shifted by offset (if not None) from the default point I</span>
<span class="sd">    (used to calibrate the CCD camera and 2theta chi determination)</span>

<span class="sd">    th0 (theta in degrees)</span>
<span class="sd">    Energy (energy in keV)</span>

<span class="sd">    :param uflab: list or array of [qx,qy,qz] (q vector)</span>
<span class="sd">    :type uflab: list or array (length must &gt; 1)</span>

<span class="sd">    :param calib: list 5 detector calibration parameters</span>
<span class="sd">    :type calib: list of floats</span>

<span class="sd">    :param offset: offset (in mm) in the scattering source (origin of Laue spots)</span>
<span class="sd">            position with respect to the position which has been used</span>
<span class="sd">            for the calibration of  the CCD detector plane. Offset is positive when in the same</span>
<span class="sd">            direction as incident beam (i.e. in sample depth)</span>
<span class="sd">            (incident beam direction remains constant)</span>
<span class="sd">    :type offset: list of floats ([x,y,z])</span>

<span class="sd">    :returns:</span>
<span class="sd">        - xcam: list of pixel X coordinates</span>
<span class="sd">        - ycam: list of pixel Y coordinates</span>
<span class="sd">        - theta: list half scattering angle &quot;theta&quot; (in degree)</span>

<span class="sd">        - optionally energy=1: add in output list of spot energies (in keV)</span>

<span class="sd">        - if returnIpM and offset not None: return list of vectors **IprimeM**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">detect</span><span class="p">,</span> <span class="n">xcen</span><span class="p">,</span> <span class="n">ycen</span><span class="p">,</span> <span class="n">xbet</span><span class="p">,</span> <span class="n">xgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calib</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>

    <span class="c1"># beta = PI/2 - xbet*DEG</span>
    <span class="c1"># xbet angle between IO and z axis</span>
    <span class="c1"># beta angle between y and IO</span>
    <span class="c1"># cosbeta= sin xbet</span>
    <span class="c1"># sinbeta = cos xbet</span>

    <span class="n">cosbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">sinbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="c1"># IOlab: vector joining O nearest point of CCD plane and I (origin of lab frame and emission source)</span>
    <span class="n">IOlab</span> <span class="o">=</span> <span class="n">detect</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cosbeta</span><span class="p">,</span> <span class="n">sinbeta</span><span class="p">])</span>

    <span class="c1"># unitary normal vector of CCD plane</span>
    <span class="c1"># joining O nearest point of CCD plane and I (origin of lab frame and emission source)</span>
    <span class="n">unlab</span> <span class="o">=</span> <span class="n">IOlab</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">IOlab</span><span class="p">,</span> <span class="n">IOlab</span><span class="p">))</span>

    <span class="c1"># normalization of all input uflab</span>
    <span class="n">norme_uflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uflab</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">uflab</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">norme_uflab</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">norme_uflab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># un is orthogonal to any vector joining O and a point M lying in the CCD frame plane</span>
    <span class="n">scal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">unlab</span><span class="p">)</span>
    <span class="n">normeIMlab</span> <span class="o">=</span> <span class="n">detect</span> <span class="o">/</span> <span class="n">scal</span>

    <span class="c1"># IMlab = normeIMlab*uflab</span>
    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">normeIMlab</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">normeIMlab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">OMlab</span> <span class="o">=</span> <span class="n">IMlab</span> <span class="o">-</span> <span class="n">IOlab</span>

    <span class="k">if</span> <span class="n">offset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span>  <span class="c1"># offset input in millimeter</span>
        <span class="c1"># OO&#39;=II&#39;-(II&#39;.un)un  # 1 vector</span>
        <span class="c1"># dd&#39;=  dd - II&#39;.un # scalar</span>
        <span class="c1"># I&#39;M= dd&#39;/(uf.un) uf # n vector</span>
        <span class="c1"># I&#39;O&#39;= dd&#39; un # 1 vectorin</span>
        <span class="c1"># O&#39;M=I&#39;M - I&#39;O&#39; # n vector</span>
        <span class="c1"># OM = OO&#39; + O&#39;M # n vector</span>
        <span class="n">IIprime</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">IIprime_un</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">IIprime</span><span class="p">,</span> <span class="n">unlab</span><span class="p">)</span>
        <span class="n">OOprime</span> <span class="o">=</span> <span class="n">IIprime</span> <span class="o">-</span> <span class="n">IIprime_un</span> <span class="o">*</span> <span class="n">unlab</span>
        <span class="n">ddprime</span> <span class="o">=</span> <span class="n">detect</span> <span class="o">+</span> <span class="n">IIprime_un</span>
        <span class="n">IprimeM_norm</span> <span class="o">=</span> <span class="n">ddprime</span> <span class="o">/</span> <span class="n">scal</span>
        <span class="n">IprimeM</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">IprimeM_norm</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uflab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">IprimeOprime</span> <span class="o">=</span> <span class="n">ddprime</span> <span class="o">*</span> <span class="n">unlab</span>
        <span class="n">OMlab</span> <span class="o">=</span> <span class="n">OOprime</span> <span class="o">+</span> <span class="n">IprimeM</span> <span class="o">-</span> <span class="n">IprimeOprime</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IIprime&quot;</span><span class="p">,</span> <span class="n">IIprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IIprime_un&quot;</span><span class="p">,</span> <span class="n">IIprime_un</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OOprime&quot;</span><span class="p">,</span> <span class="n">OOprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IprimeM_norm&quot;</span><span class="p">,</span> <span class="n">IprimeM_norm</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IprimeM&quot;</span><span class="p">,</span> <span class="n">IprimeM</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dd&quot;</span><span class="p">,</span> <span class="n">detect</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dd&#39;&quot;</span><span class="p">,</span> <span class="n">ddprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OM&quot;</span><span class="p">,</span> <span class="n">OMlab</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">returnIpM</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IprimeM</span>

    <span class="c1"># OMlab = array([xca0, yca0*sinbeta, -yca0*cosbeta])</span>
    <span class="n">xca0</span> <span class="o">=</span> <span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sinbeta</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">yca0</span> <span class="o">=</span> <span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sinbeta</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yca0</span> <span class="o">=</span> <span class="o">-</span><span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">cosbeta</span>
    <span class="c1"># zca0 = 0</span>

    <span class="n">cosgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span> <span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">singam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span> <span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="n">xcam1</span> <span class="o">=</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">xca0</span> <span class="o">+</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">yca0</span>
    <span class="n">ycam1</span> <span class="o">=</span> <span class="o">-</span><span class="n">singam</span> <span class="o">*</span> <span class="n">xca0</span> <span class="o">+</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">yca0</span>

    <span class="n">xcam</span> <span class="o">=</span> <span class="n">xcen</span> <span class="o">+</span> <span class="n">xcam1</span> <span class="o">/</span> <span class="n">pixelsize</span>
    <span class="n">ycam</span> <span class="o">=</span> <span class="n">ycen</span> <span class="o">+</span> <span class="n">ycam1</span> <span class="o">/</span> <span class="p">(</span><span class="n">pixelsize</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">rectpix</span><span class="p">))</span>

    <span class="n">twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">uflab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">th0</span> <span class="o">=</span> <span class="n">twicetheta</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="c1"># q = kf - ki</span>
    <span class="n">qlab</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">norme_qlab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qlab</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">Energy</span> <span class="o">=</span> <span class="n">CST_CONV_LAMBDA_KEV</span> <span class="o">*</span> <span class="n">norme_qlab</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th0</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">energy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">th0</span><span class="p">,</span> <span class="n">Energy</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">th0</span></div>


<span class="k">def</span> <span class="nf">calc_xycam_backreflection</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnIpM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                            <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                            <span class="n">rectpix</span><span class="o">=</span><span class="n">RECTPIX</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Laue spots position x and y in pixels units (in CCD frame) from scattering vector q</span>

<span class="sd">    As calc_xycam() but in BACK REFLECTION geometry</span>


<span class="sd">     cosbeta = np.cos(-xbet * DEG)</span>
<span class="sd">    sinbeta = np.sin(-xbet * DEG)</span>

<span class="sd">    cosgam = np.cos(- xgam * DEG)</span>
<span class="sd">    singam = np.sin(- xgam * DEG)  # negative</span>

<span class="sd">    xcam1 = (np.array(xcam) - xcen) * pixelsize</span>
<span class="sd">    ycam1 = (np.array(ycam) - ycen) * pixelsize * (1.0 + rectpix)</span>

<span class="sd">    xca0 = cosgam * xcam1 - singam * ycam1</span>
<span class="sd">    yca0 = singam * xcam1 + cosgam * ycam1</span>

<span class="sd">    # I centre</span>
<span class="sd">    # O centre of origin of pixel CCD plane array</span>
<span class="sd">    # M belong to CCD plane</span>
<span class="sd">    # IM is parallel to kf (or uf = kf/||kf||)</span>

<span class="sd">    # IOlab = detect * array([0.0, -cosbeta, sinbeta])</span>
<span class="sd">    xO, yO, zO = detect * np.array([0.0, -cosbeta, sinbeta])</span>

<span class="sd">    # OMlab = array([xca0, yca0*sinbeta, yca0*cosbeta])</span>
<span class="sd">    xOM = xca0</span>
<span class="sd">    yOM = yca0 * sinbeta</span>
<span class="sd">    zOM = yca0 * cosbeta</span>

<span class="sd">    # IMlab = IOlab + OMlab</span>
<span class="sd">    xM = xO + xOM</span>
<span class="sd">    yM = yO + yOM</span>
<span class="sd">    zM = zO + zOM</span>
<span class="sd">    IMlab = np.array([xM, yM, zM]).T</span>

<span class="sd">    # norm of IM vector</span>
<span class="sd">    # nIMlab=sqrt(dot(IMlab,IMlab))</span>
<span class="sd">    nIMlab = 1.0 * np.sqrt(xM ** 2 + yM ** 2 + zM ** 2)</span>

<span class="sd">    # print transpose(array([xM,yM,zM])) # vector joining source and pt on CCD in abs frame</span>
<span class="sd">    # print nIMlab #distance source pt on CCD (mm)</span>

<span class="sd">    uflab = np.transpose(np.array([xM, yM, zM]) / nIMlab)</span>
<span class="sd">    # print &quot;uflab&quot;,uflab</span>
<span class="sd">    EPS = 1e-17</span>

<span class="sd">    print(&quot;back reflection mode &quot;, uflab)</span>

<span class="sd">    chi = np.arctan2(-xM, zM + EPS) / DEG</span>
<span class="sd">    twicetheta = 180-np.arccos(-uflab[:, 1]) / DEG</span>
<span class="sd">    #     chiXMAS = np.arctan(uflab[:, 0] / np.sqrt(uflab[:, 1] ** 2 + uflab[:, 2] ** 2)) / DEG</span>
<span class="sd">    #     chiXMAS2 = np.arctan(np.sqrt(uflab[:, 0] ** 2 + uflab[:, 1] ** 2) / uflab[:, 2]) / DEG</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(&quot;chi_JSM&quot;, chi)</span>
<span class="sd">        print(&quot;2theta&quot;, twicetheta)</span>

<span class="sd">    if returnAngles != 1:</span>
<span class="sd">        return uflab, IMlab</span>
<span class="sd">    else:  # default return</span>
<span class="sd">        return twicetheta, chi</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distance_IO</span><span class="p">,</span> <span class="n">xcen</span><span class="p">,</span> <span class="n">ycen</span><span class="p">,</span> <span class="n">xbet</span><span class="p">,</span> <span class="n">xgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calib</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>

    <span class="c1"># beta = PI/2 - xbet*DEG</span>
    <span class="c1"># xbet angle between IO and z axis</span>
    <span class="c1"># beta angle between y and IO</span>
    <span class="c1"># cosbeta= sin xbet</span>
    <span class="c1"># sinbeta = cos xbet</span>

    <span class="c1">#     cosbeta = np.cos(PI / 2. - xbet * DEG)</span>
    <span class="c1">#     sinbeta = np.sin(PI / 2. - xbet * DEG)</span>

    <span class="n">cosbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">sinbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="c1"># if xbet positive bottom part of CCD is closer to sample than top part</span>

    <span class="c1">#    print &quot;cosbeta&quot;, cosbeta</span>
    <span class="c1">#    print &quot;sinbeta&quot;, sinbeta</span>

    <span class="c1"># IOlab: vector joining O nearest point of CCD plane and I (origin of lab frame and emission source)</span>

    <span class="n">IOlab</span> <span class="o">=</span> <span class="n">distance_IO</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">cosbeta</span><span class="p">,</span> <span class="n">sinbeta</span><span class="p">])</span>

    <span class="c1"># sinbeta negative for xbet positive</span>

    <span class="c1">#    print &quot;IOlab&quot;, IOlab</span>

    <span class="c1"># unitary normal vector of CCD plane</span>
    <span class="c1"># joining O nearest point of CCD plane and I (origin of lab frame and emission source)</span>
    <span class="n">unlab</span> <span class="o">=</span> <span class="n">IOlab</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">IOlab</span><span class="p">,</span> <span class="n">IOlab</span><span class="p">))</span>

    <span class="c1"># normalization of all input uflab</span>
    <span class="n">norme_uflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uflab</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">uflab</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">norme_uflab</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">norme_uflab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># un is orthogonal to any vector joining O and a point M lying in the CCD frame plane</span>
    <span class="n">scal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">unlab</span><span class="p">)</span>
    <span class="n">normeIMlab</span> <span class="o">=</span> <span class="n">distance_IO</span> <span class="o">/</span> <span class="n">scal</span>

    <span class="c1"># IMlab = normeIMlab*uflab</span>
    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">normeIMlab</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">normeIMlab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">OMlab</span> <span class="o">=</span> <span class="n">IMlab</span> <span class="o">-</span> <span class="n">IOlab</span>

    <span class="c1">#    print &quot;OMlab&quot;, OMlab</span>

    <span class="k">if</span> <span class="n">offset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span>  <span class="c1"># offset input in millimeter</span>
        <span class="c1"># OO&#39;=II&#39;-(II&#39;.un)un  # 1 vector</span>
        <span class="c1"># dd&#39;=  dd - II&#39;.un # scalar</span>
        <span class="c1"># I&#39;M= dd&#39;/(uf.un) uf # n vector</span>
        <span class="c1"># I&#39;O&#39;= dd&#39; un # 1 vector</span>
        <span class="c1"># O&#39;M=I&#39;M - I&#39;O&#39; # n vector</span>
        <span class="c1"># OM = OO&#39; + O&#39;M # n vector</span>
        <span class="n">IIprime</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="n">IIprime_un</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">IIprime</span><span class="p">,</span> <span class="n">unlab</span><span class="p">)</span>
        <span class="n">OOprime</span> <span class="o">=</span> <span class="n">IIprime</span> <span class="o">-</span> <span class="n">IIprime_un</span> <span class="o">*</span> <span class="n">unlab</span>
        <span class="n">ddprime</span> <span class="o">=</span> <span class="n">distance_IO</span> <span class="o">+</span> <span class="n">IIprime_un</span>
        <span class="n">IprimeM_norm</span> <span class="o">=</span> <span class="n">ddprime</span> <span class="o">/</span> <span class="n">scal</span>
        <span class="n">IprimeM</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">IprimeM_norm</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uflab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">IprimeOprime</span> <span class="o">=</span> <span class="n">ddprime</span> <span class="o">*</span> <span class="n">unlab</span>
        <span class="n">OMlab</span> <span class="o">=</span> <span class="n">OOprime</span> <span class="o">+</span> <span class="n">IprimeM</span> <span class="o">-</span> <span class="n">IprimeOprime</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IIprime&quot;</span><span class="p">,</span> <span class="n">IIprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IIprime_un&quot;</span><span class="p">,</span> <span class="n">IIprime_un</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OOprime&quot;</span><span class="p">,</span> <span class="n">OOprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IprimeM_norm&quot;</span><span class="p">,</span> <span class="n">IprimeM_norm</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IprimeM&quot;</span><span class="p">,</span> <span class="n">IprimeM</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dd&quot;</span><span class="p">,</span> <span class="n">distance_IO</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dd&#39;&quot;</span><span class="p">,</span> <span class="n">ddprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OM&quot;</span><span class="p">,</span> <span class="n">OMlab</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">returnIpM</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IprimeM</span>

    <span class="c1"># OMlab = array([xca0, yca0*sinbeta, yca0*cosbeta])</span>
    <span class="n">xca0</span> <span class="o">=</span> <span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sinbeta</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">yca0</span> <span class="o">=</span> <span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sinbeta</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yca0</span> <span class="o">=</span> <span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">cosbeta</span>
    <span class="c1"># zca0 = 0</span>

    <span class="n">cosgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">singam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="n">xcam1</span> <span class="o">=</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">xca0</span> <span class="o">+</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">yca0</span>
    <span class="n">ycam1</span> <span class="o">=</span> <span class="o">-</span><span class="n">singam</span> <span class="o">*</span> <span class="n">xca0</span> <span class="o">+</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">yca0</span>

    <span class="c1">#    print &quot;xcam1&quot;, xcam1</span>
    <span class="c1">#    print &quot;ycam1&quot;, ycam1</span>

    <span class="n">xcam</span> <span class="o">=</span> <span class="n">xcen</span> <span class="o">+</span> <span class="n">xcam1</span> <span class="o">/</span> <span class="n">pixelsize</span>
    <span class="n">ycam</span> <span class="o">=</span> <span class="n">ycen</span> <span class="o">+</span> <span class="n">ycam1</span> <span class="o">/</span> <span class="p">(</span><span class="n">pixelsize</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">rectpix</span><span class="p">))</span>

    <span class="n">twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">uflab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">th0</span> <span class="o">=</span> <span class="n">twicetheta</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="c1"># q = kf - ki</span>
    <span class="n">qf</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">norme_qflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qf</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">Energy</span> <span class="o">=</span> <span class="n">CST_CONV_LAMBDA_KEV</span> <span class="o">*</span> <span class="n">norme_qflab</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th0</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">energy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">th0</span><span class="p">,</span> <span class="n">Energy</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">th0</span>

<div class="viewcode-block" id="calc_xycam_transmission"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.calc_xycam_transmission">[docs]</a><span class="k">def</span> <span class="nf">calc_xycam_transmission</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnIpM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                            <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                            <span class="n">rectpix</span><span class="o">=</span><span class="n">RECTPIX</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Laue spots position x and y in pixels units (in CCD frame) from scattering vector q</span>

<span class="sd">    As calc_xycam() but in TRANSMISSION geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">distance_IO</span><span class="p">,</span> <span class="n">xcen</span><span class="p">,</span> <span class="n">ycen</span><span class="p">,</span> <span class="n">xbet</span><span class="p">,</span> <span class="n">xgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calib</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>

    <span class="c1"># beta = PI/2 - xbet*DEG</span>
    <span class="c1"># xbet angle between IO and z axis</span>
    <span class="c1"># beta angle between y and IO</span>
    <span class="c1"># cosbeta= sin xbet</span>
    <span class="c1"># sinbeta = cos xbet</span>

    <span class="c1">#     cosbeta = np.cos(PI / 2. - xbet * DEG)</span>
    <span class="c1">#     sinbeta = np.sin(PI / 2. - xbet * DEG)</span>

    <span class="n">cosbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">sinbeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">xbet</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="c1"># if xbet positive bottom part of CCD is closer to sample than top part</span>

    <span class="c1">#    print &quot;cosbeta&quot;, cosbeta</span>
    <span class="c1">#    print &quot;sinbeta&quot;, sinbeta</span>

    <span class="c1"># IOlab: vector joining O nearest point of CCD plane and I (origin of lab frame and emission source)</span>

    <span class="n">IOlab</span> <span class="o">=</span> <span class="n">distance_IO</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cosbeta</span><span class="p">,</span> <span class="n">sinbeta</span><span class="p">])</span>

    <span class="c1"># sinbeta negative for xbet positive</span>

    <span class="c1">#    print &quot;IOlab&quot;, IOlab</span>

    <span class="c1"># unitary normal vector of CCD plane</span>
    <span class="c1"># joining O nearest point of CCD plane and I (origin of lab frame and emission source)</span>
    <span class="n">unlab</span> <span class="o">=</span> <span class="n">IOlab</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">IOlab</span><span class="p">,</span> <span class="n">IOlab</span><span class="p">))</span>

    <span class="c1"># normalization of all input uflab</span>
    <span class="n">norme_uflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uflab</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">uflab</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">norme_uflab</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">norme_uflab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># un is orthogonal to any vector joining O and a point M lying in the CCD frame plane</span>
    <span class="n">scal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">unlab</span><span class="p">)</span>
    <span class="n">normeIMlab</span> <span class="o">=</span> <span class="n">distance_IO</span> <span class="o">/</span> <span class="n">scal</span>

    <span class="c1"># IMlab = normeIMlab*uflab</span>
    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">normeIMlab</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">normeIMlab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">OMlab</span> <span class="o">=</span> <span class="n">IMlab</span> <span class="o">-</span> <span class="n">IOlab</span>

    <span class="c1">#    print &quot;OMlab&quot;, OMlab</span>

    <span class="k">if</span> <span class="n">offset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span>  <span class="c1"># offset input in millimeter</span>
        <span class="c1"># OO&#39;=II&#39;-(II&#39;.un)un  # 1 vector</span>
        <span class="c1"># dd&#39;=  dd - II&#39;.un # scalar</span>
        <span class="c1"># I&#39;M= dd&#39;/(uf.un) uf # n vector</span>
        <span class="c1"># I&#39;O&#39;= dd&#39; un # 1 vector</span>
        <span class="c1"># O&#39;M=I&#39;M - I&#39;O&#39; # n vector</span>
        <span class="c1"># OM = OO&#39; + O&#39;M # n vector</span>
        <span class="n">IIprime</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="n">IIprime_un</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">IIprime</span><span class="p">,</span> <span class="n">unlab</span><span class="p">)</span>
        <span class="n">OOprime</span> <span class="o">=</span> <span class="n">IIprime</span> <span class="o">-</span> <span class="n">IIprime_un</span> <span class="o">*</span> <span class="n">unlab</span>
        <span class="n">ddprime</span> <span class="o">=</span> <span class="n">distance_IO</span> <span class="o">+</span> <span class="n">IIprime_un</span>
        <span class="n">IprimeM_norm</span> <span class="o">=</span> <span class="n">ddprime</span> <span class="o">/</span> <span class="n">scal</span>
        <span class="n">IprimeM</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">IprimeM_norm</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uflab</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">IprimeOprime</span> <span class="o">=</span> <span class="n">ddprime</span> <span class="o">*</span> <span class="n">unlab</span>
        <span class="n">OMlab</span> <span class="o">=</span> <span class="n">OOprime</span> <span class="o">+</span> <span class="n">IprimeM</span> <span class="o">-</span> <span class="n">IprimeOprime</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IIprime&quot;</span><span class="p">,</span> <span class="n">IIprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IIprime_un&quot;</span><span class="p">,</span> <span class="n">IIprime_un</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OOprime&quot;</span><span class="p">,</span> <span class="n">OOprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IprimeM_norm&quot;</span><span class="p">,</span> <span class="n">IprimeM_norm</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IprimeM&quot;</span><span class="p">,</span> <span class="n">IprimeM</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dd&quot;</span><span class="p">,</span> <span class="n">distance_IO</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dd&#39;&quot;</span><span class="p">,</span> <span class="n">ddprime</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OM&quot;</span><span class="p">,</span> <span class="n">OMlab</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">returnIpM</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IprimeM</span>

    <span class="c1"># OMlab = array([xca0, yca0*sinbeta, -yca0*cosbeta])</span>
    <span class="n">xca0</span> <span class="o">=</span> <span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sinbeta</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">yca0</span> <span class="o">=</span> <span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sinbeta</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yca0</span> <span class="o">=</span> <span class="o">-</span><span class="n">OMlab</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">cosbeta</span>
    <span class="c1"># zca0 = 0</span>

    <span class="n">cosgam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">singam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">xgam</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="n">xcam1</span> <span class="o">=</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">xca0</span> <span class="o">+</span> <span class="n">singam</span> <span class="o">*</span> <span class="n">yca0</span>
    <span class="n">ycam1</span> <span class="o">=</span> <span class="o">-</span><span class="n">singam</span> <span class="o">*</span> <span class="n">xca0</span> <span class="o">+</span> <span class="n">cosgam</span> <span class="o">*</span> <span class="n">yca0</span>

    <span class="c1">#    print &quot;xcam1&quot;, xcam1</span>
    <span class="c1">#    print &quot;ycam1&quot;, ycam1</span>

    <span class="n">xcam</span> <span class="o">=</span> <span class="n">xcen</span> <span class="o">+</span> <span class="n">xcam1</span> <span class="o">/</span> <span class="n">pixelsize</span>
    <span class="n">ycam</span> <span class="o">=</span> <span class="n">ycen</span> <span class="o">+</span> <span class="n">ycam1</span> <span class="o">/</span> <span class="p">(</span><span class="n">pixelsize</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">rectpix</span><span class="p">))</span>

    <span class="n">twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">uflab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">th0</span> <span class="o">=</span> <span class="n">twicetheta</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="c1"># q = kf - ki</span>
    <span class="n">qf</span> <span class="o">=</span> <span class="n">uflab</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">norme_qflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qf</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">Energy</span> <span class="o">=</span> <span class="n">CST_CONV_LAMBDA_KEV</span> <span class="o">*</span> <span class="n">norme_qflab</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th0</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">energy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">th0</span><span class="p">,</span> <span class="n">Energy</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">th0</span></div>


<span class="k">def</span> <span class="nf">calc_xycam_from2thetachi</span><span class="p">(</span><span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                        <span class="n">kf_direction</span><span class="o">=</span><span class="s2">&quot;Z&gt;0&quot;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate spots coordinates in pixel units in detector plane</span>
<span class="sd">    from 2theta, chi angles (kf)</span>

<span class="sd">    :param offset: offset (in mm) in the scattering source (origin of Laue spots)</span>
<span class="sd">        position with respect to the position which has been used</span>
<span class="sd">        for the calibration of  the CCD detector plane. Offset is positive when in the same</span>
<span class="sd">        direction as incident beam (i.e. in sample depth)</span>
<span class="sd">        (incident beam direction remains constant)</span>
<span class="sd">    :type offset: list of floats ([x,y,z])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># scattered vector not in Lauetools frame (y//ki)</span>
    <span class="n">uflab</span> <span class="o">=</span> <span class="n">uflab_from2thetachi</span><span class="p">(</span><span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;uflab&quot;</span><span class="p">,</span> <span class="n">uflab</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kf_direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Z&gt;0&quot;</span><span class="p">,):</span>  <span class="c1"># , &#39;[90.0, 45.0]&#39;):</span>
        <span class="k">return</span> <span class="n">calc_xycam</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Y&gt;0&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&lt;0&quot;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CAUTION: not checked yet&quot;</span><span class="p">)</span>
        <span class="c1"># TODO raise ValueError, print &quot;not checked yet&quot;</span>
        <span class="k">return</span> <span class="n">calc_xycam</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;X&gt;0&quot;</span><span class="p">,):</span>  <span class="c1"># transmission</span>
        <span class="k">return</span> <span class="n">calc_xycam_transmission</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;X&lt;0&quot;</span><span class="p">,):</span>  <span class="c1"># back-reflection</span>
        <span class="c1"># patch JSM March 2020</span>
        <span class="k">return</span> <span class="n">calc_xycam_backreflection</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sentence</span> <span class="o">=</span> <span class="s2">&quot;kf_direction = </span><span class="si">%s</span><span class="s2"> is not implemented yet &quot;</span> <span class="o">%</span> <span class="n">kf_direction</span>
        <span class="n">sentence</span> <span class="o">+=</span> <span class="s2">&quot;in calc_xycam_from2thetachi() in find2thetachi&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>


<div class="viewcode-block" id="uflab_from2thetachi"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.uflab_from2thetachi">[docs]</a><span class="k">def</span> <span class="nf">uflab_from2thetachi</span><span class="p">(</span><span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes :math:`{\bf u_f}` vectors coordinates in lauetools LT2 frame</span>
<span class="sd">    from :math:`{\bf k_f}` scattering angles :math:`2 \theta` and :math:`2 \chi` angles</span>

<span class="sd">    :param twicetheta: (list) :math:`2 \theta` angle(s) ( in degree)</span>
<span class="sd">    :param chi: (list) :math:`2 \chi` angle(s) ( in degree)</span>

<span class="sd">    :returns: list of `{\bf u_f}` =  [:math:`uf_x,uf_y,uf_z`]</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ctw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">twicetheta</span><span class="p">)</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">stw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">twicetheta</span><span class="p">)</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">cchi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">schi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="n">xuflab</span> <span class="o">=</span> <span class="o">-</span><span class="n">stw</span> <span class="o">*</span> <span class="n">schi</span>
    <span class="n">yuflab</span> <span class="o">=</span> <span class="n">ctw</span>
    <span class="n">zuflab</span> <span class="o">=</span> <span class="n">stw</span> <span class="o">*</span> <span class="n">cchi</span>

    <span class="n">uflab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xuflab</span><span class="p">,</span> <span class="n">yuflab</span><span class="p">,</span> <span class="n">zuflab</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;uflab&quot;</span><span class="p">,</span> <span class="n">uflab</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">uflab</span></div>


<span class="k">def</span> <span class="nf">q_unit_XYZ</span><span class="p">(</span><span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes unit vector of :math:`{\bf q}` (scattering transfer moment) :math:`{\bf u_q}`</span>
<span class="sd">    from scattered :math:`{\bf k_f}` angles</span>
<span class="sd">    # TODO: useful ? check with from_twchi_to_qunit()</span>
<span class="sd">    lauetools frame</span>
<span class="sd">    #in degrees</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">THETA</span> <span class="o">=</span> <span class="n">twicetheta</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">CHI</span> <span class="o">=</span> <span class="n">chi</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">THETA</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">THETA</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">CHI</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">THETA</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">CHI</span><span class="p">)])</span>


<span class="k">def</span> <span class="nf">q_unit_2thetachi</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes 2theta and chi scattering angles from a u_q vector expressed in LaueTools frame</span>
<span class="sd">    #result in deg</span>
<span class="sd">    # TODO: useful ? check with from_qunit_to_twchi()</span>
<span class="sd">    lauetools frame ?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
    <span class="c1"># TODO: sign of chi must be checked</span>
    <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">theta</span><span class="p">,</span> <span class="n">chi</span><span class="p">])</span>


<div class="viewcode-block" id="from_twchi_to_qunit"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.from_twchi_to_qunit">[docs]</a><span class="k">def</span> <span class="nf">from_twchi_to_qunit</span><span class="p">(</span><span class="n">Angles</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from kf 2theta, chi to q unit in LaueTools frame (xx// ki) q=kf-ki</span>
<span class="sd">    returns array = (all x&#39;s, all y&#39;s, all z&#39;s)</span>

<span class="sd">    Angles in degrees !!</span>
<span class="sd">    Angles[0] 2theta deg values,</span>
<span class="sd">    Angles[1] chi values in deg</span>

<span class="sd">    this is the inverse function of from_qunit_to_twchi(), useful to check it</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">twthe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Angles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Angles</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">no</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">twthe</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">qx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">twthe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">qy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">twthe</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>
    <span class="n">qz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">twthe</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">])</span> <span class="o">/</span> <span class="n">no</span></div>


<div class="viewcode-block" id="from_twchi_to_q"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.from_twchi_to_q">[docs]</a><span class="k">def</span> <span class="nf">from_twchi_to_q</span><span class="p">(</span><span class="n">Angles</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From kf 2theta,chi to q (arbitrary lenght) in lab frame (xx// ki) q=kf-ki</span>
<span class="sd">    returns array = (all qx&#39;s, all qy&#39;s, all qz&#39;s)</span>

<span class="sd">    Angles in degrees !!</span>
<span class="sd">    Angles[0] 2theta deg values,</span>
<span class="sd">    Angles[1] chi values in deg</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">twthe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Angles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Angles</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">qx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">twthe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">qy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">twthe</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>
    <span class="n">qz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">twthe</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">])</span></div>


<div class="viewcode-block" id="from_qunit_to_twchi"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.from_qunit_to_twchi">[docs]</a><span class="k">def</span> <span class="nf">from_qunit_to_twchi</span><span class="p">(</span><span class="n">arrayXYZ</span><span class="p">,</span> <span class="n">labXMAS</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns 2theta chi from a q unit vector (defining a direction) expressed in LaueTools frame (**xx**// **ki**) **q=kf-ki**</span>

<span class="sd">    .. math:: \left [ \begin{matrix}</span>
<span class="sd">        -\sin \theta \\ \cos \theta \sin \chi \\ \cos \theta \cos \chi</span>
<span class="sd">        \end{matrix}</span>
<span class="sd">        \right ]</span>

<span class="sd">    .. note::</span>
<span class="sd">        in LaueTools frame</span>

<span class="sd">        .. math::</span>
<span class="sd">            kf = \left [ \begin{matrix}</span>
<span class="sd">            \cos 2\theta \\ \sin 2\theta \sin \chi \\ \sin 2\theta \cos \chi</span>
<span class="sd">            \end{matrix}</span>
<span class="sd">            \right ]</span>

<span class="sd">            q = 2 \sin \theta \left [ \begin{matrix}</span>
<span class="sd">            -\sin \theta \\ \cos \theta \sin \chi \\ \cos \theta \cos \chi</span>
<span class="sd">            \end{matrix}</span>
<span class="sd">            \right ]</span>

<span class="sd">        In LT2 Frame   labXMAS=1</span>

<span class="sd">        .. math::</span>
<span class="sd">            kf = \left [ \begin{matrix}</span>
<span class="sd">            \sin 2\theta \sin \chi \\ \cos 2\theta \\ \sin 2\theta \cos \chi</span>
<span class="sd">            \end{matrix}</span>
<span class="sd">            \right ]</span>

<span class="sd">            q = 2 \sin \theta \left [ \begin{matrix}</span>
<span class="sd">            \cos \theta \sin \chi \\ -\sin \theta \\ \cos \theta \cos \chi</span>
<span class="sd">            \end{matrix}</span>
<span class="sd">            \right ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">arrayXYZ</span>

    <span class="k">if</span> <span class="n">labXMAS</span><span class="p">:</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">X</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
        <span class="n">twthe</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="o">-</span><span class="n">Y</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># labXMAS=0  lauetools</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Y</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
        <span class="n">twthe</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="o">-</span><span class="n">X</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">twthe</span><span class="p">,</span> <span class="n">chi</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span></div>


<div class="viewcode-block" id="qvector_from_xy_E"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.qvector_from_xy_E">[docs]</a><span class="k">def</span> <span class="nf">qvector_from_xy_E</span><span class="p">(</span><span class="n">xcamList</span><span class="p">,</span> <span class="n">ycamList</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">detectorplaneparameters</span><span class="p">,</span> <span class="n">pixelsize</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns q vectors in Lauetools frame given x and y pixel positions on detector</span>
<span class="sd">    for a given Energy (keV)</span>

<span class="sd">    :param xcamList: list pixel x postions</span>
<span class="sd">    :param ycamList: list pixel y postions</span>
<span class="sd">    :param energy: list pf energies</span>
<span class="sd">    :param detectorplaneparameters: list of 5 calibration parameters</span>
<span class="sd">    :param pixelsize: pixel size in mm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># in LT&#39;s frame (x// ki)</span>

    <span class="c1">#     print &quot;xcamList&quot;,xcamList</span>
    <span class="c1">#     print &quot;ycamList&quot;,ycamList</span>
    <span class="n">twtheta</span><span class="p">,</span> <span class="n">chi</span> <span class="o">=</span> <span class="n">calc_uflab</span><span class="p">(</span><span class="n">xcamList</span><span class="p">,</span> <span class="n">ycamList</span><span class="p">,</span> <span class="n">detectorplaneparameters</span><span class="p">,</span> <span class="n">returnAngles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                                        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                        <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                                                        <span class="n">rectpix</span><span class="o">=</span><span class="n">RECTPIX</span><span class="p">,</span>
                                                                        <span class="n">kf_direction</span><span class="o">=</span><span class="s2">&quot;Z&gt;0&quot;</span><span class="p">)</span>

    <span class="n">thetarad</span> <span class="o">=</span> <span class="n">twtheta</span> <span class="o">*</span> <span class="n">DEG</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">chirad</span> <span class="o">=</span> <span class="n">chi</span> <span class="o">*</span> <span class="n">DEG</span>

    <span class="n">qx</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span>
    <span class="n">qy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">chirad</span><span class="p">)</span>
    <span class="n">qz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">chirad</span><span class="p">)</span>

    <span class="n">newq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">])</span>
    <span class="n">normnewq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">qy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">qz</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">qvec</span> <span class="o">=</span> <span class="n">newq</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">normnewq</span><span class="p">)</span>
    <span class="c1">#     print &quot;qvec&quot;,qvec</span>

    <span class="c1">#     print &quot;energy&quot;,energy</span>

    <span class="n">qvector_Lauetoolsframe</span> <span class="o">=</span> <span class="n">qvec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">energy</span> <span class="o">/</span> <span class="mf">12.398</span><span class="p">)</span>

    <span class="c1">#     print &quot;qvector_Lauetoolsframe&quot;,qvector_Lauetoolsframe</span>

    <span class="k">return</span> <span class="n">qvector_Lauetoolsframe</span></div>


<div class="viewcode-block" id="unit_q"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.unit_q">[docs]</a><span class="k">def</span> <span class="nf">unit_q</span><span class="p">(</span><span class="n">ttheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;lauetools&quot;</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns unit q vector from 2theta,chi coordinates</span>

<span class="sd">    :param ttheta: list of 2theta angles (in degrees)</span>
<span class="sd">    :param chi: list of chi angles (in degrees)</span>
<span class="sd">    :param anglesample: incidence angle of beam to surface plane (degrees)</span>
<span class="sd">    :param frame: frame to express vectors in: &#39;lauetools&#39; , &#39;XMASlab&#39; (LT2 frame),&#39;XMASsample&#39;</span>

<span class="sd">    :returns: list of 3D u_f (unit vector of scattering transfer q)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">thetarad</span> <span class="o">=</span> <span class="n">ttheta</span> <span class="o">*</span> <span class="n">DEG</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">chirad</span> <span class="o">=</span> <span class="n">chi</span> <span class="o">*</span> <span class="n">DEG</span>

    <span class="k">if</span> <span class="n">frame</span> <span class="o">==</span> <span class="s2">&quot;lauetools&quot;</span><span class="p">:</span>
        <span class="n">qx</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span>
        <span class="n">qy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">chirad</span><span class="p">)</span>
        <span class="n">qz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">chirad</span><span class="p">)</span>

        <span class="n">newq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">])</span>
        <span class="n">normnewq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">newq</span><span class="p">,</span> <span class="n">newq</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">newq</span> <span class="o">/</span> <span class="n">normnewq</span>
    <span class="c1"># LT2 frame</span>
    <span class="k">elif</span> <span class="n">frame</span> <span class="o">==</span> <span class="s2">&quot;XMASlab&quot;</span><span class="p">:</span>
        <span class="c1"># chi convention:</span>
        <span class="c1"># y along Xray horizontal</span>
        <span class="c1"># x towards wall behind horizontal</span>
        <span class="c1"># z vertical up</span>

        <span class="c1"># kf=( - sin 2theta sin chi, cos 2theta  , sin 2theta cos chi) XMAS convention</span>
        <span class="c1"># ki=( 0, 1  , 0) XMAS convention</span>
        <span class="c1"># q = 2 sin theta (- costheta sinchi , - sintheta  ,  costheta coschi)</span>
        <span class="c1">#  unitkf  =  unitki  +   2sintheta unitq</span>

        <span class="n">qx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">chirad</span><span class="p">)</span>
        <span class="n">qy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span>
        <span class="n">qz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">chirad</span><span class="p">)</span>

        <span class="n">newq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">])</span>
        <span class="n">normnewq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">newq</span><span class="p">,</span> <span class="n">newq</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">newq</span> <span class="o">/</span> <span class="n">normnewq</span>
    <span class="c1"># LT2 sample frame</span>
    <span class="k">elif</span> <span class="n">frame</span> <span class="o">==</span> <span class="s2">&quot;XMASsample&quot;</span><span class="p">:</span>

        <span class="c1"># kf=( - sin 2theta sin chi, cos 2theta  , sin 2theta cos chi) XMAS convention</span>
        <span class="c1"># ki=( 0, 1  , 0) XMAS convention</span>
        <span class="c1"># q = 2 sin theta (- costheta sinchi , - sintheta  ,  costheta coschi)</span>
        <span class="c1">#  unitkf  =  unitki  +   2sintheta unitq</span>

        <span class="n">angrad</span> <span class="o">=</span> <span class="n">anglesample</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>  <span class="c1"># Must include -xbet/2 correction ???</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angrad</span><span class="p">)</span>
        <span class="n">sa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angrad</span><span class="p">)</span>

        <span class="n">matrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">sa</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">sa</span><span class="p">,</span> <span class="n">ca</span><span class="p">]])</span>

        <span class="n">qx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">chirad</span><span class="p">)</span>
        <span class="n">qy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span>
        <span class="n">qz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetarad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">chirad</span><span class="p">)</span>

        <span class="n">newq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrot</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span><span class="p">]))</span>
        <span class="n">normnewq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">newq</span><span class="p">,</span> <span class="n">newq</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">newq</span> <span class="o">/</span> <span class="n">normnewq</span></div>


<span class="k">def</span> <span class="nf">plotXY2thetachi</span><span class="p">(</span><span class="n">datX</span><span class="p">,</span> <span class="n">datY</span><span class="p">,</span> <span class="n">dat2the</span><span class="p">,</span> <span class="n">datchi</span><span class="p">,</span> <span class="n">mostintense</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    old script to combine plot of pixel x,y and 2theta chi plot</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mostintense</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mostintense</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">datX</span><span class="p">):</span>
        <span class="n">data_x</span> <span class="o">=</span> <span class="n">datX</span><span class="p">[:</span><span class="n">mostintense</span><span class="p">]</span>
        <span class="n">data_y</span> <span class="o">=</span> <span class="n">datY</span><span class="p">[:</span><span class="n">mostintense</span><span class="p">]</span>
        <span class="n">twicetheta</span> <span class="o">=</span> <span class="n">dat2the</span><span class="p">[:</span><span class="n">mostintense</span><span class="p">]</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="n">datchi</span><span class="p">[:</span><span class="n">mostintense</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_x</span> <span class="o">=</span> <span class="n">datX</span>
        <span class="n">data_y</span> <span class="o">=</span> <span class="n">datY</span>
        <span class="n">twicetheta</span> <span class="o">=</span> <span class="n">dat2the</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="n">datchi</span>

    <span class="n">plot1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
    <span class="n">plot1</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
    <span class="n">P</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
    <span class="n">P</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">)</span>
    <span class="n">plot1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">data_x</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data_y</span><span class="p">))</span>

    <span class="n">plot2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
    <span class="n">plot2</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">P</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;chi&quot;</span><span class="p">)</span>
    <span class="n">P</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;2theta&quot;</span><span class="p">)</span>
    <span class="n">plot2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">chi</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">twicetheta</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>

    <span class="n">P</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># ---------------    Frame Matrix conversion</span>
<span class="k">def</span> <span class="nf">matxmas_to_OrientMatrix</span><span class="p">(</span><span class="n">satocr</span><span class="p">,</span> <span class="n">calib</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    thanks to Odile robach&#39;s reverse engineering hard work</span>

<span class="sd">    From XMAS matrices in IND file to matrix in lauetools frame</span>
<span class="sd">    convert matrix from XMAS sample axes to lab axes + normalize by astar</span>

<span class="sd">    - calib with last angles in degrees</span>

<span class="sd">    - satocrs = transposee de la matrice numero 2 du .STR :   matrice UB</span>
<span class="sd">    &quot;coordinates of a*, b*, c* in X, Y, Z&quot;</span>
<span class="sd">    - satocru = matrice numero 2 du .IND :   matrice U</span>
<span class="sd">    &quot;matrix hkl =&gt; XYZ&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">astar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">satocr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="c1"># print &quot;satocr \n&quot;, satocr</span>
    <span class="n">satocrnorm</span> <span class="o">=</span> <span class="n">satocr</span> <span class="o">/</span> <span class="n">astar</span>  <span class="c1"># sample to crystal: satocr</span>
    <span class="c1"># print &quot;satocrnorm \n&quot;, satocrnorm</span>

    <span class="n">omega0</span> <span class="o">=</span> <span class="mf">40.0</span>  <span class="c1"># deg</span>
    <span class="n">xbet</span> <span class="o">=</span> <span class="n">calib</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">DEG</span>  <span class="c1"># rad</span>
    <span class="c1"># print &quot;xbet in rad&quot; , xbet</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">omega0</span> <span class="o">*</span> <span class="n">DEG</span> <span class="o">-</span> <span class="n">xbet</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="c1"># print &quot;omega&quot; , omega*180.0/np.pi</span>

    <span class="c1"># rotation de omega autour de l&#39;axe x pour repasser dans Rlab</span>
    <span class="n">matrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">)],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">)]])</span>
    <span class="c1"># print &quot;matrot \n&quot; , matrot</span>

    <span class="n">labtocr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrot</span><span class="p">,</span> <span class="n">satocrnorm</span><span class="p">)</span>
    <span class="n">astarlab</span> <span class="o">=</span> <span class="n">labtocr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">bstarlab</span> <span class="o">=</span> <span class="n">labtocr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">cstarlab</span> <span class="o">=</span> <span class="n">labtocr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="n">matstarlab1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">astarlab</span><span class="p">,</span> <span class="n">bstarlab</span><span class="p">,</span> <span class="n">cstarlab</span><span class="p">))</span>
    <span class="n">changesign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>

    <span class="n">matstarlab2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">matstarlab1</span><span class="p">,</span> <span class="n">changesign</span><span class="p">)</span>
    <span class="c1"># print &quot;matstarlab from satocr \n&quot;, matstarlab2</span>

    <span class="c1"># mm=matstarlab1</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="n">matstarlab2</span>

    <span class="c1"># matstarlabLaueTools= array([[mm[1],-mm[4],-mm[7]],[mm[0],-mm[6],-mm[3]],[-mm[2],mm[5],mm[8]]])</span>
    <span class="n">matstarlabLaueTools</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">mm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mm</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">mm</span><span class="p">[</span><span class="mi">7</span><span class="p">]],</span>
                                    <span class="p">[</span><span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">6</span><span class="p">]],</span>
                                    <span class="p">[</span><span class="n">mm</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mm</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">mm</span><span class="p">[</span><span class="mi">8</span><span class="p">]]])</span>

    <span class="c1"># resulting matrix contains orientation + strain</span>

    <span class="k">return</span> <span class="n">matstarlabLaueTools</span>


<span class="k">def</span> <span class="nf">matstarlabLaueTools_to_matstarlabOR</span><span class="p">(</span><span class="n">UBmat</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    convert matrix from lauetools frame: ki//x, z towards CCD (top), y = z^x</span>
<span class="sd">                    to ORobach or XMAS&#39;s frame: ki//y, z towards CCD (top), y = z^x</span>

<span class="sd">    convert the so called UBmat to matstarlab</span>
<span class="sd">    (matstarlab stands for &#39;matrix of reciprocal unit cell basis vectors in lab. frame&#39;)</span>

<span class="sd">    see the reciprocal function: matstarlabOR_to_matstarlabLaueTools</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="n">UBmat</span>

    <span class="c1"># print &quot;check matrix before normalizing&quot;</span>
    <span class="c1"># print &quot;normes astar1 bstar1 cstar1 = &quot;, GT.norme_vec(astar1),GT.norme_vec(astar1),GT.norme_vec(astar1)</span>
    <span class="c1"># print &quot;inner products astar1.bstar1, bstar1.cstar1, cstar1.astar1 \n&quot;,\</span>
    <span class="c1">#      inner(astar1,bstar1), inner(bstar1,cstar1), inner(cstar1,astar1)</span>
    <span class="c1"># print &quot;cross products sign(astar1xbstar1).cstar1&quot;, sign(inner(cross(astar1,bstar1),cstar1))</span>

    <span class="c1"># matstarlab = array([-mm[1,0],mm[0,0],mm[2,0],mm[1,1],-mm[0,1],-mm[2,1],mm[1,2],-mm[0,2],-mm[2,2]])</span>
    <span class="n">matstarlab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                            <span class="n">mm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                            <span class="n">mm</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                            <span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">mm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">mm</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                            <span class="n">mm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                            <span class="n">mm</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>

    <span class="n">matstarlab</span> <span class="o">=</span> <span class="n">matstarlab</span> <span class="o">/</span> <span class="n">GT</span><span class="o">.</span><span class="n">norme_vec</span><span class="p">(</span><span class="n">matstarlab</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">matstarlab</span>


<span class="k">def</span> <span class="nf">matstarlabOR_to_matstarlabLaueTools</span><span class="p">(</span><span class="n">matstarlab</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reciprocal function of matstarlabLaueTools_to_matstarlabOR</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="n">matstarlab</span>

    <span class="c1"># print &quot;check matrix before normalizing&quot;</span>
    <span class="c1"># print &quot;normes astar1 bstar1 cstar1 = &quot;, GT.norme_vec(astar1),GT.norme_vec(astar1),GT.norme_vec(astar1)</span>
    <span class="c1"># print &quot;inner products astar1.bstar1, bstar1.cstar1, cstar1.astar1 \n&quot;,\</span>
    <span class="c1">#      inner(astar1,bstar1), inner(bstar1,cstar1), inner(cstar1,astar1)</span>
    <span class="c1"># print &quot;cross products sign(astar1xbstar1).cstar1&quot;, sign(inner(cross(astar1,bstar1),cstar1))</span>

    <span class="n">UBmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">mm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mm</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">mm</span><span class="p">[</span><span class="mi">7</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">-</span><span class="n">mm</span><span class="p">[</span><span class="mi">6</span><span class="p">]],</span> <span class="p">[</span><span class="n">mm</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mm</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">mm</span><span class="p">[</span><span class="mi">8</span><span class="p">]]])</span>

    <span class="k">return</span> <span class="n">UBmat</span>


<span class="k">def</span> <span class="nf">matstarlab_to_matwithlatpar</span><span class="p">(</span><span class="n">matstarlab</span><span class="p">,</span> <span class="n">dlatu_rad</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  OR method to convert UB matrix to matrix with vec recirpocical basis.</span>
<span class="sd">    .. todo:: to put in CrustalParameters or LaueGeometry?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm_vec0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">matstarlab</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">matstarlab</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
    <span class="n">matnorm</span> <span class="o">=</span> <span class="n">matstarlab</span> <span class="o">/</span> <span class="n">norm_vec0</span>
    <span class="n">rlatsr</span> <span class="o">=</span> <span class="n">CP</span><span class="o">.</span><span class="n">matrix_to_rlat</span><span class="p">(</span><span class="n">GT</span><span class="o">.</span><span class="n">matline_to_mat3x3</span><span class="p">(</span><span class="n">matnorm</span><span class="p">),</span> <span class="n">angles_in_deg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dlatsr</span> <span class="o">=</span> <span class="n">CP</span><span class="o">.</span><span class="n">dlat_to_rlat</span><span class="p">(</span><span class="n">rlatsr</span><span class="p">,</span> <span class="n">angles_in_deg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># print &quot;matstarlab = \n&quot;, matstarlab</span>
    <span class="n">dil</span> <span class="o">=</span> <span class="n">CP</span><span class="o">.</span><span class="n">dlat_to_dil</span><span class="p">(</span><span class="n">dlatu_rad</span><span class="p">,</span> <span class="n">dlatsr</span><span class="p">,</span> <span class="n">angles_in_deg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># print &quot;dilatation =&quot;, dil</span>
    <span class="n">rlats1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rlatsr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">dil</span><span class="p">),</span> <span class="n">rlatsr</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]))</span>
    <span class="c1"># print &quot;rlats1 = &quot;, rlats1</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">matnorm</span> <span class="o">*</span> <span class="n">rlats1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># dlats1 = CP.dlat_to_rlat(rlats1, angles_in_deg=0)</span>
    <span class="c1"># print &quot;dlats1 = &quot;, dlats1</span>

    <span class="k">return</span> <span class="n">mat</span>


<span class="k">def</span> <span class="nf">readlt_det</span><span class="p">(</span><span class="n">filedet</span><span class="p">,</span> <span class="n">returnmatLT</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_matLT</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; OR method to read .det file</span>
<span class="sd">    .. todo:: use better IOLauetools method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;reading info from LaueTools det file : </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">filedet</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calibration, orientation matrix&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;convert matrix to matstarlabOR&quot;</span><span class="p">)</span>

    <span class="n">calib</span><span class="p">,</span> <span class="n">mat_line</span> <span class="o">=</span> <span class="n">IOLT</span><span class="o">.</span><span class="n">readfile_det</span><span class="p">(</span><span class="n">filedet</span><span class="p">)</span>

    <span class="n">matLT3x3</span> <span class="o">=</span> <span class="p">(</span><span class="n">GT</span><span class="o">.</span><span class="n">matline_to_mat3x3</span><span class="p">(</span><span class="n">mat_line</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">min_matLT</span><span class="p">:</span>
        <span class="n">matmin</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">FindO</span><span class="o">.</span><span class="n">find_lowest_Euler_Angles_matrix</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">)</span>
        <span class="n">matLT3x3</span> <span class="o">=</span> <span class="n">matmin</span>

    <span class="n">matstarlab</span> <span class="o">=</span> <span class="n">matstarlabLaueTools_to_matstarlabOR</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;matstarlab = </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">matstarlab</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">6</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">returnmatLT</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">calib</span><span class="p">,</span> <span class="n">matstarlab</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">calib</span><span class="p">,</span> <span class="n">matstarlab</span><span class="p">,</span> <span class="n">matLT3x3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">readlt_fit</span><span class="p">(</span><span class="n">filefit</span><span class="p">,</span> <span class="n">returnmatLT</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_matLT</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">readmore</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                                <span class="n">readmore2</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. todo::</span>

<span class="sd">        to put in IOLauetools</span>

<span class="sd">    modif 03Aug12 : genfromtxt removed (problem with skip_footer)</span>
<span class="sd">    add transfo of HKL&#39;s if matmin_LT  == True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;reading info from LaueTools fit file : </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">filefit</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;strained orientation matrix, peak list&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;convert matrix to matstarlabOR&quot;</span><span class="p">)</span>

    <span class="n">matLT3x3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">strain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filefit</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">matrixfound</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">calibfound</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pixdevfound</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">strainfound</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">eulerfound</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">linecalib</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">linepixdev</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">linestrain</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lineeuler</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">list1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">linestartspot</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="n">lineendspot</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># print i</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;spot#&quot;</span><span class="p">:</span>
                <span class="c1"># linecol = line.rstrip(&quot;\n&quot;)</span>
                <span class="n">linestartspot</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#UB&quot;</span><span class="p">:</span>
                <span class="c1"># print line</span>
                <span class="n">matrixfound</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">linestartmat</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">lineendspot</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># print &quot;matrix found&quot;</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#Sa&quot;</span><span class="p">:</span>
                <span class="c1"># print line</span>
                <span class="n">calibfound</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">linecalib</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#pi&quot;</span><span class="p">:</span>
                <span class="c1"># print line</span>
                <span class="n">pixdevfound</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">linepixdev</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#de&quot;</span><span class="p">:</span>
                <span class="c1"># print line</span>
                <span class="n">strainfound</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">linestrain</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#Eu&quot;</span><span class="p">:</span>
                <span class="c1"># print line</span>
                <span class="n">eulerfound</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">lineeuler</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">matrixfound</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">linestartmat</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">linestartmat</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">linestartmat</span> <span class="o">+</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">strline</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">matLT3x3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strline</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">strainfound</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">linestrain</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">linestrain</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">linestrain</span> <span class="o">+</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">strline</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">strain</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strline</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">calibfound</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">linecalib</span><span class="p">):</span>
                <span class="n">calib</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)[:</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="c1"># print &quot;calib = &quot;, calib</span>
            <span class="k">if</span> <span class="n">eulerfound</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">lineeuler</span><span class="p">):</span>
                <span class="n">euler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="c1"># print &quot;euler = &quot;, euler</span>
            <span class="k">if</span> <span class="n">pixdevfound</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">linepixdev</span><span class="p">):</span>
                <span class="n">pixdev</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
                <span class="c1"># print &quot;pixdev = &quot;, pixdev</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">linestartspot</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">lineendspot</span><span class="p">):</span>
                <span class="n">list1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># linetot = i</span>

    <span class="c1"># print &quot;linetot = &quot;, linetot</span>

    <span class="n">data_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data_fit</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_fit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

    <span class="c1"># print &quot;UB matrix = \n&quot;, matLT3x3.round(decimals=6)</span>

    <span class="k">if</span> <span class="n">verbose2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before transfo&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_fit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;q0 = &quot;</span><span class="p">,</span> <span class="n">q0</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">qm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;qm1 = &quot;</span><span class="p">,</span> <span class="n">qm1</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">min_matLT</span><span class="p">:</span>
        <span class="n">matmin</span><span class="p">,</span> <span class="n">transfmat</span> <span class="o">=</span> <span class="n">FindO</span><span class="o">.</span><span class="n">find_lowest_Euler_Angles_matrix</span><span class="p">(</span>
            <span class="n">matLT3x3</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>
        <span class="n">matLT3x3</span> <span class="o">=</span> <span class="n">matmin</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;transfmat </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">transfmat</span><span class="p">))</span>
        <span class="c1"># transformer aussi les HKL pour qu&#39;ils soient coherents avec matmin</span>
        <span class="n">hkl</span> <span class="o">=</span> <span class="n">data_fit</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">data_fit</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transfmat</span><span class="p">,</span> <span class="n">hkl</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after transfo&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_fit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;q0 = &quot;</span><span class="p">,</span> <span class="n">q0</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">qm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;qm1 = &quot;</span><span class="p">,</span> <span class="n">qm1</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>

    <span class="n">matstarlab</span> <span class="o">=</span> <span class="n">matstarlabLaueTools_to_matstarlabOR</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;matstarlab = </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">matstarlab</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">6</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">readmore2</span><span class="p">:</span>
        <span class="n">readmore</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># xx yy zz yz xz xy</span>
    <span class="n">strain6</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">strain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">returnmatLT</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">readmore</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">matstarlab</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">pixdev</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">readmore2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">matstarlab</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">pixdev</span><span class="p">,</span> <span class="n">strain6</span><span class="p">,</span> <span class="n">euler</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">matstarlab</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">readmore</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">matstarlab</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">,</span> <span class="n">matLT3x3</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">pixdev</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">readmore2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">matstarlab</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">,</span> <span class="n">matLT3x3</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">pixdev</span><span class="p">,</span> <span class="n">strain6</span><span class="p">,</span> <span class="n">euler</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">matstarlab</span><span class="p">,</span> <span class="n">data_fit</span><span class="p">,</span> <span class="n">matLT3x3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">readall_str</span><span class="p">(</span><span class="n">grain_index</span><span class="p">,</span> <span class="n">filemane_str</span><span class="p">,</span> <span class="n">returnmatLT</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_matLT</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. todo::</span>

<span class="sd">        to put in IOLauetools</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data_str</span><span class="p">,</span> <span class="n">matstr</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">dev_str</span> <span class="o">=</span> <span class="n">IOLT</span><span class="o">.</span><span class="n">readfile_str</span><span class="p">(</span><span class="n">filemane_str</span><span class="p">,</span> <span class="n">grain_index</span><span class="p">)</span>

    <span class="c1"># postprocessing</span>

    <span class="n">data_str</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">data_str</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>

    <span class="n">satocrs</span> <span class="o">=</span> <span class="n">matstr</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="c1"># print &quot;strained orientation matrix (satocrs) = \n&quot;, satocrs</span>

    <span class="n">matstarlab</span> <span class="o">=</span> <span class="n">matxmas_to_matstarlab</span><span class="p">(</span><span class="n">satocrs</span><span class="p">,</span> <span class="n">calib</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">min_matLT</span><span class="p">:</span>
        <span class="n">matLT3x3</span> <span class="o">=</span> <span class="n">matstarlabOR_to_matstarlabLaueTools</span><span class="p">(</span><span class="n">matstarlab</span><span class="p">)</span>
        <span class="n">matmin</span><span class="p">,</span> <span class="n">transfmat</span> <span class="o">=</span> <span class="n">FindO</span><span class="o">.</span><span class="n">find_lowest_Euler_Angles_matrix</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">)</span>
        <span class="n">matLT3x3</span> <span class="o">=</span> <span class="n">matmin</span>
        <span class="n">matstarlab</span> <span class="o">=</span> <span class="n">matstarlabLaueTools_to_matstarlabOR</span><span class="p">(</span><span class="n">matLT3x3</span><span class="p">)</span>
        <span class="c1"># transfo des HKL a verifier</span>
        <span class="n">hklmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transfmat</span><span class="p">,</span> <span class="n">data_str</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">T</span>
        <span class="n">data_str</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">hklmin</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">returnmatLT</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data_str</span><span class="p">,</span> <span class="n">matstarlab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">dev_str</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data_str</span><span class="p">,</span> <span class="n">matstarlab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">dev_str</span><span class="p">,</span> <span class="n">matLT3x3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">matxmas_to_matstarlab</span><span class="p">(</span><span class="n">satocr</span><span class="p">,</span> <span class="n">calib</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Original function to correctly use matrix from STR or IND</span>

<span class="sd">    # modif 04 Mar 2010 xbet en degres au lieu de radians</span>

<span class="sd">    # satocrs = transposee de la matrice numero 2 du .STR :</span>
<span class="sd">    # &quot;coordinates of a*, b*, c* in X, Y, Z&quot;</span>
<span class="sd">    # satocru = matrice numero 2 du .IND :</span>
<span class="sd">    #  &quot;matrix hkl =&gt; XYZ&quot;</span>
<span class="sd">    #print &quot;convert matrix from XMAS sample axes to lab axes + normalize by astar&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">astar</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">norme_vec</span><span class="p">(</span><span class="n">satocr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="c1"># print &quot;satocr \n&quot;, satocr</span>
    <span class="n">satocrnorm</span> <span class="o">=</span> <span class="n">satocr</span> <span class="o">/</span> <span class="n">astar</span>
    <span class="c1"># print &quot;satocrnorm \n&quot;, satocrnorm</span>

    <span class="n">omega0</span> <span class="o">=</span> <span class="mf">40.0</span>
    <span class="n">xbetrad</span> <span class="o">=</span> <span class="n">calib</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">DEG</span>

    <span class="c1"># print &quot;xbetrad = &quot; , xbetrad</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">omega0</span> <span class="o">*</span> <span class="n">DEG</span> <span class="o">-</span> <span class="n">xbetrad</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="c1"># print &quot;omega&quot; , omega*180.0/np.pi</span>

    <span class="c1"># rotation de omega autour de l&#39;axe x pour repasser dans Rlab</span>
    <span class="n">matrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">)],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">)]])</span>
    <span class="c1"># print &quot;matrot \n&quot; , matrot</span>

    <span class="n">labtocr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrot</span><span class="p">,</span> <span class="n">satocrnorm</span><span class="p">)</span>
    <span class="n">astarlab</span> <span class="o">=</span> <span class="n">labtocr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">bstarlab</span> <span class="o">=</span> <span class="n">labtocr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">cstarlab</span> <span class="o">=</span> <span class="n">labtocr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="n">matstarlab1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">astarlab</span><span class="p">,</span> <span class="n">bstarlab</span><span class="p">,</span> <span class="n">cstarlab</span><span class="p">))</span>
    <span class="n">changesign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>
    <span class="n">matstarlab2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">matstarlab1</span><span class="p">,</span> <span class="n">changesign</span><span class="p">)</span>
    <span class="c1"># print &quot;matstarlab from satocr \n&quot;, matstarlab2</span>
    <span class="k">return</span> <span class="n">matstarlab2</span>


<div class="viewcode-block" id="Compute_data2thetachi"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.Compute_data2thetachi">[docs]</a><span class="k">def</span> <span class="nf">Compute_data2thetachi</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">tuple_column_X_Y_I</span><span class="p">,</span> <span class="n">_nblines_headertoskip</span><span class="p">,</span>
                                                        <span class="n">sorting_intensity</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span><span class="p">,</span>
                                                        <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                        <span class="n">kf_direction</span><span class="o">=</span><span class="s2">&quot;Z&gt;0&quot;</span><span class="p">,</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                        <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>  <span class="c1"># only for peaks coming from fit2d doing an y direction inversion</span>
                                                        <span class="n">saturation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">forceextension_lines_to_extract</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                        <span class="n">col_isbadspot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                        <span class="n">alpha_xray_incidence_correction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts spot positions x,y to scattering angles 2theta, chi from a list of peaks</span>

<span class="sd">    :param filename: fullpath to peaks list ASCII file</span>
<span class="sd">    :type filename: string</span>

<span class="sd">    :param tuple_column_X_Y_I: tuple with column indices of spots X, Y (pixels on CCD) and intensity</span>
<span class="sd">    :type tuple_column_X_Y_I: 3 elements</span>

<span class="sd">    :param _nblines_headertoskip: nb of line to skip before reading an array of data in ascii file</span>

<span class="sd">    :param param: list of CCD calibration parameters [det, xcen, ycen, xbet, xgam]</span>
<span class="sd">    :param pixelsize: pixelsize in mm</span>
<span class="sd">    :param dim: (nb pixels x, nb pixels y)</span>

<span class="sd">    :param kf_direction: label of detection geometry (CCD position): &#39;Z&gt;0&#39;,&#39;X&gt;0&#39;,...</span>
<span class="sd">    :type kf_direction: string</span>


<span class="sd">    :param sorting_intensity: &#39;yes&#39; sort spots list by decreasing intensity</span>


<span class="sd">    saturation = 0 : do not read Ipixmax column of DAT file from LaueTools peaksearch</span>
<span class="sd">    saturation &gt; 0 : read Ipixmax column and create data_sat list</span>
<span class="sd">    data_sat[i] = 1 if Ipixmax[i]&gt; saturation, =0 otherwise</span>

<span class="sd">    Note: _nblines_headertoskip =0 for .pik file (no header at all)</span>
<span class="sd">            _nblines_headertoskip =1 for .peaks coming from fit2d</span>

<span class="sd">    col_Ipixmax = 10 for .dat from LT peak search using method &quot;Local Maxima&quot;</span>
<span class="sd">    (TODO : bug in Ipixmax for method &quot;convolve&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col_X</span><span class="p">,</span> <span class="n">col_Y</span><span class="p">,</span> <span class="n">col_I</span> <span class="o">=</span> <span class="n">tuple_column_X_Y_I</span>

    <span class="n">extension</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">forceextension_lines_to_extract</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="s2">&quot;forcedextension&quot;</span>

    <span class="k">if</span> <span class="n">extension</span> <span class="o">==</span> <span class="s2">&quot;pik&quot;</span><span class="p">:</span>  <span class="c1"># no header</span>
        <span class="n">nbline</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">data_xyI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="n">col_X</span><span class="p">,</span> <span class="n">col_Y</span><span class="p">,</span> <span class="n">col_I</span><span class="p">),</span> <span class="n">skiprows</span><span class="o">=</span><span class="n">nbline</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">extension</span> <span class="o">==</span> <span class="s2">&quot;peaks&quot;</span><span class="p">:</span>  <span class="c1"># single line header</span>
        <span class="n">data_xyI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="n">col_X</span><span class="p">,</span> <span class="n">col_Y</span><span class="p">,</span> <span class="n">col_I</span><span class="p">),</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">extension</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dat&quot;</span><span class="p">,</span> <span class="s2">&quot;DAT&quot;</span><span class="p">):</span>  <span class="c1"># peak list single line header</span>
        <span class="n">data_xyI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="n">col_X</span><span class="p">,</span> <span class="n">col_Y</span><span class="p">,</span> <span class="n">col_I</span><span class="p">),</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nb of spots and columns in .dat file&quot;</span><span class="p">,</span> <span class="n">data_xyI</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">saturation</span><span class="p">:</span>
            <span class="n">data_Ipixmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># print &quot;Ipixmax &quot;,data_Ipixmax</span>
            <span class="n">indsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_Ipixmax</span> <span class="o">&gt;=</span> <span class="n">saturation</span><span class="p">)</span>
            <span class="c1"># print indsat</span>
            <span class="n">data_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_Ipixmax</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">data_sat</span><span class="p">[</span><span class="n">indsat</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># print data_sat</span>

            <span class="k">if</span> <span class="n">col_isbadspot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data_isbadspot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="n">col_isbadspot</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">data_isbadspot</span><span class="p">)</span>

        <span class="c1"># mike.close()</span>

    <span class="k">elif</span> <span class="n">extension</span> <span class="o">==</span> <span class="s2">&quot;forcedextension&quot;</span><span class="p">:</span>
        <span class="c1"># mike=scipy.io.array_import.get_open_file(filename)</span>
        <span class="c1"># mike.readline()</span>
        <span class="c1"># data_xyI=scipy.io.array_import.read_array(filename,columns=(col_X,col_Y,col_I),lines=forceextension_lines_to_extract)</span>
        <span class="n">data_xyI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="n">col_X</span><span class="p">,</span> <span class="n">col_Y</span><span class="p">,</span> <span class="n">col_I</span><span class="p">),</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># mike.close()</span>
    <span class="k">elif</span> <span class="n">extension</span> <span class="o">==</span> <span class="s2">&quot;cor&quot;</span><span class="p">:</span>  <span class="c1"># single line header</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data_xyI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does contain just one header line&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown file extension for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">sha</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># manage if there is a single spot</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nb_peaks</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nb_peaks</span> <span class="o">=</span> <span class="n">sha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing param arg in Compute_data2thetachi() of find2thetachi module&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">param_det</span> <span class="o">=</span> <span class="n">param</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;file :</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;containing </span><span class="si">%d</span><span class="s2"> peaks&quot;</span> <span class="o">%</span> <span class="n">nb_peaks</span><span class="p">)</span>
        <span class="c1"># print data_xyI</span>

    <span class="c1"># default</span>
    <span class="c1"># data_x=data_xyI[:,0]</span>
    <span class="c1"># data_y=data_xyI[:,1]</span>
    <span class="c1"># data_I=data_xyI[:,2]</span>

    <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;pik&quot;</span><span class="p">,</span> <span class="s2">&quot;peaks&quot;</span><span class="p">):</span>
        <span class="n">data_x</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># + 0.5  # 0.5 for being closer to XMAS peaks position</span>
        <span class="n">data_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># + 0.5 # 0.5 for being closer to XMAS peaks position</span>
        <span class="n">data_I</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># for fit2d pixels convention</span>

    <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dat&quot;</span><span class="p">,</span> <span class="s2">&quot;DAT&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nb_peaks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data_x</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">data_y</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">data_I</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">nb_peaks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_xyI</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_xyI</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">data_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_xyI</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data_xyI</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">data_I</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_xyI</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">data_xyI</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">extension</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;forcedextension&quot;</span><span class="p">,</span> <span class="s2">&quot;cor&quot;</span><span class="p">):</span>
        <span class="n">data_x</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">data_y</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">data_I</span> <span class="o">=</span> <span class="n">data_xyI</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="c1"># 21Jul14  O. Robach---------------</span>
    <span class="k">if</span> <span class="n">alpha_xray_incidence_correction</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using alpha_xray_incidence_correction = &quot;</span><span class="p">,</span> <span class="n">alpha_xray_incidence_correction</span><span class="p">)</span>
        <span class="n">xystart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span><span class="p">))</span>
        <span class="c1">#        print &quot;xystart = &quot;, xystart</span>
        <span class="n">npics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xystart</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npics</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">xycen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">param_det</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">param_det</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="c1">#        print &quot;xycen = &quot;, xycen</span>
        <span class="n">dxy</span> <span class="o">=</span> <span class="n">xystart</span> <span class="o">-</span> <span class="n">xycen</span>
        <span class="n">dxynorm2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">dxy</span><span class="p">,</span> <span class="n">dxy</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#        print &quot;dxynorm2 = &quot;, dxynorm2</span>
        <span class="n">dxynorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">dxynorm2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="c1">#        print &quot;dxynorm =&quot;, dxynorm</span>
        <span class="c1"># dxynorminv = 1.0 / dxynorm</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">pixelsize</span> <span class="o">/</span> <span class="n">param_det</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">scale_factor</span>
        <span class="c1">#        print &quot;dd = &quot;, param_det[0]</span>
        <span class="c1">#        print &quot;pixelsize = &quot;, pixelsize</span>
        <span class="c1">#        print &quot;scale_factor = &quot;, scale_factor</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">npics</span><span class="p">)):</span>
            <span class="n">xynew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xystart</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                                <span class="o">+</span> <span class="n">alpha_xray_incidence_correction</span>
                                <span class="o">*</span> <span class="n">scale_factor</span>
                                <span class="o">*</span> <span class="n">dxy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                                <span class="o">*</span> <span class="n">dxynorm</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">delta_xy</span> <span class="o">=</span> <span class="n">xynew</span> <span class="o">-</span> <span class="n">xystart</span>
        <span class="c1">#        print &quot;delta_xy = &quot;, delta_xy</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;maximum spot displacement |dx| |dy| : &quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">delta_xy</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>

        <span class="n">data_x</span> <span class="o">=</span> <span class="n">xynew</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">data_y</span> <span class="o">=</span> <span class="n">xynew</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1"># ----compute scattering angles2theta and chi --------------------------</span>
    <span class="n">twicethetaraw</span><span class="p">,</span> <span class="n">chiraw</span> <span class="o">=</span> <span class="n">calc_uflab</span><span class="p">(</span><span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span><span class="p">,</span> <span class="n">param_det</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="n">returnAngles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                                        <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                                                        <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">)</span>
    <span class="c1">#-----------------------------------------------------------------------</span>
    <span class="c1"># print chi,twicetheta</span>
    <span class="k">if</span> <span class="n">nb_peaks</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sorting_intensity</span> <span class="o">==</span> <span class="s2">&quot;yes&quot;</span><span class="p">:</span>
        <span class="n">listsorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data_I</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">chiraw</span><span class="p">,</span> <span class="n">listsorted</span><span class="p">)</span>
        <span class="n">twicetheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">twicethetaraw</span><span class="p">,</span> <span class="n">listsorted</span><span class="p">)</span>
        <span class="n">data_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data_x</span><span class="p">,</span> <span class="n">listsorted</span><span class="p">)</span>
        <span class="n">data_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data_y</span><span class="p">,</span> <span class="n">listsorted</span><span class="p">)</span>
        <span class="n">dataintensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data_I</span><span class="p">,</span> <span class="n">listsorted</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">saturation</span><span class="p">:</span>
            <span class="n">data_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data_sat</span><span class="p">,</span> <span class="n">listsorted</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col_isbadspot</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_isbadspot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data_isbadspot</span><span class="p">,</span> <span class="n">listsorted</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">dataintensity</span> <span class="o">=</span> <span class="n">data_I</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="n">chiraw</span>
        <span class="n">twicetheta</span> <span class="o">=</span> <span class="n">twicethetaraw</span>

    <span class="k">if</span> <span class="n">nb_peaks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dataintensity</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataintensity</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="p">[</span><span class="n">chi</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">twicetheta</span> <span class="o">=</span> <span class="p">[</span><span class="n">twicetheta</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">data_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">data_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">saturation</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;adding flag column for saturated peaks&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">dataintensity</span><span class="p">,</span> <span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span><span class="p">,</span> <span class="n">data_sat</span>
    <span class="k">if</span> <span class="n">col_isbadspot</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">dataintensity</span><span class="p">,</span> <span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span><span class="p">,</span> <span class="n">data_sat</span><span class="p">,</span> <span class="n">data_isbadspot</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">col_isbadspot</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">dataintensity</span><span class="p">,</span> <span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span><span class="p">,</span> <span class="n">data_isbadspot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">dataintensity</span><span class="p">,</span> <span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span></div>


<div class="viewcode-block" id="convert2corfile"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.convert2corfile">[docs]</a><span class="k">def</span> <span class="nf">convert2corfile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">calibparam</span><span class="p">,</span> <span class="n">dirname_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dirname_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                                <span class="n">CCDCalibdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                                                <span class="n">add_props</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert .dat (peaks list from peaksearch procedure) to .cor (adding scattering angles 2theta chi)</span>

<span class="sd">    From X,Y pixel positions in peak list file (x,y,I,...) and detector plane geometry comptues scattering angles 2theta chi</span>
<span class="sd">    and creates a .cor file (ascii peaks list (2theta chi X Y int ...))</span>

<span class="sd">    :param calibparam: list of 5 CCD cakibration parameters (used if CCDCalibdict is None or  CCDCalibdict[&#39;CCDCalibPameters&#39;] is missing)</span>

<span class="sd">    :param pixelsize: CCD pixelsize (in mm) (used if CCDCalibdict is None or CCDCalibdict[&#39;pixelsize&#39;] is missing)</span>

<span class="sd">    :param CCDCalibdict: dictionary of CCD file and calibration parameters</span>

<span class="sd">    :param add_props: add all peaks properties to .cor file instead of the 5 columns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dirname_in</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filename_in</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname_in</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filename_in</span> <span class="o">=</span> <span class="n">filename</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;CCDCalibdict in convert2corfile of </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">filename</span><span class="p">,</span> <span class="n">CCDCalibdict</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">CCDCalibdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;CCDCalibParameters&quot;</span> <span class="ow">in</span> <span class="n">CCDCalibdict</span><span class="p">:</span>
            <span class="n">calibparam</span> <span class="o">=</span> <span class="n">CCDCalibdict</span><span class="p">[</span><span class="s2">&quot;CCDCalibParameters&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;xpixelsize&quot;</span> <span class="ow">in</span> <span class="n">CCDCalibdict</span><span class="p">:</span>
            <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">CCDCalibdict</span><span class="p">[</span><span class="s2">&quot;xpixelsize&quot;</span><span class="p">]</span>

    <span class="p">(</span><span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">dataintensity</span><span class="p">,</span> <span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span><span class="p">)</span> <span class="o">=</span> <span class="n">Compute_data2thetachi</span><span class="p">(</span><span class="n">filename_in</span><span class="p">,</span>
                                                                            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                                                                            <span class="mi">1</span><span class="p">,</span>
                                                                            <span class="n">sorting_intensity</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span><span class="p">,</span>
                                                                            <span class="n">param</span><span class="o">=</span><span class="n">calibparam</span><span class="p">,</span>
                                                                            <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">add_props</span><span class="p">:</span>
        <span class="n">rawdata</span><span class="p">,</span> <span class="n">allcolnames</span> <span class="o">=</span> <span class="n">IOLT</span><span class="o">.</span><span class="n">read_Peaklist</span><span class="p">(</span><span class="n">filename_in</span><span class="p">,</span> <span class="n">output_columnsname</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># need to sort data by intensity (col 2)</span>
        <span class="n">sortedind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">rawdata</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])[::</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">rawdata</span><span class="p">[</span><span class="n">sortedind</span><span class="p">]</span>

        <span class="n">add_props</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">:],</span> <span class="n">allcolnames</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span>

    <span class="c1"># TODO: handle windowsOS path syntax</span>
    <span class="n">filename_wo_path</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">file_extension</span> <span class="o">=</span> <span class="n">filename_wo_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">prefix_outputname</span> <span class="o">=</span> <span class="n">filename_wo_path</span><span class="p">[:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">file_extension</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">dirname_out</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filename_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname_out</span><span class="p">,</span> <span class="n">prefix_outputname</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filename_out</span> <span class="o">=</span> <span class="n">prefix_outputname</span>

    <span class="k">if</span> <span class="n">CCDCalibdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">DictLT</span><span class="o">.</span><span class="n">CCD_CALIBRATION_PARAMETERS</span><span class="p">[:</span><span class="mi">5</span><span class="p">]):</span>
            <span class="n">CCDCalibdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">calibparam</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>

        <span class="n">CCDCalibdict</span><span class="p">[</span><span class="s2">&quot;xpixelsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixelsize</span>
        <span class="n">CCDCalibdict</span><span class="p">[</span><span class="s2">&quot;ypixelsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixelsize</span>
        <span class="n">CCDCalibdict</span><span class="p">[</span><span class="s2">&quot;pixelsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixelsize</span>

        <span class="n">param</span> <span class="o">=</span> <span class="n">CCDCalibdict</span>

        <span class="c1"># update dict according to values in file .cor</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_in</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">IOLT</span><span class="o">.</span><span class="n">readCalibParametersInFile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Dict_to_update</span><span class="o">=</span><span class="n">CCDCalibdict</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">calibparam</span> <span class="o">+</span> <span class="p">[</span><span class="n">pixelsize</span><span class="p">]</span>

    <span class="c1"># print(&#39;add_props&#39;, data.shape, add_props)</span>

    <span class="n">IOLT</span><span class="o">.</span><span class="n">writefile_cor</span><span class="p">(</span><span class="n">filename_out</span><span class="p">,</span> <span class="n">twicetheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span><span class="p">,</span> <span class="n">dataintensity</span><span class="p">,</span>
                                                            <span class="n">data_props</span><span class="o">=</span><span class="n">add_props</span><span class="p">,</span>
                                                            <span class="n">sortedexit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                            <span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">,</span>
                                                            <span class="n">initialfilename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert2corfile_fileseries"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.convert2corfile_fileseries">[docs]</a><span class="k">def</span> <span class="nf">convert2corfile_fileseries</span><span class="p">(</span><span class="n">fileindexrange</span><span class="p">,</span> <span class="n">filenameprefix</span><span class="p">,</span> <span class="n">calibparam</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                                                            <span class="n">nbdigits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                                                            <span class="n">dirname_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                                            <span class="n">dirname_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                                            <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                            <span class="n">fliprot</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    convert a serie of peaks list ascii files to .cor files (adding scattering angles).</span>

<span class="sd">    Filename is decomposed as following for incrementing file index in ####:</span>
<span class="sd">    prefix####suffix</span>
<span class="sd">    example: myimage_0025.myccd =&gt; prefix=myimage_ nbdigits=4 suffix=.myccd</span>

<span class="sd">    :param nbdigits: nb of digits of file index in filename (with zero padding)</span>
<span class="sd">        (example: for myimage_0002.ccd nbdigits = 4</span>

<span class="sd">    :param calibparam: list of 5 CCD cakibration parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">encodingdigits</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%%</span><span class="s2">0</span><span class="si">%d</span><span class="s2">d&quot;</span> <span class="o">%</span> <span class="n">nbdigits</span>

    <span class="k">if</span> <span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;.dat&quot;</span>

    <span class="k">for</span> <span class="n">fileindex</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">fileindexrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fileindexrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="n">filename_in</span> <span class="o">=</span> <span class="n">filenameprefix</span> <span class="o">+</span> <span class="n">encodingdigits</span> <span class="o">%</span> <span class="n">fileindex</span> <span class="o">+</span> <span class="n">suffix</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;filename_in&quot;</span><span class="p">,</span> <span class="n">filename_in</span><span class="p">)</span>
        <span class="n">convert2corfile</span><span class="p">(</span><span class="n">filename_in</span><span class="p">,</span>
                        <span class="n">calibparam</span><span class="p">,</span>
                        <span class="n">dirname_in</span><span class="o">=</span><span class="n">dirname_in</span><span class="p">,</span>
                        <span class="n">dirname_out</span><span class="o">=</span><span class="n">dirname_out</span><span class="p">,</span>
                        <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert2corfile_multiprocessing"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.convert2corfile_multiprocessing">[docs]</a><span class="k">def</span> <span class="nf">convert2corfile_multiprocessing</span><span class="p">(</span><span class="n">fileindexrange</span><span class="p">,</span>
                                    <span class="n">filenameprefix</span><span class="p">,</span>
                                    <span class="n">calibparam</span><span class="p">,</span>
                                    <span class="n">dirname_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                    <span class="n">nbdigits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                    <span class="n">dirname_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                    <span class="n">fliprot</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="p">,</span>
                                    <span class="n">nb_of_cpu</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    launch several processes in parallel to convert .dat file to .cor file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">index_start</span><span class="p">,</span> <span class="n">index_final</span> <span class="o">=</span> <span class="n">fileindexrange</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need 2 file indices integers in fileindexrange=(indexstart, indexfinal)&quot;</span><span class="p">)</span>

    <span class="n">fileindexdivision</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">getlist_fileindexrange_multiprocessing</span><span class="p">(</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_final</span><span class="p">,</span> <span class="n">nb_of_cpu</span><span class="p">)</span>

    <span class="c1">#    t00 = time.time()</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nb_of_cpu</span><span class="p">)):</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">convert2corfile_fileseries</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">fileindexdivision</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">filenameprefix</span><span class="p">,</span>
                <span class="n">calibparam</span><span class="p">,</span>
                <span class="n">suffix</span><span class="p">,</span>
                <span class="n">nbdigits</span><span class="p">,</span>
                <span class="n">dirname_in</span><span class="p">,</span>
                <span class="n">dirname_out</span><span class="p">,</span>
                <span class="n">pixelsize</span><span class="p">))</span>
        <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
        <span class="n">proc</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>


<span class="c1">#    t_mp = time.time() - t00</span>
<span class="c1">#    print &quot;Execution time : %.2f&quot; % t_mp</span>


<span class="k">def</span> <span class="nf">fromlab_tosample</span><span class="p">(</span><span class="n">UB</span><span class="p">,</span> <span class="n">anglesample_deg</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>  <span class="c1"># in deg</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute UBs</span>

<span class="sd">    qs = UBs G   with G =ha*+kb*+lc* a*,b*,c* are aligned with lab frame x,y,z</span>
<span class="sd">    qs is q in sample frame deduced from lab by a 40* rotation around y (lauetools convention)</span>

<span class="sd">    lauetools convention: x // ki ie. ki = 2pi/lambda(1,0,0), z perpendicular to x and contained</span>
<span class="sd">    in the plane defined by x and dd* u where u is a unit vector normal to the CCD plane</span>
<span class="sd">    and dd is the shortest distance between the CCD plane and the emission source of scattered beams</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">anglesample</span> <span class="o">=</span> <span class="n">anglesample_deg</span> <span class="o">*</span> <span class="n">DEG</span>  <span class="c1"># in rad</span>
    <span class="n">Rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">anglesample</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">anglesample</span><span class="p">)],</span>
                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                            <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">anglesample</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">anglesample</span><span class="p">)]])</span>

    <span class="c1"># = GT.matRot([0,1,0], 40)</span>
    <span class="c1"># invRot = np.linalg.inv(Rot)</span>
    <span class="n">UBs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rot</span><span class="p">,</span> <span class="n">UB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">UBs</span>


<div class="viewcode-block" id="vec_normalTosurface"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.vec_normalTosurface">[docs]</a><span class="k">def</span> <span class="nf">vec_normalTosurface</span><span class="p">(</span><span class="n">mat_labframe</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    solve Mat * X = (0,0,1) for X</span>
<span class="sd">    for pure rotation invMat = transpose(Mat)</span>

<span class="sd">    TODO: add option sample angle and axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># last row of matrix in sample frame</span>
    <span class="k">return</span> <span class="n">fromlab_tosample</span><span class="p">(</span><span class="n">mat_labframe</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span></div>


<div class="viewcode-block" id="vec_onsurface_alongys"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.vec_onsurface_alongys">[docs]</a><span class="k">def</span> <span class="nf">vec_onsurface_alongys</span><span class="p">(</span><span class="n">mat_labframe</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    solve Mat * X = (0,1,0) for X</span>
<span class="sd">    for pure rotation invMat = transpose(Mat)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fromlab_tosample</span><span class="p">(</span><span class="n">mat_labframe</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>


<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># ---------------------------WIRE TECHNIQUE ---------------------------------</span>
<span class="c1"># ---------------------------------------------------------------------------</span>


<span class="c1"># Following functions are for dealing with in depth  x-ray emission source</span>

<span class="k">def</span> <span class="nf">find_yzsource_from_IM_uf</span><span class="p">(</span><span class="n">IM</span><span class="p">,</span> <span class="n">uf</span><span class="p">,</span> <span class="n">depth_z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from vector IM in absolute frame  I origin, M point in CCD plane</span>
<span class="sd">    uf: unit vector in absolute frame joining Iprime (source) and M</span>
<span class="sd">    depth_z: in microns known vertical offset</span>

<span class="sd">    returns x and y position of emission source</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uz</span> <span class="o">=</span> <span class="n">uf</span><span class="o">.</span><span class="n">T</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">IM</span><span class="o">.</span><span class="n">T</span>

    <span class="n">deltaZ</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">depth_z</span> <span class="o">*</span> <span class="mf">1000.0</span>  <span class="c1"># in millimeters</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">deltaZ</span> <span class="o">/</span> <span class="n">uz</span>

    <span class="n">xsource</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">ux</span>
    <span class="n">ysource</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">uy</span>
    <span class="n">zsource</span> <span class="o">=</span> <span class="n">depth_z</span>

    <span class="c1"># rotation matrix from absolute to sample frame</span>
    <span class="c1"># Xs= R Xabs</span>
    <span class="n">anglerad</span> <span class="o">=</span> <span class="n">anglesample</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">anglerad</span><span class="p">)</span>
    <span class="n">sa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">anglerad</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">sa</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">sa</span><span class="p">,</span> <span class="n">ca</span><span class="p">]])</span>
    <span class="c1"># source position in sample frame</span>
    <span class="n">tsource</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xsource</span><span class="p">,</span> <span class="n">ysource</span><span class="p">,</span> <span class="n">zsource</span><span class="p">)</span>
    <span class="n">xsource_s</span><span class="p">,</span> <span class="n">ysource_s</span><span class="p">,</span> <span class="n">zsource_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">tsource</span><span class="p">)</span>

    <span class="n">IIprime</span> <span class="o">=</span> <span class="n">tsource</span><span class="o">.</span><span class="n">T</span>
    <span class="n">IIprime_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xsource_s</span><span class="p">,</span> <span class="n">ysource_s</span><span class="p">,</span> <span class="n">zsource_s</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">IIprime</span><span class="p">,</span> <span class="n">IIprime_s</span>


<span class="k">def</span> <span class="nf">IMlab_from_xycam</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns list of vector position of M (on CCD camera) in absolute frame</span>
<span class="sd">    from pixels position vector in CCD frame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">IMlab</span> <span class="o">=</span> <span class="n">calc_uflab</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">returnAngles</span><span class="o">=</span><span class="s2">&quot;uflab&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IMlab&quot;</span><span class="p">,</span> <span class="n">IMlab</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">IMlab</span>


<span class="k">def</span> <span class="nf">IW_from_IM_onesource</span><span class="p">(</span><span class="n">IIprime</span><span class="p">,</span> <span class="n">IM</span><span class="p">,</span> <span class="n">depth_wire</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span> <span class="n">anglewire</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from:</span>
<span class="sd">    II&#39;: single vector II&#39; (2 elements= y,z) source position in absolute frame</span>
<span class="sd">    IM: array of vectors IM (3 elements= x,y,z) point on CCD in absolute frame</span>
<span class="sd">    depth_wire: height normal to the surface of the wire</span>
<span class="sd">    I origin of absolute frame and calibrated source emission</span>

<span class="sd">    returns:</span>
<span class="sd">    array of vectors wire position (y,z)  (hypothesis: wire parallel to Ox)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">yIp</span><span class="p">,</span> <span class="n">zIp</span> <span class="o">=</span> <span class="n">IIprime</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Next time, please use a 2elements source position (y,z)&quot;</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">yIp</span><span class="p">,</span> <span class="n">zIp</span> <span class="o">=</span> <span class="n">IIprime</span>

    <span class="n">angs</span> <span class="o">=</span> <span class="n">anglesample</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">angw</span> <span class="o">=</span> <span class="n">anglewire</span> <span class="o">*</span> <span class="n">DEG</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">IM</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">IH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">depth_wire</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angs</span><span class="p">),</span> <span class="n">depth_wire</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angs</span><span class="p">)])</span>

    <span class="n">slopeM</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">zIp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yIp</span><span class="p">)</span>
    <span class="n">slopefil</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">angw</span><span class="p">)</span>

    <span class="n">cstM</span> <span class="o">=</span> <span class="n">slopeM</span> <span class="o">*</span> <span class="n">yIp</span> <span class="o">+</span> <span class="n">zIp</span>
    <span class="n">cstH</span> <span class="o">=</span> <span class="n">slopefil</span> <span class="o">*</span> <span class="n">IH</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">IH</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">yw</span> <span class="o">=</span> <span class="p">(</span><span class="n">cstM</span> <span class="o">-</span> <span class="n">cstH</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">slopeM</span> <span class="o">-</span> <span class="n">slopefil</span><span class="p">)</span>
    <span class="n">zw</span> <span class="o">=</span> <span class="n">cstH</span> <span class="o">-</span> <span class="n">slopefil</span> <span class="o">*</span> <span class="n">yw</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">yw</span><span class="p">,</span> <span class="n">zw</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">IW_from_source_oneIM</span><span class="p">(</span><span class="n">IIprime</span><span class="p">,</span> <span class="n">IM</span><span class="p">,</span> <span class="n">depth_wire</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO : MAY BE FALSE</span>
<span class="sd">    from:</span>
<span class="sd">    II&#39;: array of  vectors II&#39; (2 elements= y,z) source position in absolute frame</span>
<span class="sd">    IM: SINGLE vector IM (3 elements= x,y,z) point on CCD in absolute frame</span>
<span class="sd">    depth_wire: height normal to the surface of the wire</span>
<span class="sd">    I origin of absolute frame and calibrated source emission</span>

<span class="sd">    returns:</span>
<span class="sd">    array of vectors wire position (y,z)  (hypothesis: wire parallel to Ox)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">yIp</span><span class="p">,</span> <span class="n">zIp</span> <span class="o">=</span> <span class="p">(</span><span class="n">IIprime</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">IM</span>

    <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">zIp</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">yIp</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">ang</span> <span class="o">=</span> <span class="n">anglesample</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">tw0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>

    <span class="n">yw</span> <span class="o">=</span> <span class="p">(</span><span class="n">yIp</span> <span class="o">*</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">zIp</span> <span class="o">+</span> <span class="n">depth_wire</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">slope</span> <span class="o">-</span> <span class="n">tw0</span><span class="p">)</span>
    <span class="n">zw</span> <span class="o">=</span> <span class="n">tw0</span> <span class="o">*</span> <span class="n">yw</span> <span class="o">+</span> <span class="n">depth_wire</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">yw</span><span class="p">,</span> <span class="n">zw</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">find_yzsource_from_xycam_uf</span><span class="p">(</span><span class="n">OM</span><span class="p">,</span> <span class="n">uf</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">depth_z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from:</span>
<span class="sd">    OM: list of vectors OM (2 elements) in CCD plane in CCD frame (pixels unit)</span>
<span class="sd">    uf: list of unit vectors (3 elements) in absolute frame</span>
<span class="sd">    depth_z:  known vertical offset of the beam with respect in microns</span>
<span class="sd">                default value = 0 (source is along the line passing through I origin for CCD calibration)</span>


<span class="sd">    returns:</span>
<span class="sd">    list of position [y,z] of emission source in absolute frame</span>
<span class="sd">    list of position [y,z] of emission source in sample frame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span> <span class="o">=</span> <span class="n">OM</span><span class="o">.</span><span class="n">T</span>

    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">IMlab_from_xycam</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">calib</span><span class="p">)</span>

    <span class="n">IMlab_yz</span> <span class="o">=</span> <span class="n">IMlab</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">find_yzsource_from_IM_uf</span><span class="p">(</span><span class="n">IMlab_yz</span><span class="p">,</span> <span class="n">uf</span><span class="p">,</span> <span class="n">depth_z</span><span class="o">=</span><span class="n">depth_z</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="n">anglesample</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_yzsource_from_2xycam_2yzwire</span><span class="p">(</span><span class="n">OMs</span><span class="p">,</span> <span class="n">IWs</span><span class="p">,</span> <span class="n">calib</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    rfrom:</span>
<span class="sd">    OMs: array of 2 vectors OM (2 elements) in CCD plane in CCD frame (pixels unit): array([OM1,OM2])</span>
<span class="sd">    IWs: array of 2 position vectors (2 elements= [y,z]) in absolute frame of wire (which is parallel to Ox): array([IW1,IW2]</span>

<span class="sd">    returns:</span>
<span class="sd">    y,z position of source of emission (hypothesis x=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span> <span class="o">=</span> <span class="n">OMs</span><span class="o">.</span><span class="n">T</span>

    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">IMlab_from_xycam</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">calib</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">Y_IM</span><span class="p">,</span> <span class="n">Z_IM</span> <span class="o">=</span> <span class="n">IMlab</span><span class="o">.</span><span class="n">T</span>
    <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">Y_IM</span>
    <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">Z_IM</span>

    <span class="n">YW</span><span class="p">,</span> <span class="n">ZW</span> <span class="o">=</span> <span class="n">IWs</span><span class="o">.</span><span class="n">T</span>
    <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">YW</span>
    <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">ZW</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">u1</span> <span class="o">-</span> <span class="n">y1</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">z1</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">u2</span> <span class="o">-</span> <span class="n">y2</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">z2</span>

    <span class="n">E</span> <span class="o">=</span> <span class="o">-</span><span class="n">y1</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">A</span>
    <span class="n">F</span> <span class="o">=</span> <span class="o">-</span><span class="n">y2</span> <span class="o">*</span> <span class="n">D</span> <span class="o">+</span> <span class="n">z2</span> <span class="o">*</span> <span class="n">C</span>

    <span class="n">determ</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">D</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">C</span>

    <span class="n">ysource</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">E</span> <span class="o">-</span> <span class="n">A</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span> <span class="o">/</span> <span class="n">determ</span>
    <span class="n">zsource</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span> <span class="o">*</span> <span class="n">E</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span> <span class="o">/</span> <span class="n">determ</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ysource</span><span class="p">,</span> <span class="n">zsource</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">find_yzsource_from_2xycam_2yzwire_version2</span><span class="p">(</span><span class="n">OMs</span><span class="p">,</span> <span class="n">IWs</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from:</span>
<span class="sd">    OMs: array of 2 vectors OM (2 elements) in CCD plane in CCD frame (pixels unit): array([OM1,OM2])</span>
<span class="sd">    IWs: array of 2 position vectors (2 elements= [y,z]) in absolute frame of wire (which is parallel to Ox): array([IW1,IW2]</span>

<span class="sd">    assumption: xsource = 0</span>

<span class="sd">    returns:</span>
<span class="sd">    position of source of emission</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span> <span class="o">=</span> <span class="n">OMs</span><span class="o">.</span><span class="n">T</span>

    <span class="n">IMlab</span> <span class="o">=</span> <span class="n">IMlab_from_xycam</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">calib</span><span class="p">)</span>

    <span class="n">IM_1</span><span class="p">,</span> <span class="n">IM_2</span> <span class="o">=</span> <span class="n">IMlab</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>  <span class="c1"># y,z of IMs</span>

    <span class="n">IW_1</span><span class="p">,</span> <span class="n">IW_2</span> <span class="o">=</span> <span class="n">IWs</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># y,z of IW</span>

    <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">ShortestLine</span><span class="p">(</span><span class="n">IM_1</span><span class="p">,</span> <span class="n">IW_1</span><span class="p">,</span> <span class="n">IM_2</span><span class="p">,</span> <span class="n">IW_2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;line1 points&quot;</span><span class="p">,</span> <span class="n">IM_1</span><span class="p">,</span> <span class="n">IW_1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;line2 points&quot;</span><span class="p">,</span> <span class="n">IM_2</span><span class="p">,</span> <span class="n">IW_2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;two points&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;distance &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">,</span> <span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">)))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>


<span class="k">def</span> <span class="nf">find_multiplesourcesyz_from_multiplexycam_multipleyzwire</span><span class="p">(</span><span class="n">OMs</span><span class="p">,</span> <span class="n">Wire_abscissae</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span>
                                                                                <span class="n">anglesample</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span>
                                                                                <span class="n">wire_height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                                                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from:</span>
<span class="sd">    OMs: array of n vectors OM (2 elements) in CCD plane in CCD frame (pixels unit): array([OM1,OM2, ..., OMn])</span>
<span class="sd">    IWs: array of n wire abscissae of wire (which is parallel to Ox): array([W1,W2,...,Wn]</span>
<span class="sd">    Wire (strictly parallel to x) travels strictly at anglesample from horizontal plane (defined by ui,xbet and CCD plane in calibration). Wire abscissa is zero when wire is on top of point I of calibration at height wire_height. Wire abscissa increases in same direction as y (and Xray beam).</span>

<span class="sd">    assumption: 1) xsource = 0</span>
<span class="sd">                2) sources lying in yOz plane may only differ from incident direction in this plane</span>

<span class="sd">    returns:</span>
<span class="sd">    all positions of source of emission from all pairs [spot,Wire_abscissa]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">IWs</span> <span class="o">=</span> <span class="n">IW_from_wireabscissa</span><span class="p">(</span><span class="n">Wire_abscissae</span><span class="p">,</span> <span class="n">wire_height</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="n">anglesample</span><span class="p">)</span>  <span class="c1"># array of [y,z]</span>
    <span class="n">IWs</span> <span class="o">=</span> <span class="n">IWs</span><span class="o">.</span><span class="n">T</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">pairs_of_indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">IWs</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Wire_abscissae</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">OMs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">IWs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">))):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;oms&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">OMs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;iws&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">IWs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">find_yzsource_from_2xycam_2yzwire_version2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">OMs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                                        <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">IWs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                                        <span class="n">calib</span><span class="p">,</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IW_from_wireabscissa</span><span class="p">(</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">wire_height</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from:</span>
<span class="sd">    abscissa of wire and wire height from sample surface inclined by anglesample (deg)</span>

<span class="sd">    returns:</span>
<span class="sd">    absolute coordinate of wire (hypothesis x is undetermined)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ang</span> <span class="o">=</span> <span class="n">anglesample</span> <span class="o">*</span> <span class="n">DEG</span>
    <span class="n">sw0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
    <span class="n">cw0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">abscissa</span> <span class="o">*</span> <span class="n">cw0</span> <span class="o">-</span> <span class="n">wire_height</span> <span class="o">*</span> <span class="n">sw0</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">abscissa</span> <span class="o">*</span> <span class="n">sw0</span> <span class="o">+</span> <span class="n">wire_height</span> <span class="o">*</span> <span class="n">cw0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">Wireabscissa_from_IW</span><span class="p">(</span><span class="n">IWy</span><span class="p">,</span> <span class="n">IWz</span><span class="p">,</span> <span class="n">wire_height</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    from:</span>
<span class="sd">    absolute coordinate of wire (hypothesis x is undetermined)</span>
<span class="sd">    wire height from sample surface inclined by anglesample (deg)</span>

<span class="sd">    returns:</span>
<span class="sd">    abscissa of wire along ysample inclined by anglesample from point at IIw0 distance from I</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angs</span> <span class="o">=</span> <span class="n">anglesample</span> <span class="o">*</span> <span class="n">DEG</span>

    <span class="c1"># IH = np.array([0, -wire_height * np.sin(angs), wire_height * np.cos(angs)])</span>

    <span class="c1"># WH = array([0, IWy, IWz]) -  IH</span>

    <span class="n">WHy</span> <span class="o">=</span> <span class="n">IWy</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="n">wire_height</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angs</span><span class="p">))</span>
    <span class="n">WHz</span> <span class="o">=</span> <span class="n">IWz</span> <span class="o">-</span> <span class="n">wire_height</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angs</span><span class="p">)</span>

    <span class="c1"># add sign simply for angle wire  around 40 deg</span>
    <span class="n">signe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">IWz</span> <span class="o">&gt;</span> <span class="n">wire_height</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angs</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">signe</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">WHy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">WHz</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">twotheta_from_wire_and_source</span><span class="p">(</span><span class="n">ysource</span><span class="p">,</span> <span class="n">Height_wire</span><span class="p">,</span> <span class="n">Abscissa_wire</span><span class="p">,</span> <span class="n">anglesample</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    point moving parallel to sample surface in Oyz plane</span>

<span class="sd">    ysource= II&#39;  abscissa of spots emission (I&#39;) from calibration origin source (I)</span>
<span class="sd">    Height_wire= height of moving point Iw from sample surface</span>
<span class="sd">    Abscissa_wire= abscissa of moving point along its straight trajectory from point Iw0</span>
<span class="sd">            which is in between I and microscope  (normal at sample surface)</span>

<span class="sd">    returns scattering angle 2theta from y direction to I&#39;Iw (no x component)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lambda_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">Height_wire</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Abscissa_wire</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span> <span class="o">+</span> <span class="n">anglesample</span>
    <span class="n">coslambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lambda_angle</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">yprime</span> <span class="o">=</span> <span class="n">ysource</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Abscissa_wire</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">coslambda</span> <span class="o">-</span> <span class="n">yprime</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">yprime</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">yprime</span> <span class="o">*</span> <span class="n">coslambda</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span>


<div class="viewcode-block" id="convert_xycam_from_sourceshift"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.convert_xycam_from_sourceshift">[docs]</a><span class="k">def</span> <span class="nf">convert_xycam_from_sourceshift</span><span class="p">(</span><span class="n">OMs</span><span class="p">,</span> <span class="n">IIp</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From x,y on CCD camera (OMs) and source shift (IIprime)</span>
<span class="sd">    compute modified x,y values for the SAME calibration (calib)(for further analysis)</span>

<span class="sd">    return new value of x,y</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span> <span class="o">=</span> <span class="n">OMs</span><span class="o">.</span><span class="n">T</span>
    <span class="n">uflab</span><span class="p">,</span> <span class="n">IM</span> <span class="o">=</span> <span class="n">calc_uflab</span><span class="p">(</span><span class="n">xcam</span><span class="p">,</span> <span class="n">ycam</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">returnAngles</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">)</span>  <span class="c1"># IM normalized</span>
    <span class="c1"># IM vectors</span>
    <span class="c1"># IM=IprimeM_from_uf(uflab,array([0,0,0]),calib,verbose=0)</span>
    <span class="n">OM</span> <span class="o">=</span> <span class="n">calc_xycam</span><span class="p">(</span><span class="n">uflab</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnIpM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">)</span>
    <span class="n">x0cam</span><span class="p">,</span> <span class="n">y0cam</span><span class="p">,</span> <span class="n">th0</span><span class="p">,</span> <span class="n">E0</span> <span class="o">=</span> <span class="n">OM</span>
    <span class="c1"># IpM=IpI + IM= IM-IIP</span>
    <span class="n">IpM</span> <span class="o">=</span> <span class="n">IM</span> <span class="o">-</span> <span class="n">IIp</span>
    <span class="n">nor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IpM</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># new uf prime</span>
    <span class="n">ufp</span> <span class="o">=</span> <span class="n">IpM</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nor</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nor</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">OpMp</span> <span class="o">=</span> <span class="n">calc_xycam</span><span class="p">(</span><span class="n">ufp</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnIpM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">)</span>
    <span class="n">xpcam</span><span class="p">,</span> <span class="n">ypcam</span><span class="p">,</span> <span class="n">thp</span><span class="p">,</span> <span class="n">Ep</span> <span class="o">=</span> <span class="n">OpMp</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> for source at I and Iprime&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X in pixel&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x0cam</span><span class="p">,</span> <span class="n">xpcam</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Y in pixel&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">y0cam</span><span class="p">,</span> <span class="n">ypcam</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2theta in deg&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">th0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">thp</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energy&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">E0</span><span class="p">,</span> <span class="n">Ep</span><span class="p">)</span>
        <span class="c1"># print uflab,ufp</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> for IIprime (mm)&quot;</span><span class="p">,</span> <span class="n">IIp</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;And calibration &quot;</span><span class="p">,</span> <span class="n">calib</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> shift to add to X&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">xpcam</span> <span class="o">-</span> <span class="n">x0cam</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;shift to add to Y&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ypcam</span> <span class="o">-</span> <span class="n">y0cam</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;shift to add to 2theta in deg&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">thp</span> <span class="o">-</span> <span class="n">th0</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;shift to add to Energy (IN eV)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ep</span> <span class="o">-</span> <span class="n">E0</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">absorbprofile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; absorption profile&quot;&quot;&quot;</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">R</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">cond</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Absorbfunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">coef</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">x0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; absorption function &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">coef</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">yabs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Absorbfunction</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">yabs</span><span class="p">)</span>
    <span class="c1"># y=np.piecewise(x,[cond],[Absorbfunction,1.],radius=R,coef=mu,center=x0)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">cond</span><span class="p">],</span> <span class="p">[</span><span class="n">yabs</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<div class="viewcode-block" id="lengthInSample"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.LaueGeometry.lengthInSample">[docs]</a><span class="k">def</span> <span class="nf">lengthInSample</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">twtheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; compute geometrical lengthes in sample from impact point (I) at the surface to a point (B)</span>
<span class="sd">    where xray are scattered (or fluorescence is emitted) and finally escape from inside at point (C) lying at the sample surface</span>
<span class="sd">    (intersection of line with unit vector u with sample surface plane tilted by omega)</span>

<span class="sd">    .. warning::</span>

<span class="sd">        twtheta and chi angles can be misleading.</span>
<span class="sd">        Assumption is made that angles of unit vector from B to C (or to detector frame pixel) are</span>
<span class="sd">        :math:`2 \theta` and :math:`\chi`.</span>
<span class="sd">        For large depth D, unit vector scattered beam direction is not given by :math:`2 \theta` and :math:`\chi` angles</span>
<span class="sd">        as they are used for describing the scattering direction from point I and a given detector frame position</span>
<span class="sd">        (you should then compute the two angles correction , actually :math:`\chi` is unchanged, and the :math:`2 \theta` change is approx</span>
<span class="sd">        d/ distance .i.e. 3 10-4 for d=20 µm and CCD at 70 mm)</span>

<span class="sd">    .. note::</span>

<span class="sd">        incoming beam coming from the right positive x direction with</span>
<span class="sd">            - IB = (-D,0,0)</span>
<span class="sd">            - BC =(xc+D,yc,zc)</span>
<span class="sd">            - and length BC is proportional to the depth D</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="n">c2theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">twtheta</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">s2theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">twtheta</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">cchi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">chi</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">schi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">chi</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">comega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="n">somega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">)</span>

    <span class="n">factor</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">somega</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="n">c2theta</span> <span class="o">*</span> <span class="n">somega</span> <span class="o">+</span> <span class="n">s2theta</span> <span class="o">*</span> <span class="n">cchi</span> <span class="o">*</span> <span class="n">comega</span><span class="p">)</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">c2theta</span><span class="p">)</span>
    <span class="n">yc</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">s2theta</span> <span class="o">*</span> <span class="n">schi</span><span class="p">)</span>
    <span class="n">zc</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">s2theta</span> <span class="o">*</span> <span class="n">cchi</span><span class="p">)</span>

    <span class="n">BC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xc</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yc</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">zc</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[x,y,z] of BC&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">twtheta</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">zc</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">Ratio_BC_over_D</span> <span class="o">=</span> <span class="n">BC</span> <span class="o">/</span> <span class="n">D</span>

    <span class="k">return</span> <span class="n">D</span> <span class="o">+</span> <span class="n">BC</span><span class="p">,</span> <span class="n">BC</span><span class="p">,</span> <span class="n">Ratio_BC_over_D</span><span class="p">,</span> <span class="n">D</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, J.S. Micha, O. Robach., S. Tardif

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>