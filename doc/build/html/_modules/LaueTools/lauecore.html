

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>LaueTools.lauecore &mdash; LaueTools  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> LaueTools
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getStarted.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../conventions.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../GUIs.html">Graphical User Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LaueToolsModules.html">LaueTools Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">LaueTools</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>LaueTools.lauecore</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for LaueTools.lauecore</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core module to compute Laue Pattern in various geometry</span>

<span class="sd">Main author is J. S. Micha:   micha [at] esrf [dot] fr</span>

<span class="sd">version July 2019</span>
<span class="sd">from LaueTools package hosted in</span>

<span class="sd">http://sourceforge.net/projects/lauetools/</span>

<span class="sd">or</span>

<span class="sd">https://gitlab.esrf.fr/micha/lauetools</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">builtins</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

<span class="c1"># LaueTools modules</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">CrystalParameters</span> <span class="k">as</span> <span class="n">CP</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">generaltools</span> <span class="k">as</span> <span class="n">GT</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">IOLaueTools</span> <span class="k">as</span> <span class="n">IOLT</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="n">dict_LaueTools</span> <span class="kn">import</span> <span class="p">(</span><span class="n">dict_Materials</span><span class="p">,</span> <span class="n">dict_Extinc</span><span class="p">,</span> <span class="n">CST_ENERGYKEV</span><span class="p">,</span>
            <span class="n">DEFAULT_DETECTOR_DISTANCE</span><span class="p">,</span> <span class="n">DEFAULT_DETECTOR_DIAMETER</span><span class="p">,</span> <span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">LaueGeometry</span> <span class="k">as</span> <span class="n">LTGeo</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">CrystalParameters</span> <span class="k">as</span> <span class="nn">CP</span>
    <span class="kn">import</span> <span class="nn">generaltools</span> <span class="k">as</span> <span class="nn">GT</span>
    <span class="kn">import</span> <span class="nn">IOLaueTools</span> <span class="k">as</span> <span class="nn">IOLT</span>
    <span class="kn">from</span> <span class="nn">dict_LaueTools</span> <span class="k">import</span> <span class="p">(</span><span class="n">dict_Materials</span><span class="p">,</span> <span class="n">dict_Extinc</span><span class="p">,</span> <span class="n">CST_ENERGYKEV</span><span class="p">,</span>
            <span class="n">DEFAULT_DETECTOR_DISTANCE</span><span class="p">,</span> <span class="n">DEFAULT_DETECTOR_DIAMETER</span><span class="p">,</span> <span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">)</span>

    <span class="c1"># TODO: LTGeo to be removed</span>
    <span class="kn">import</span> <span class="nn">LaueGeometry</span> <span class="k">as</span> <span class="nn">LTGeo</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">generatehkl</span>

    <span class="n">USE_CYTHON</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cython compiled module for fast computation of Laue spots is not installed!&quot;</span><span class="p">)</span>
    <span class="n">USE_CYTHON</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">DEG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>

<span class="c1"># --- ---------- Spot class</span>
<span class="k">class</span> <span class="nc">spot</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Laue Spot class still used...</span>

<span class="sd">    .. todo:: To be avoided for greater performance... To be replaced by full numpy computations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indice</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Millers</span> <span class="o">=</span> <span class="n">indice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Qxyz</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xcam</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ycam</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Twicetheta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Chi</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        to used indices for defining a key and using set() sorted()  ... object</span>
<span class="sd">        comparison</span>
<span class="sd">        In our case used for eliminating spots which equal fondamental key</span>
<span class="sd">        Warning: Indice must not be changed , intead troubles:</span>
<span class="sd">            see http://wiki.python.org/moin/DictionaryKeys</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># listint = tuple(self.have_fond().Millers)</span>
        <span class="c1"># still have -2 -4 -2   =  -2 -2 -4</span>
        <span class="n">III</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">have_fond_indices</span><span class="p">()</span>
        <span class="n">listint</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">100000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">III</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">listint</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">have_fond_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return prime indices (fondamental direction)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">interlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Millers</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">interlist</span><span class="p">]</span>
        <span class="c1"># print &quot;interlist &quot;,interlist</span>
        <span class="c1"># print &quot;inter &quot;, inter</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Millers</span><span class="p">)</span> <span class="o">/</span> <span class="n">GT</span><span class="o">.</span><span class="n">pgcdl</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>

<span class="c1"># --- ---------------   PROCEDURES</span>
<div class="viewcode-block" id="Quicklist"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.Quicklist">[docs]</a><span class="k">def</span> <span class="nf">Quicklist</span><span class="p">(</span><span class="n">OrientMatrix</span><span class="p">,</span> <span class="n">ReciprocBasisVectors</span><span class="p">,</span> <span class="n">listRSnorm</span><span class="p">,</span> <span class="n">lambdamin</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return 6 indices min and max boundary values for each Miller index h, k, l</span>
<span class="sd">    to be contained in the largest Ewald Sphere.</span>

<span class="sd">    :param OrientMatrix:  orientation matrix (3*3 matrix)</span>
<span class="sd">    :param ReciprocBasisVectors:      list of the three vectors a*,b*,c* in the lab frame</span>
<span class="sd">                            before rotation with OrientMatrix</span>
<span class="sd">    :param listRSnorm:      : list of the three reciprocal space lengthes of a*,b*,c*</span>
<span class="sd">    :param lambdamin:       : lambdamin (in Angstrom) corresponding to energy max</span>

<span class="sd">    :return: [[hmin,hmax],[kmin,kmax],[lmin,lmax]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#     print &quot;OrientMatrix in Quicklist&quot;, OrientMatrix</span>

    <span class="k">assert</span> <span class="n">lambdamin</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lambdamin in Quicklist is not positive! </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">lambdamin</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">OrientMatrix</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">OrientMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">OrientMatrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">OrientMatrix</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix is not 3*3 array !!!</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">OrientMatrix</span><span class="p">))</span>

    <span class="k">if</span> <span class="mf">0.</span> <span class="ow">in</span> <span class="n">listRSnorm</span> <span class="ow">or</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">listRSnorm</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;listRSnorm contains 0 !! </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">listRSnorm</span><span class="p">))</span>

    <span class="c1"># lengthes of a*,b*,c*</span>
    <span class="n">astarnorm</span><span class="p">,</span> <span class="n">bstarnorm</span><span class="p">,</span> <span class="n">cstarnorm</span> <span class="o">=</span> <span class="n">listRSnorm</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;norms of input a*,b*,c* : in Angstrom-1&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">([</span><span class="n">astarnorm</span><span class="p">,</span> <span class="n">bstarnorm</span><span class="p">,</span> <span class="n">cstarnorm</span><span class="p">])</span>

    <span class="c1"># vec a*,b*,c* input</span>
    <span class="n">vecastar</span><span class="p">,</span> <span class="n">vecbstar</span><span class="p">,</span> <span class="n">veccstar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ReciprocBasisVectors</span><span class="p">)</span>

    <span class="c1"># unit vectors</span>
    <span class="c1"># input vec a* normalized , ie vec a* direction</span>
    <span class="n">vecastar_n</span> <span class="o">=</span> <span class="n">vecastar</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">vecastar</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">vecbstar_n</span> <span class="o">=</span> <span class="n">vecbstar</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">vecbstar</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">veccstar_n</span> <span class="o">=</span> <span class="n">veccstar</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">veccstar</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># vec a* with appropriate length</span>
    <span class="n">astar</span> <span class="o">=</span> <span class="n">vecastar_n</span> <span class="o">*</span> <span class="n">astarnorm</span>
    <span class="n">bstar</span> <span class="o">=</span> <span class="n">vecbstar_n</span> <span class="o">*</span> <span class="n">bstarnorm</span>
    <span class="n">cstar</span> <span class="o">=</span> <span class="n">veccstar_n</span> <span class="o">*</span> <span class="n">cstarnorm</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;(a*,b*,c*) in Angstrom-1&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">astar</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">bstar</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cstar</span><span class="p">)</span>

    <span class="n">normastar</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">astar</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">normbstar</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">bstar</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">normcstar</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">cstar</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;norms of a*,b*,c* : (must be equal to input norms) in Angstrom-1&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">normastar</span><span class="p">,</span> <span class="n">normbstar</span><span class="p">,</span> <span class="n">normcstar</span><span class="p">)</span>

    <span class="c1"># rotation matrix or orientation matrix</span>
    <span class="n">matrice_rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">OrientMatrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">matrice_rot</span><span class="p">)</span>

    <span class="n">rotAstar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrice_rot</span><span class="p">,</span> <span class="n">astar</span><span class="p">)</span>  <span class="c1"># R(vec a* with appropriate length)</span>
    <span class="n">rotBstar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrice_rot</span><span class="p">,</span> <span class="n">bstar</span><span class="p">)</span>
    <span class="n">rotCstar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrice_rot</span><span class="p">,</span> <span class="n">cstar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;R(a*, b*, c*) in Angstrom-1&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rotAstar</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rotBstar</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rotCstar</span><span class="p">)</span>

    <span class="c1"># transfer matrix from R(a*),R(b*),R(c*) to X, Y, Z</span>
    <span class="n">matricerotvecstar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rotAstar</span><span class="p">,</span> <span class="n">rotBstar</span><span class="p">,</span> <span class="n">rotCstar</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="c1"># transfer matrix from X, Y, Z to R(a*),R(b*),R(c*)</span>
    <span class="c1"># inv_matricerotstar = scipy.linalg.basic.inv(matricerotvecstar)</span>
    <span class="n">inv_matricerotstar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matricerotvecstar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ------------------------&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;transfer matrix from R(a*),R(b*),R(c*) to X, Y, Z&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">matricerotvecstar</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ------------------------&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;transfer matrix from X, Y, Z to R(a*),R(b*),R(c*)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">inv_matricerotstar</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1 / lambdamin:&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span><span class="p">,</span> <span class="s2">&quot; Angstrom-1&quot;</span><span class="p">)</span>

    <span class="n">OC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>  <span class="c1"># centre of the largest Ewald sphere in X, Y, Z frame</span>

    <span class="n">OCrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_matricerotstar</span><span class="p">,</span> <span class="n">OC</span><span class="p">)</span>  <span class="c1"># same centre in the R(a*),R(b*),R(c*) frame</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;center of largest Ewald Sphere in the R(a*),R(b*),R(c*) frame&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">OCrot</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1 / lambdamin in corresponding R(a*),R(b*),R(c*) units&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">([</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normastar</span><span class="p">,</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normbstar</span><span class="p">,</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normcstar</span><span class="p">])</span>

    <span class="c1"># for non alpha = beta = gamma = 90 deg case</span>
    <span class="c1"># Calculate the crossproduct of rotated vector to correct properly the range on each rotated vector</span>

    <span class="n">crossastar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rotBstar</span><span class="p">,</span> <span class="n">rotCstar</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rotBstar</span><span class="p">,</span> <span class="n">rotCstar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># normalised cross vector for reference</span>
    <span class="n">crossbstar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rotCstar</span><span class="p">,</span> <span class="n">rotAstar</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rotCstar</span><span class="p">,</span> <span class="n">rotAstar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">crosscstar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rotAstar</span><span class="p">,</span> <span class="n">rotBstar</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rotAstar</span><span class="p">,</span> <span class="n">rotBstar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;crossedvector&quot;</span><span class="p">,</span> <span class="n">crossastar</span><span class="p">,</span> <span class="n">crossbstar</span><span class="p">,</span> <span class="n">crosscstar</span><span class="p">)</span>

    <span class="n">cosanglea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotAstar</span> <span class="o">/</span> <span class="n">normastar</span><span class="p">,</span> <span class="n">crossastar</span><span class="p">)</span>
    <span class="n">cosangleb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotBstar</span> <span class="o">/</span> <span class="n">normbstar</span><span class="p">,</span> <span class="n">crossbstar</span><span class="p">)</span>
    <span class="n">cosanglec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotCstar</span> <span class="o">/</span> <span class="n">normcstar</span><span class="p">,</span> <span class="n">crosscstar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cosangle&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">cosanglea</span><span class="p">,</span> <span class="n">cosangleb</span><span class="p">,</span> <span class="n">cosanglec</span><span class="p">])</span>

    <span class="n">hmin</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">properinteger</span><span class="p">(</span><span class="n">OCrot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normastar</span> <span class="o">/</span> <span class="n">cosanglea</span><span class="p">)</span>
    <span class="n">kmin</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">properinteger</span><span class="p">(</span><span class="n">OCrot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normbstar</span> <span class="o">/</span> <span class="n">cosangleb</span><span class="p">)</span>
    <span class="n">lmin</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">properinteger</span><span class="p">(</span><span class="n">OCrot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normcstar</span> <span class="o">/</span> <span class="n">cosanglec</span><span class="p">)</span>

    <span class="n">hmax</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">properinteger</span><span class="p">(</span><span class="n">OCrot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normastar</span> <span class="o">/</span> <span class="n">cosanglea</span><span class="p">)</span>
    <span class="n">kmax</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">properinteger</span><span class="p">(</span><span class="n">OCrot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normbstar</span> <span class="o">/</span> <span class="n">cosangleb</span><span class="p">)</span>
    <span class="n">lmax</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">properinteger</span><span class="p">(</span><span class="n">OCrot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lambdamin</span> <span class="o">/</span> <span class="n">normcstar</span> <span class="o">/</span> <span class="n">cosanglec</span><span class="p">)</span>

    <span class="c1"># print &quot;hmM, kmM, lmM&quot;,[hmin, hmax, kmin, kmax, lmin, lmax]</span>
    <span class="c1"># SECURITY -1</span>
    <span class="n">Hmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">Kmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">Lmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># SECURITY +1 and +1 because of exclusion convention for slicing in python</span>
    <span class="c1"># (superior limit in range is excluded)</span>
    <span class="n">Hmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">Kmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">Lmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="c1"># print &quot;Hmin, Kmin, Lmin&quot;,Hmin, Kmin, Lmin</span>
    <span class="c1"># print &quot;Hmax, Kmax, Lmax&quot;,Hmax, Kmax, Lmax</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">list_hkl_limits</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">Hmin</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">Hmax</span><span class="p">)],</span>
                        <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">Kmin</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">Kmax</span><span class="p">)],</span>
                        <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">Lmin</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">Lmax</span><span class="p">)]]</span>
        <span class="k">return</span> <span class="n">list_hkl_limits</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="genHKL_np"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.genHKL_np">[docs]</a><span class="k">def</span> <span class="nf">genHKL_np</span><span class="p">(</span><span class="n">listn</span><span class="p">,</span> <span class="n">Extinc</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate all Miller indices hkl from indices limits given  by listn</span>
<span class="sd">    and taking into account for systematic exctinctions</span>

<span class="sd">    :param listn: Miller indices limits (warning: these lists are used in python range (last index is excluded))</span>
<span class="sd">    :type listn: [[hmin,hmax],[kmin,kmax],[lmin,lmax]]</span>

<span class="sd">    :param Extinc: label corresponding to systematic exctinction</span>
<span class="sd">        rules on h k and l miller indics such as (&#39;fcc&#39;, &#39;bcc&#39;, &#39;dia&#39;, ...) or &#39;no&#39; for any rules</span>
<span class="sd">    :type Extinc: string</span>

<span class="sd">    :return: array of [h,k,l]</span>

<span class="sd">    .. note:: node [0,0,0] is excluded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">listn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hkl ranges are undefined&quot;</span><span class="p">)</span>

    <span class="c1">#    print &quot;inside genHKL_np&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">listn</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">listn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_h_min</span><span class="p">,</span> <span class="n">n_h_max</span> <span class="o">=</span> <span class="n">listn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_k_min</span><span class="p">,</span> <span class="n">n_k_max</span> <span class="o">=</span> <span class="n">listn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_l_min</span><span class="p">,</span> <span class="n">n_l_max</span> <span class="o">=</span> <span class="n">listn</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arg #1 has not the shape (3, 2)&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arg #1 is not a list or has not 3 elements&quot;</span><span class="p">)</span>

    <span class="n">nbelements</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_h_max</span> <span class="o">-</span> <span class="n">n_h_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_k_max</span> <span class="o">-</span> <span class="n">n_k_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_l_max</span> <span class="o">-</span> <span class="n">n_l_min</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">nbelements</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nbelements</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="n">nbelements</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Needs (3,2) list of sorted integers&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Extinc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_Extinc</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not understand extinction code: &quot; </span><span class="si">%s</span><span class="s1"> &quot; &#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">Extinc</span><span class="p">))</span>

    <span class="n">HKLraw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">n_h_min</span><span class="p">:</span><span class="n">n_h_max</span><span class="p">,</span> <span class="n">n_k_min</span><span class="p">:</span><span class="n">n_k_max</span><span class="p">,</span> <span class="n">n_l_min</span><span class="p">:</span><span class="n">n_l_max</span><span class="p">]</span>
    <span class="n">HKLs</span> <span class="o">=</span> <span class="n">HKLraw</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#    print &quot;HKLs&quot;, HKLs</span>
    <span class="n">HKL</span> <span class="o">=</span> <span class="n">HKLraw</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">HKLs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">HKLs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">HKLs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">HKLs</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">CP</span><span class="o">.</span><span class="n">ApplyExtinctionrules</span><span class="p">(</span><span class="n">HKL</span><span class="p">,</span> <span class="n">Extinc</span><span class="p">)</span></div>


<span class="c1"># --- -----------------------  Main procedures</span>
<span class="k">def</span> <span class="nf">parse_grainparameters</span><span class="p">(</span><span class="n">SingleCrystalParams</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extract and check type of the 4 elements of SingleCrystalParams</span>

<span class="sd">    .. todo:: to be used</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Bmatrix</span><span class="p">,</span> <span class="n">Extinc</span><span class="p">,</span> <span class="n">Orientmatrix</span><span class="p">,</span> <span class="n">key_for_dict</span> <span class="o">=</span> <span class="n">SingleCrystalParams</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;List of input parameters for crystal Laue pattern simulation &quot;</span>
                            <span class="s2">&quot;has </span><span class="si">%d</span><span class="s2"> elements instead of 4 !&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">SingleCrystalParams</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">Extinc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_Extinc</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong code </span><span class="si">%s</span><span class="s2"> for extinction !&quot;</span> <span class="o">%</span> <span class="n">Extinc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Bmatrix</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong B matrix format!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Orientmatrix</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong Orientmatrix format!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Bmatrix</span><span class="p">,</span> <span class="n">Extinc</span><span class="p">,</span> <span class="n">Orientmatrix</span><span class="p">,</span> <span class="n">key_for_dict</span>


<div class="viewcode-block" id="getLaueSpots"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.getLaueSpots">[docs]</a><span class="k">def</span> <span class="nf">getLaueSpots</span><span class="p">(</span><span class="n">wavelmin</span><span class="p">,</span> <span class="n">wavelmax</span><span class="p">,</span> <span class="n">crystalsParams</span><span class="p">,</span> <span class="n">linestowrite</span><span class="p">,</span>
                                            <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">,</span>
                                            <span class="n">OpeningAngleCollection</span><span class="o">=</span><span class="mf">22.0</span><span class="p">,</span>
                                            <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                            <span class="n">fileOK</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">dictmaterials</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Qxyz vectors and corresponding HKL miller indices for nodes in recicprocal space that can be measured</span>
<span class="sd">    for the given detection geometry and energy bandpass configuration.</span>

<span class="sd">    :param wavelmin:   smallest wavelength in Angstrom</span>
<span class="sd">    :param wavelmax:  largest wavelength in Angstrom</span>

<span class="sd">    :param crystalsParams: list of *SingleCrystalParams*, each of them being a list</span>
<span class="sd">        of 4 elements for crystal orientation and strain properties:</span>

<span class="sd">        * [0](array): is the B matrix a*,b*,c* vectors are expressed in column</span>
<span class="sd">            in LaueTools frame in reciprocal angstrom units</span>

<span class="sd">        * [1](str): peak Extinction rules (&#39;no&#39;,&#39;fcc&#39;,&#39;dia&#39;, etc...)</span>

<span class="sd">        * [2](array): orientation matrix</span>

<span class="sd">        * [3](str): key for material element</span>

<span class="sd">    :param kf_direction: string defining the average geometry, mean value of exit scattered vector:</span>
<span class="sd">        &#39;Z&gt;0&#39;   top spots</span>

<span class="sd">        &#39;Y&gt;0&#39;   one side spots (towards hutch door)</span>

<span class="sd">        &#39;Y&lt;0&#39;   other side spots</span>

<span class="sd">        &#39;X&gt;0&#39;   transmission spots</span>

<span class="sd">        &#39;X&lt;0&#39;   backreflection spots</span>
<span class="sd">    :param fastcompute:</span>
<span class="sd">        * 1, compute reciprocal space (RS) vector BUT NOT the Miller indices</span>

<span class="sd">        * 0, returns both RS vectors (normalised) and Miller indices</span>

<span class="sd">    :param ResolutionAngstrom:</span>
<span class="sd">        * scalar, smallest interplanar distance ordered in crystal in angstrom.</span>

<span class="sd">        * None, all reflections will be calculated that can be time-consuming for large unit cell</span>

<span class="sd">    :param linestowrite: list of [string] that can be write in file or display in</span>
<span class="sd">        stdout. Example: [[&quot;&quot;]] or [[&quot;**********&quot;],[&quot;lauetools&quot;]]</span>

<span class="sd">    :return:</span>
<span class="sd">        * list of [Qx,Qy,Qz]s for each grain, list of [H,K,L]s for each grain (fastcompute = 0)</span>

<span class="sd">        * list of [Qx,Qy,Qz]s for each grain, None  (fastcompute = 1)</span>

<span class="sd">    .. caution::</span>
<span class="sd">        This method doesn&#39;t create spot instances.</span>

<span class="sd">        This is done in filterLaueSpots with fastcompute = 0</span>
<span class="sd">    .. caution::</span>
<span class="sd">        finer selection of nodes : on camera , without harmonics can be</span>
<span class="sd">        done later with filterLaueSpots()</span>

<span class="sd">    .. note:: lauetools laboratory frame is in this case:</span>
<span class="sd">        x// ki (center of ewald sphere has neagtive x component)</span>
<span class="sd">        z perp to x and belonging to the plane defined by x and dd vectors</span>
<span class="sd">        (where dd vector is the smallest vector joining sample impact point and points on CCD plane)</span>
<span class="sd">        y is perpendicular to x and z</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wavelmin</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wavelmax</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">wavelmin</span> <span class="o">&lt;</span> <span class="n">wavelmax</span> <span class="ow">and</span> <span class="n">wavelmin</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">wlm</span> <span class="o">=</span> <span class="n">wavelmin</span> <span class="o">*</span> <span class="mf">1.0</span>
            <span class="n">wlM</span> <span class="o">=</span> <span class="n">wavelmax</span> <span class="o">*</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wavelengthes must be positive and ordered&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wavelengthes must have numerical values&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linestowrite</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="n">linestowrite</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;&quot;</span><span class="p">]]</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linestowrite</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linestowrite</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linestowrite</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing list of string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crystalsParams</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Grains parameters list is not correct. It Must be: [grain] for 1 grain or [grain1, grain2] for 2 grains...&quot;</span><span class="p">)</span>

    <span class="n">nb_of_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">crystalsParams</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;energy range: </span><span class="si">%.2f</span><span class="s2"> - </span><span class="si">%.2f</span><span class="s2"> keV&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">wlM</span><span class="p">,</span> <span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">wlm</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of grains: &quot;</span><span class="p">,</span> <span class="n">nb_of_grains</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dictmaterials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dictmaterials</span> <span class="o">=</span> <span class="n">dict_Materials</span>

    <span class="c1"># loop over grains</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nb_of_grains</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">key_material</span> <span class="o">=</span> <span class="n">dictmaterials</span><span class="p">[</span><span class="n">crystalsParams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="n">smsg</span> <span class="o">=</span> <span class="s2">&quot;wrong type of input paramters: must be a list of 4 elements&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">smsg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# grain:  &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot; made of &quot;</span><span class="p">,</span> <span class="n">key_material</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; crystal parameters:&quot;</span><span class="p">,</span> <span class="n">crystalsParams</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">fileOK</span><span class="p">:</span>
            <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><span class="s2">&quot;</span><span class="p">])</span>
            <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;grain no &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s2">&quot; made of &quot;</span><span class="p">,</span> <span class="n">key_material</span><span class="p">,</span>
                                <span class="s2">&quot; default lattice parameter &quot;</span><span class="p">,</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">dictmaterials</span><span class="p">[</span><span class="n">crystalsParams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]][</span><span class="mi">1</span><span class="p">]),])</span>
            <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;(vec* basis in lab. frame, real lattice lengthes expansion, &quot;</span>
            <span class="s2">&quot;orientation matrix, atomic number):&quot;</span><span class="p">])</span>
            <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;(orientation angles have no meanings here since orienation &quot;</span>
            <span class="s2">&quot;is given by a quaternion extracted from openGL, see below)&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">crystalsParams</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">elem</span><span class="p">)])</span>
        <span class="c1"># print dictmaterials[crystalsParams[i][3]]</span>

    <span class="k">if</span> <span class="n">fileOK</span><span class="p">:</span>
        <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;************------------------------------------***************&quot;</span><span class="p">])</span>
        <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;energy range: &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">wlM</span><span class="p">),</span> <span class="s2">&quot; - &quot;</span><span class="p">,</span>
                                        <span class="nb">str</span><span class="p">(</span><span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">wlm</span><span class="p">),</span> <span class="s2">&quot; keV&quot;</span><span class="p">,])</span>

    <span class="n">wholelistvecfiltered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">wholelistindicesfiltered</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># calculation of RS lattice nodes in lauetools laboratory frame and indices</span>

    <span class="c1"># loop over grains</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nb_of_grains</span><span class="p">)):</span>

        <span class="p">(</span><span class="n">Bmatrix</span><span class="p">,</span> <span class="n">Extinc</span><span class="p">,</span>
        <span class="n">Orientmatrix</span><span class="p">,</span> <span class="n">key_for_dict</span><span class="p">)</span> <span class="o">=</span> <span class="n">parse_grainparameters</span><span class="p">(</span><span class="n">crystalsParams</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">in getLaueSpots()&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bmatrix&quot;</span><span class="p">,</span> <span class="n">Bmatrix</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Orientmatrix&quot;</span><span class="p">,</span> <span class="n">Orientmatrix</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;key_for_dict&quot;</span><span class="p">,</span> <span class="n">key_for_dict</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Extinc&quot;</span><span class="p">,</span> <span class="n">Extinc</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="n">Bmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Bmatrix</span><span class="p">)</span>

        <span class="c1"># generation of hkl nodes from Bmatrix</span>

        <span class="n">listvecstarlength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Bmatrix</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># print &quot;listvecstarlength&quot;,listvecstarlength</span>

        <span class="c1"># in Bmatrix.T,  a*, b* ,c* are rows of this argument</span>
        <span class="c1">#  B matrix in q= Orientmatrix B G formula</span>
        <span class="c1"># limitation of probed h k and l ranges</span>
        <span class="n">list_hkl_limits</span> <span class="o">=</span> <span class="n">Quicklist</span><span class="p">(</span><span class="n">Orientmatrix</span><span class="p">,</span> <span class="n">Bmatrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">listvecstarlength</span><span class="p">,</span> <span class="n">wlm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Loop over h k l</span>
        <span class="c1"># ----cython optimization</span>
        <span class="k">global</span> <span class="n">USE_CYTHON</span>
        <span class="k">if</span> <span class="n">USE_CYTHON</span><span class="p">:</span>
            <span class="n">hlim</span><span class="p">,</span> <span class="n">klim</span><span class="p">,</span> <span class="n">llim</span> <span class="o">=</span> <span class="n">list_hkl_limits</span>
            <span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span> <span class="o">=</span> <span class="n">hlim</span>
            <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">=</span> <span class="n">klim</span>
            <span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">=</span> <span class="n">llim</span>
            <span class="n">dict_extinc</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;no&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;fcc&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;dia&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ExtinctionCode</span> <span class="o">=</span> <span class="n">dict_extinc</span><span class="p">[</span><span class="n">Extinc</span><span class="p">]</span>
                <span class="n">SPECIAL_EXTINC</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">ExtinctionCode</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">SPECIAL_EXTINC</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1">#  print &quot;\n\n*******\nUsing Cython optimization\n********\n\n&quot;</span>
            <span class="n">hkls</span><span class="p">,</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">generatehkl</span><span class="o">.</span><span class="n">genHKL</span><span class="p">(</span><span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span><span class="p">,</span> <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span><span class="p">,</span> <span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">ExtinctionCode</span><span class="p">)</span>

            <span class="n">table_vec</span> <span class="o">=</span> <span class="n">hkls</span><span class="p">[:</span><span class="n">counter</span><span class="p">]</span>

            <span class="c1"># TODO need to remove element [0,0,0] or naturally removed in ?</span>
            <span class="k">if</span> <span class="n">SPECIAL_EXTINC</span><span class="p">:</span>
                <span class="c1">#  print &quot;special extinction&quot;</span>
                <span class="n">table_vec</span> <span class="o">=</span> <span class="n">CP</span><span class="o">.</span><span class="n">ApplyExtinctionrules</span><span class="p">(</span><span class="n">table_vec</span><span class="p">,</span> <span class="n">Extinc</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">USE_CYTHON</span><span class="p">:</span>
            <span class="n">table_vec</span> <span class="o">=</span> <span class="n">genHKL_np</span><span class="p">(</span><span class="n">list_hkl_limits</span><span class="p">,</span> <span class="n">Extinc</span><span class="p">)</span>

        <span class="n">Orientmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Orientmatrix</span><span class="p">)</span>

        <span class="n">listrotvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Orientmatrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Bmatrix</span><span class="p">,</span> <span class="n">table_vec</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

        <span class="n">listrotvec_X</span> <span class="o">=</span> <span class="n">listrotvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">listrotvec_Y</span> <span class="o">=</span> <span class="n">listrotvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">listrotvec_Z</span> <span class="o">=</span> <span class="n">listrotvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">arraysquare</span> <span class="o">=</span> <span class="n">listrotvec_X</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">listrotvec_Y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">listrotvec_Z</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># removing all spots that have positive X component</span>
        <span class="n">cond_Xnegativeonly</span> <span class="o">=</span> <span class="n">listrotvec_X</span> <span class="o">&lt;</span> <span class="mf">0.</span>
        <span class="n">listrotvec_X</span> <span class="o">=</span> <span class="n">listrotvec_X</span><span class="p">[</span><span class="n">cond_Xnegativeonly</span><span class="p">]</span>
        <span class="n">listrotvec_Y</span> <span class="o">=</span> <span class="n">listrotvec_Y</span><span class="p">[</span><span class="n">cond_Xnegativeonly</span><span class="p">]</span>
        <span class="n">listrotvec_Z</span> <span class="o">=</span> <span class="n">listrotvec_Z</span><span class="p">[</span><span class="n">cond_Xnegativeonly</span><span class="p">]</span>
        <span class="n">arraysquare</span> <span class="o">=</span> <span class="n">arraysquare</span><span class="p">[</span><span class="n">cond_Xnegativeonly</span><span class="p">]</span>

        <span class="n">table_vec</span> <span class="o">=</span> <span class="n">table_vec</span><span class="p">[</span><span class="n">cond_Xnegativeonly</span><span class="p">]</span>

        <span class="c1">#         print &quot;len(table_vec)&quot;, len(table_vec)</span>

        <span class="c1"># Kf direction selection</span>
        <span class="c1"># top reflection 2theta = 90</span>
        <span class="k">if</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Z&gt;0&quot;</span><span class="p">:</span>
            <span class="n">KF_condit</span> <span class="o">=</span> <span class="n">listrotvec_Z</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
        <span class="c1"># side reflection  2theta = 90</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Y&gt;0&quot;</span><span class="p">:</span>
            <span class="n">KF_condit</span> <span class="o">=</span> <span class="n">listrotvec_Y</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># side reflection  2theta = 90</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Y&lt;0&quot;</span><span class="p">:</span>
            <span class="n">KF_condit</span> <span class="o">=</span> <span class="n">listrotvec_Y</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="c1"># x &gt; -R transmission 2theta = 0</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;X&gt;0&quot;</span><span class="p">:</span>
            <span class="n">KF_condit</span> <span class="o">=</span> <span class="p">(</span><span class="n">listrotvec_X</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">listrotvec_X</span><span class="p">)</span> <span class="o">/</span> <span class="n">arraysquare</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># x &lt; -R back reflection 2theta = 180</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;X&lt;0&quot;</span><span class="p">:</span>
            <span class="n">KF_condit</span> <span class="o">=</span> <span class="p">(</span><span class="n">listrotvec_X</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">listrotvec_X</span><span class="p">)</span> <span class="o">/</span> <span class="n">arraysquare</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1">#   all spots inside the two ewald&#39;s sphere with scattered beams in any direction&#39;</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;4PI&quot;</span><span class="p">:</span>
            <span class="n">KF_condit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">listrotvec_X</span><span class="p">)</span> <span class="o">*</span> <span class="kc">True</span>
        <span class="c1"># user&#39;s definition of mean kf vector</span>
        <span class="c1"># [2theta , chi]= / kf = [cos2theta,sin2theta*sinchi,sin2theta*coschi]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">,</span> <span class="p">(</span><span class="n">builtins</span><span class="o">.</span><span class="n">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">USING user defined LauePattern Region</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kf_direction must be defined by a list of two angles !&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kf_2theta</span><span class="p">,</span> <span class="n">kf_chi</span> <span class="o">=</span> <span class="n">kf_direction</span>
                <span class="n">kf_2theta</span><span class="p">,</span> <span class="n">kf_chi</span> <span class="o">=</span> <span class="n">kf_2theta</span> <span class="o">*</span> <span class="n">DEG</span><span class="p">,</span> <span class="n">kf_chi</span> <span class="o">*</span> <span class="n">DEG</span>

                <span class="n">qmean_theta</span><span class="p">,</span> <span class="n">qmean_chi</span> <span class="o">=</span> <span class="n">kf_2theta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">kf_chi</span>

                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;central q angles&quot;</span><span class="p">,</span> <span class="n">qmean_theta</span><span class="p">,</span> <span class="n">qmean_chi</span><span class="p">)</span>

                <span class="c1"># q.qmean &gt;0</span>
                <span class="c1">#    KF_condit = (-listrotvec_X * np.sin(qmean_theta) + \</span>
                <span class="c1">#                 listrotvec_Y * np.cos(qmean_theta) * np.sin(qmean_chi) + \</span>
                <span class="c1">#                 listrotvec_Z * np.cos(qmean_theta) * np.cos(qmean_chi)) &gt; 0</span>

                <span class="c1">#    # angle(q, qmean) &lt; 45 deg</span>
                <span class="c1">#     AngleMax = OpeningAngleCollection * DEG</span>
                <span class="c1">#   KF_condit = np.arccos(((-listrotvec_X * np.sin(qmean_theta) + \</span>
                <span class="c1">#                            listrotvec_Y * np.cos(qmean_theta) * np.sin(qmean_chi) + \</span>
                <span class="c1">#                            listrotvec_Z * np.cos(qmean_theta) * np.cos(qmean_chi))) / np.sqrt(arraysquare)) &lt; AngleMax</span>

                <span class="c1"># angle(kf, kfmean) &lt; 45 deg</span>
                <span class="n">AngleMax</span> <span class="o">=</span> <span class="n">OpeningAngleCollection</span> <span class="o">*</span> <span class="n">DEG</span>

                <span class="n">Rewald</span> <span class="o">=</span> <span class="n">arraysquare</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">listrotvec_X</span><span class="p">))</span>
                <span class="n">kfsquare</span> <span class="o">=</span> <span class="n">Rewald</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">KF_condit</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span>
                            <span class="p">(</span><span class="n">listrotvec_X</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">kf_2theta</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">listrotvec_Y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">kf_2theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">kf_chi</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">listrotvec_Z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">kf_2theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">kf_chi</span><span class="p">)</span>
                        <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kfsquare</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">AngleMax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kf_direction &#39;</span><span class="si">%s</span><span class="s2">&#39; is not understood!&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">))</span>

        <span class="c1">#        print &quot;nb of KF_condit&quot;, len(np.where(KF_condit == True)[0])</span>

        <span class="c1"># vectors inside the two Ewald&#39;s spheres</span>
        <span class="c1"># last condition could be perhaps put before on</span>
        <span class="c1"># listrotvec_X[listrotvec_Z &gt; 0]...</span>
        <span class="n">Condit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="p">((</span><span class="n">listrotvec_X</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">wlm</span> <span class="o">+</span> <span class="n">arraysquare</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">),</span>
                <span class="p">((</span><span class="n">listrotvec_X</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">wlM</span> <span class="o">+</span> <span class="n">arraysquare</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">),</span> <span class="p">(</span><span class="n">KF_condit</span><span class="p">))</span>
        <span class="c1">#   print &quot;nb of spots in spheres and in towards CCD region&quot;, len(np.where(Condit == True)[0])</span>

        <span class="k">if</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#             print &#39;Using detailled computation mode&#39;</span>

            <span class="k">if</span> <span class="n">ResolutionAngstrom</span><span class="p">:</span>
                <span class="c1"># #crude resolution limitation 2Angstrom for lattice [20 4.8 49]</span>
                <span class="c1"># Hcond = np.abs(table_vec[:,0])&lt;10</span>
                <span class="c1"># Kcond = np.abs(table_vec[:,1])&lt;3</span>
                <span class="c1"># Lcond = np.abs(table_vec[:,2])&lt;25</span>
                <span class="c1"># ConditResolution = np.logical_and(np.logical_and((Hcond) ,</span>
                <span class="c1">#                                                  (Kcond)),</span>
                <span class="c1">#                                                   (Lcond))</span>
                <span class="n">ConditResolution</span> <span class="o">=</span> <span class="n">arraysquare</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">ResolutionAngstrom</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="n">Condit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">ConditResolution</span><span class="p">)</span>

            <span class="c1"># print &quot;Condit&quot;,Condit</span>
            <span class="n">fil_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">listrotvec_X</span><span class="p">)</span>
            <span class="n">fil_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">listrotvec_Y</span><span class="p">)</span>
            <span class="n">fil_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">listrotvec_Z</span><span class="p">)</span>

            <span class="c1"># print &quot;fil_Z&quot;,fil_Z</span>
            <span class="n">fil_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">table_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">fil_K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">table_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">fil_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">table_vec</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

            <span class="n">listvecfiltered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fil_X</span><span class="p">,</span> <span class="n">fil_Y</span><span class="p">,</span> <span class="n">fil_Z</span><span class="p">]))</span>
            <span class="n">listindicesfiltered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fil_H</span><span class="p">,</span> <span class="n">fil_K</span><span class="p">,</span> <span class="n">fil_L</span><span class="p">]))</span>

            <span class="c1">#  print &quot;listindicesfiltered&quot;, len(listindicesfiltered)</span>

            <span class="c1"># if 0:</span>
            <span class="c1"># print &quot;listrotvec[0]&quot;,listrotvec[0]</span>
            <span class="c1"># print &quot;fgfghfg&quot;,fil_X</span>
            <span class="c1"># Energyarray = CST_ENERGYKEV*2*np.abs(listrotvec_X) / arraysquare</span>
            <span class="c1"># Efiltered = np.compress(Condit, Energyarray)</span>
            <span class="c1"># print &quot;energyfiltered&quot;,Efiltered</span>
            <span class="c1"># print &quot;listindicesfiltered&quot;,listindicesfiltered</span>

            <span class="c1"># to return</span>
            <span class="n">wholelistvecfiltered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listvecfiltered</span><span class="p">)</span>
            <span class="n">wholelistindicesfiltered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listindicesfiltered</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Orientation matrix&quot;</span><span class="p">,</span> <span class="n">Orientmatrix</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# grain: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of spots for # grain &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">listvecfiltered</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">fileOK</span><span class="p">:</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;# grain :&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;Orientation matrix given as input :&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">Orientmatrix</span><span class="p">)])</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;Number of spots for # grain  &quot;</span><span class="p">,</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">listvecfiltered</span><span class="p">))])</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;*****-------------*****&quot;</span><span class="p">])</span>

        <span class="c1"># only q vectors are calculated, not Miller indices</span>
        <span class="k">elif</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#            print &#39;Using fastcompute mode&#39;</span>

            <span class="k">if</span> <span class="n">ResolutionAngstrom</span><span class="p">:</span>

                <span class="c1"># #crude resolution limitation 2Angstrom for lattice [20 4.8 49]</span>
                <span class="c1"># Hcond = np.abs(table_vec[:,0])&lt;10</span>
                <span class="c1"># Kcond = np.abs(table_vec[:,1])&lt;3</span>
                <span class="c1"># Lcond = np.abs(table_vec[:,2])&lt;25</span>
                <span class="c1"># ConditResolution = np.logical_and(np.logical_and((Hcond) ,</span>
                <span class="c1">#                                                  (Kcond)),</span>
                <span class="c1">#                                                   (Lcond))</span>

                <span class="n">ConditResolution</span> <span class="o">=</span> <span class="n">arraysquare</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">ResolutionAngstrom</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="n">Condit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">ConditResolution</span><span class="p">)</span>

            <span class="c1"># print &quot;Condit&quot;, Condit</span>
            <span class="n">fil_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">listrotvec_X</span><span class="p">)</span>
            <span class="n">fil_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">listrotvec_Y</span><span class="p">)</span>
            <span class="n">fil_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Condit</span><span class="p">,</span> <span class="n">listrotvec_Z</span><span class="p">)</span>

            <span class="c1"># to return</span>
            <span class="n">listvecfiltered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fil_X</span><span class="p">,</span> <span class="n">fil_Y</span><span class="p">,</span> <span class="n">fil_Z</span><span class="p">]))</span>
            <span class="n">wholelistvecfiltered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listvecfiltered</span><span class="p">)</span>
            <span class="c1"># wholelistindicesfiltered is empty</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Orientation matrix&quot;</span><span class="p">,</span> <span class="n">Orientmatrix</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# grain: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rotating all spots&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nb of spots for # grain  &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">listvecfiltered</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">fileOK</span><span class="p">:</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;# grain :&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;Orientation matrix given as input :&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">Orientmatrix</span><span class="p">)])</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;Number of spots for # grain  &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s2">&quot;: &quot;</span><span class="p">,</span>
                        <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">listvecfiltered</span><span class="p">))])</span>
                <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;*****-------------*****&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">wholelistvecfiltered</span><span class="p">,</span> <span class="n">wholelistindicesfiltered</span></div>


<div class="viewcode-block" id="create_spot"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.create_spot">[docs]</a><span class="k">def</span> <span class="nf">create_spot</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">,</span> <span class="n">miller</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span> <span class="n">allattributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                                <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; From reciprocal space position and 3 miller indices</span>
<span class="sd">    create a spot instance (on top camera geometry)</span>

<span class="sd">    :param pos_vec: 3D vector</span>
<span class="sd">    :type pos_vec: list of 3 float</span>
<span class="sd">    :param  miller: list of 3 miller indices</span>
<span class="sd">    :param detectordistance: approximate distance detector sample (to compute complementary spots attributes)</span>
<span class="sd">    :param  allattributes: False or 0  not to compute complementary spot attributes</span>
<span class="sd">    :param  allattributes: boolean</span>

<span class="sd">    :return: spot instance</span>

<span class="sd">    .. note:: spot.Qxyz is a vector expressed in lauetools frame</span>

<span class="sd">    X along x-ray and Z towards CCD when CCD on top and y towards experimental hutch door</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spotty</span> <span class="o">=</span> <span class="n">spot</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span> <span class="o">=</span> <span class="n">pos_vec</span>
    <span class="n">vecres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecres</span><span class="p">,</span> <span class="n">vecres</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">vecres</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">normkout</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">allattributes</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">detectordistance</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span>
                <span class="o">/</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">spotty</span><span class="o">.</span><span class="n">Xcam</span> <span class="o">=</span> <span class="o">-</span><span class="n">X</span> <span class="o">/</span> <span class="n">pixelsize</span> <span class="o">+</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">spotty</span><span class="o">.</span><span class="n">Ycam</span> <span class="o">=</span> <span class="o">-</span><span class="n">Y</span> <span class="o">/</span> <span class="n">pixelsize</span> <span class="o">+</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">spotty</span><span class="o">.</span><span class="n">Twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">/</span> <span class="n">normkout</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span>
        <span class="c1">#        spotty.Chi = math.atan(spotty.Qxyz[1] * 1. / spotty.Qxyz[2]) / DEG</span>
        <span class="n">spotty</span><span class="o">.</span><span class="n">Chi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>

    <span class="k">return</span> <span class="n">spotty</span></div>


<div class="viewcode-block" id="create_spot_np"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.create_spot_np">[docs]</a><span class="k">def</span> <span class="nf">create_spot_np</span><span class="p">(</span><span class="n">Qxyz</span><span class="p">,</span> <span class="n">miller</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span> <span class="n">allattributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; From reciprocal space position and 3 miller indices</span>
<span class="sd">    create a spot instance (on top camera geometry)</span>

<span class="sd">    :param pos_vec: 3D vector</span>
<span class="sd">    :type pos_vec: list of 3 float</span>
<span class="sd">    :param  miller: list of 3 miller indices</span>
<span class="sd">    :param detectordistance: approximate distance detector sample (to compute complementary spots attributes)</span>
<span class="sd">    :param  allattributes: False or 0  not to compute complementary spot attributes</span>
<span class="sd">    :param  allattributes: boolean</span>

<span class="sd">    :return: spot instance</span>

<span class="sd">    .. note:: spot.Qxyz is a vector expressed in lauetools frame</span>

<span class="sd">    X along x-ray and Z towards CCD when CCD on top and y towards experimental hutch door</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#     print &quot;Qxyz&quot;, Qxyz</span>
    <span class="n">EwaldRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Qxyz</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qxyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="n">ki</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Qxyz</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">ki</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EwaldRadius</span>

    <span class="n">kout</span> <span class="o">=</span> <span class="n">ki</span> <span class="o">+</span> <span class="n">Qxyz</span>
    <span class="c1">#     if spotty.Qxyz[2] &gt; 0:</span>
    <span class="n">normkout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kout</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1">#     print &quot;kout[:, 0]&quot;, kout[:, 0]</span>
    <span class="c1">#     print &quot;len(kout[:, 0])&quot;, len(kout[:, 0])</span>
    <span class="c1">#     print &quot;normkout&quot;, normkout</span>
    <span class="c1">#     print &quot;len(normkout)&quot;, len(normkout)</span>

    <span class="n">Twicetheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">kout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">normkout</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span>
    <span class="c1">#        spotty.Chi = math.atan(spotty.Qxyz[1] * 1. / spotty.Qxyz[2]) / DEG</span>
    <span class="n">Chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">kout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">kout</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>

    <span class="n">Energy</span> <span class="o">=</span> <span class="n">EwaldRadius</span> <span class="o">*</span> <span class="n">CST_ENERGYKEV</span>

    <span class="k">return</span> <span class="n">Twicetheta</span><span class="p">,</span> <span class="n">Chi</span><span class="p">,</span> <span class="n">Energy</span><span class="p">,</span> <span class="n">miller</span></div>


<span class="k">def</span> <span class="nf">create_spot_4pi</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">,</span> <span class="n">miller</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span> <span class="n">allattributes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                                <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; From reciprocal space position and 3 miller indices</span>
<span class="sd">    create a spot scattered in 4pi steradian no camera position</span>

<span class="sd">    .. note:: spot.Qxyz is a vector expressed in lauetools frame</span>

<span class="sd">    X along x-ray and Z towards CCD when CCD on top and y towards experimental hutch door</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spotty</span> <span class="o">=</span> <span class="n">spot</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span> <span class="o">=</span> <span class="n">pos_vec</span>
    <span class="n">vecres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecres</span><span class="p">,</span> <span class="n">vecres</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">vecres</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">normkout</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">spotty</span><span class="o">.</span><span class="n">Twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">/</span> <span class="n">normkout</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span>
    <span class="c1">#    spotty.Chi = math.atan(spotty.Qxyz[1] * 1. / spotty.Qxyz[2]) / DEG</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">Chi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>

    <span class="k">return</span> <span class="n">spotty</span>


<span class="k">def</span> <span class="nf">create_spot_side_pos</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">,</span> <span class="n">miller</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span>
                                        <span class="n">allattributes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                        <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; From reciprocal space position and 3 miller indices</span>
<span class="sd">    create a spot on side camera</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spotty</span> <span class="o">=</span> <span class="n">spot</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span> <span class="o">=</span> <span class="n">pos_vec</span>
    <span class="n">vecres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecres</span><span class="p">,</span> <span class="n">vecres</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">vecres</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">normkout</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allattributes</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">/</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#             spotty.Xcam = X / pixelsize + dim[0] / 2</span>
            <span class="c1">#             spotty.Ycam = Y / pixelsize + dim[1] / 2</span>
            <span class="n">spotty</span><span class="o">.</span><span class="n">Xcam</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">pixelsize</span>
            <span class="n">spotty</span><span class="o">.</span><span class="n">Ycam</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">/</span> <span class="n">pixelsize</span>

        <span class="n">spotty</span><span class="o">.</span><span class="n">Twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">/</span> <span class="n">normkout</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span>
        <span class="c1"># spotty.Chi = math.atan(spotty.Qxyz[1]*1. / spotty.Qxyz[2])/DEG</span>
        <span class="n">spotty</span><span class="o">.</span><span class="n">Chi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>

    <span class="k">return</span> <span class="n">spotty</span>


<span class="k">def</span> <span class="nf">create_spot_side_neg</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">,</span> <span class="n">miller</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span> <span class="n">allattributes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                            <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; From reciprocal space position and 3 miller indices</span>
<span class="sd">    create a spot on neg side camera</span>

<span class="sd">    .. todo:: Update with dim as other create_spot()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spotty</span> <span class="o">=</span> <span class="n">spot</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span> <span class="o">=</span> <span class="n">pos_vec</span>
    <span class="n">vecres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecres</span><span class="p">,</span> <span class="n">vecres</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">vecres</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">normkout</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allattributes</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">/</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">spotty</span><span class="o">.</span><span class="n">Xcam</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">pixelsize</span> <span class="o">+</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">spotty</span><span class="o">.</span><span class="n">Ycam</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">/</span> <span class="n">pixelsize</span> <span class="o">+</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="n">spotty</span><span class="o">.</span><span class="n">Twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">/</span> <span class="n">normkout</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span>
        <span class="c1"># spotty.Chi = math.atan(spotty.Qxyz[1]*1. / spotty.Qxyz[2])/DEG</span>
        <span class="n">spotty</span><span class="o">.</span><span class="n">Chi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>

    <span class="k">return</span> <span class="n">spotty</span>


<span class="k">def</span> <span class="nf">create_spot_front</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">,</span> <span class="n">miller</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span> <span class="n">allattributes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                        <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; From reciprocal space position and 3 miller indices</span>
<span class="sd">    create a spot on forward direction transmission geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#     print &quot;use create_spot_front&quot;</span>
    <span class="n">spotty</span> <span class="o">=</span> <span class="n">spot</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span> <span class="o">=</span> <span class="n">pos_vec</span>
    <span class="n">vecres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecres</span><span class="p">,</span> <span class="n">vecres</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">vecres</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">miller</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">miller</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">miller</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># print(&quot;MILLER == MILER ==0&quot;)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="c1">#print(&#39;good reflection for transmission&#39;)</span>
        <span class="n">abskx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span>
        <span class="n">normkout</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">abskx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># if qx &lt; -R   no spot in transmission mode (qx is &lt;0)</span>
        <span class="k">if</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">X</span> <span class="o">=</span> <span class="o">-</span><span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">abskx</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="o">-</span><span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">abskx</span>
        <span class="n">spotty</span><span class="o">.</span><span class="n">Xcam</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">pixelsize</span> <span class="o">+</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">spotty</span><span class="o">.</span><span class="n">Ycam</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">/</span> <span class="n">pixelsize</span> <span class="o">+</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="n">spotty</span><span class="o">.</span><span class="n">Twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">/</span> <span class="n">normkout</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span>
        <span class="c1"># spotty.Chi = math.atan(spotty.Qxyz[1]*1. / spotty.Qxyz[2])/DEG</span>
        <span class="n">spotty</span><span class="o">.</span><span class="n">Chi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>

        <span class="k">return</span> <span class="n">spotty</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">create_spot_back</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">,</span> <span class="n">miller</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span> <span class="n">allattributes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; From reciprocal space position and 3 miller indices</span>
<span class="sd">    create a spot on backward directions i.e.  back reflection geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spotty</span> <span class="o">=</span> <span class="n">spot</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span> <span class="o">=</span> <span class="n">pos_vec</span>
    <span class="n">vecres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_vec</span><span class="p">)</span>
    <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecres</span><span class="p">,</span> <span class="n">vecres</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">vecres</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">abskx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span>
        <span class="n">normkout</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">abskx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allattributes</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">abskx</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">*</span> <span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">abskx</span>
            <span class="n">spotty</span><span class="o">.</span><span class="n">Xcam</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">pixelsize</span> <span class="o">+</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">spotty</span><span class="o">.</span><span class="n">Ycam</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">/</span> <span class="n">pixelsize</span> <span class="o">+</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="n">spotty</span><span class="o">.</span><span class="n">Twicetheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spotty</span><span class="o">.</span><span class="n">EwaldRadius</span><span class="p">)</span> <span class="o">/</span> <span class="n">normkout</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span>
        <span class="c1"># spotty.Chi = math.atan(spotty.Qxyz[1]*1. / spotty.Qxyz[2])/DEG</span>
        <span class="n">spotty</span><span class="o">.</span><span class="n">Chi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spotty</span><span class="o">.</span><span class="n">Qxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">DEG</span>

    <span class="k">return</span> <span class="n">spotty</span>

<span class="k">def</span> <span class="nf">filterQandHKLvectors</span><span class="p">(</span><span class="n">vec_and_indices</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span> <span class="n">detectordiameter</span><span class="p">,</span> <span class="n">kf_direction</span><span class="o">=</span><span class="s1">&#39;Z&gt;0&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;filter vector Q and HKL in vec_and_indices</span>

<span class="sd">    :param vec_and_indices: arrays of vectors Q and HKL</span>
<span class="sd">    :type vec_and_indices: [Qs, HKLs]</span>
<span class="sd">    :param detectordistance: distance detector sample (mm)</span>
<span class="sd">    :type detectordistance: float</span>
<span class="sd">    :param detectordiameter: detector diameter (mm)</span>
<span class="sd">    :type detectordiameter: float</span>
<span class="sd">    :param kf_direction: geometry of detection label or two angles giving 2theta chi direction of detector, defaults to &#39;Z&gt;0&#39;</span>
<span class="sd">    :type kf_direction: str or 2 floats, optional</span>
<span class="sd">    :raises ValueError: [description]</span>
<span class="sd">    :raises ValueError: [description]</span>
<span class="sd">    :return: [oncam_vec], [oncam_HKL]</span>
<span class="sd">    :rtype: [np.array of 3 elements, np.array of 3 elements]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Qvectors_list</span><span class="p">,</span> <span class="n">HKLs_list</span> <span class="o">=</span> <span class="n">vec_and_indices</span>
    <span class="n">Qx</span> <span class="o">=</span> <span class="n">Qvectors_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="n">Qy</span> <span class="o">=</span> <span class="n">Qvectors_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="n">Qz</span> <span class="o">=</span> <span class="n">Qvectors_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>

    <span class="n">indi_H</span> <span class="o">=</span> <span class="n">HKLs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">indi_K</span> <span class="o">=</span> <span class="n">HKLs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">indi_L</span> <span class="o">=</span> <span class="n">HKLs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="n">Qsquare</span> <span class="o">=</span> <span class="n">Qx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Qy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Qz</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1"># (proportional to photons Energy)</span>
    <span class="n">Rewald</span> <span class="o">=</span> <span class="n">Qsquare</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qx</span><span class="p">)</span>

    <span class="c1"># Kf direction selection</span>
    <span class="k">if</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Z&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># top reflection geometry</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">Qz</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Y&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># side reflection geometry (for detector between the GMT hutch door and the sample (beam coming from right to left)</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">Qy</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qz</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Y&lt;0&quot;</span><span class="p">:</span>  <span class="c1"># other side reflection</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="o">-</span><span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qz</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;X&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># transmission geometry</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="o">-</span><span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qz</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;X&lt;0&quot;</span><span class="p">:</span>  <span class="c1"># back reflection geometry</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qz</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;4PI&quot;</span><span class="p">:</span>  <span class="c1"># to keep all scattered spots</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;kf_direction must be defined by a list of two angles !&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xcam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
            <span class="n">Ycam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown laue geometry code for kf_direction parameter&quot;</span><span class="p">)</span>

    <span class="c1"># print &quot;Xcam, Ycam&quot;,Xcam</span>
    <span class="c1"># print Ycam</span>
    <span class="c1"># print &quot;******************&quot;</span>
    <span class="c1"># On camera filter</span>
    <span class="c1"># print &quot;detectordiameter&quot;, detectordiameter</span>
    <span class="n">halfCamdiametersquare</span> <span class="o">=</span> <span class="p">(</span><span class="n">detectordiameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="c1"># TODO: should contain Xcam-Xcamcen (mm) and Ycam-Ycamcen with Xcamcen, Ycamcen</span>
    <span class="c1"># given by user</span>
    <span class="n">onCam_cond</span> <span class="o">=</span> <span class="n">Xcam</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Ycam</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">halfCamdiametersquare</span>
    <span class="c1"># resulting arrays</span>
    <span class="n">oncam_Qx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">Qx</span><span class="p">)</span>
    <span class="n">oncam_Qy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">Qy</span><span class="p">)</span>
    <span class="n">oncam_Qz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">Qz</span><span class="p">)</span>

    <span class="n">oncam_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">oncam_Qx</span><span class="p">,</span> <span class="n">oncam_Qy</span><span class="p">,</span> <span class="n">oncam_Qz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">oncam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_H</span><span class="p">)</span>
    <span class="n">oncam_K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_K</span><span class="p">)</span>
    <span class="n">oncam_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_L</span><span class="p">)</span>
    <span class="n">oncam_HKL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">oncam_H</span><span class="p">,</span> <span class="n">oncam_K</span><span class="p">,</span> <span class="n">oncam_L</span><span class="p">]))</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">oncam_vec</span><span class="p">],</span> <span class="p">[</span><span class="n">oncam_HKL</span><span class="p">]</span>


<div class="viewcode-block" id="filterLaueSpots"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.filterLaueSpots">[docs]</a><span class="k">def</span> <span class="nf">filterLaueSpots</span><span class="p">(</span><span class="n">vec_and_indices</span><span class="p">,</span> <span class="n">HarmonicsRemoval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">,</span>
                                    <span class="n">fileOK</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">detectordistance</span><span class="o">=</span><span class="n">DEFAULT_DETECTOR_DISTANCE</span><span class="p">,</span>
                                    <span class="n">detectordiameter</span><span class="o">=</span><span class="n">DEFAULT_DETECTOR_DIAMETER</span><span class="p">,</span>
                                    <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                    <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                                    <span class="n">linestowrite</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;&quot;</span><span class="p">]]):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculates list of grains spots on camera and without harmonics</span>
<span class="sd">    and on CCD camera from [[spots grain 0],[spots grain 1],etc] =&gt;</span>
<span class="sd">    returns [[spots grain 0],[spots grain 1],etc] w / o harmonics and on camera  CCD</span>

<span class="sd">    :param vec_and_indices: list of elements corresponding to 1 grain, each element is composed by</span>
<span class="sd">        * [0] array of vector</span>

<span class="sd">        * [1] array of indices</span>

<span class="sd">    :param HarmonicsRemoval: 1, removes harmonics according to their miller indices</span>
<span class="sd">        (only for fastcompute = 0)</span>

<span class="sd">    :param fastcompute:</span>
<span class="sd">        * 1, outputs a list for each grain of 2theta spots and a list for each grain of chi spots</span>
<span class="sd">            (HARMONICS spots are still HERE!)</span>
<span class="sd">        * 0, outputs list for each grain of spots with</span>

<span class="sd">    :param kf_direction: label for detection geometry (CCD plane with respect to the incoming beam and sample)</span>
<span class="sd">    :type kf_direction: string</span>

<span class="sd">    :return:</span>
<span class="sd">        * list of spot instances if fastcompute=0</span>

<span class="sd">        * 2theta, chi          if fastcompute=1</span>

<span class="sd">    .. note::</span>
<span class="sd">        * USED IMPORTANTLY in lauecore.SimulateResults  lauecore.SimulateLaue</span>
<span class="sd">        * USED in matchingrate.AngularResidues</span>
<span class="sd">        * USED in ParametricLaueSimulator.dosimulation_parametric</span>
<span class="sd">        * USED in AutoindexationGUI.OnSimulate_S3, DetectorCalibration.Reckon_2pts, and others</span>

<span class="sd">    .. todo::</span>
<span class="sd">        add dim in create_spot in various geometries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print(&quot;filterLaueSpots !!!!!&quot;)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Qvectors_list</span><span class="p">,</span> <span class="n">HKLs_list</span> <span class="o">=</span> <span class="n">vec_and_indices</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vec_and_indices has not two elements!&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">nbofgrains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Qvectors_list</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Qvectors_list is not a iterable !&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Qvectors_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;first element of Qvectors_list is not surprisingly an array&quot;</span><span class="p">)</span>

    <span class="c1"># preparing list of results</span>
    <span class="k">if</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ListSpots_Oncam_wo_harmonics</span> <span class="o">=</span> <span class="n">emptylists</span><span class="p">(</span><span class="n">nbofgrains</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Oncam2theta</span> <span class="o">=</span> <span class="n">emptylists</span><span class="p">(</span><span class="n">nbofgrains</span><span class="p">)</span>
        <span class="n">Oncamchi</span> <span class="o">=</span> <span class="n">emptylists</span><span class="p">(</span><span class="n">nbofgrains</span><span class="p">)</span>

    <span class="c1"># loop over grains</span>
    <span class="n">totalnbspots</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">grainindex</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nbofgrains</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">Qx</span> <span class="o">=</span> <span class="n">Qvectors_list</span><span class="p">[</span><span class="n">grainindex</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>
            <span class="n">Qy</span> <span class="o">=</span> <span class="n">Qvectors_list</span><span class="p">[</span><span class="n">grainindex</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>
            <span class="n">Qz</span> <span class="o">=</span> <span class="n">Qvectors_list</span><span class="p">[</span><span class="n">grainindex</span><span class="p">][:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Qvectors_list</span><span class="p">[</span><span class="n">grainindex</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;vec_and_indices has not the proper shape&quot;</span><span class="p">)</span>

        <span class="n">Qsquare</span> <span class="o">=</span> <span class="n">Qx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Qy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Qz</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># corresponding Ewald sphere radius for each spots</span>
        <span class="c1"># (proportional to photons Energy)</span>
        <span class="n">Rewald</span> <span class="o">=</span> <span class="n">Qsquare</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qx</span><span class="p">)</span>

        <span class="c1"># Kf direction selection</span>
        <span class="k">if</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Z&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># top reflection geometry</span>
            <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">Qz</span>
            <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
            <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Y&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># side reflection geometry (for detector between the GMT hutch door and the sample (beam coming from right to left)</span>
            <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">Qy</span>
            <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
            <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qz</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Y&lt;0&quot;</span><span class="p">:</span>  <span class="c1"># other side reflection</span>
            <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
            <span class="n">Xcam</span> <span class="o">=</span> <span class="o">-</span><span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
            <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;X&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># transmission geometry</span>
            <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
            <span class="n">Xcam</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
            <span class="n">Ycam</span> <span class="o">=</span> <span class="o">-</span><span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;X&lt;0&quot;</span><span class="p">:</span>  <span class="c1"># back reflection geometry</span>
            <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Qx</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
            <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
            <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">Qz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;4PI&quot;</span><span class="p">:</span>  <span class="c1"># to keep all scattered spots</span>
            <span class="n">Xcam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
            <span class="n">Ycam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;kf_direction must be defined by a list of two angles !&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Xcam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
                <span class="n">Ycam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Qy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown laue geometry code for kf_direction parameter&quot;</span><span class="p">)</span>

        <span class="c1">#print(&quot;Xcam, Ycam&quot;,Xcam,Ycam)</span>
        <span class="c1"># print Ycam</span>
        <span class="c1"># print &quot;******************&quot;</span>
        <span class="c1"># On camera filter</span>
        <span class="c1"># print &quot;detectordiameter&quot;, detectordiameter</span>
        <span class="n">halfCamdiametersquare</span> <span class="o">=</span> <span class="p">(</span><span class="n">detectordiameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># TODO: should contain Xcam-Xcamcen (mm) and Ycam-Ycamcen with Xcamcen, Ycamcen</span>
        <span class="c1"># given by user</span>
        <span class="n">onCam_cond</span> <span class="o">=</span> <span class="n">Xcam</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Ycam</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">halfCamdiametersquare</span>

        <span class="c1">#print(&#39;onCam_cond&#39;,onCam_cond)</span>
        <span class="c1">#print(&#39;onCam_cond   true&#39;,np.where(onCam_cond==True))</span>
        <span class="c1"># resulting arrays</span>
        <span class="n">oncam_Qx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">Qx</span><span class="p">)</span>
        <span class="n">oncam_Qy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">Qy</span><span class="p">)</span>
        <span class="n">oncam_Qz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">Qz</span><span class="p">)</span>

        <span class="n">oncam_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">oncam_XplusR</span> <span class="o">=</span> <span class="n">oncam_Qx</span> <span class="o">+</span> <span class="n">oncam_R</span>

        <span class="c1"># compute 2theta, chi  (in radians)</span>
        <span class="n">oncam_2theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">oncam_XplusR</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">oncam_XplusR</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">oncam_Qy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">oncam_Qz</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1">#print(&#39;oncam_2theta&#39;,oncam_2theta)</span>
        <span class="c1"># be careful of the of sign</span>
        <span class="n">oncam_chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">oncam_Qy</span> <span class="o">/</span> <span class="n">oncam_Qz</span><span class="p">)</span>
        <span class="c1">#         oncam_chi = np.arctan2(1. * oncam_Qy, oncam_Qz)</span>
        <span class="c1"># TODO: replace by arctan2(1. * oncam_Qy ,oncam_Qz) ??</span>

        <span class="c1">#        print &quot;oncam_2theta&quot;, oncam_2theta</span>
        <span class="c1">#        print &quot;oncam_chi&quot;, oncam_chi</span>
        <span class="c1">#        print &quot;len(oncam)&quot;, len(oncam_2theta)</span>

        <span class="c1"># creates spot instances which takes some times...</span>
        <span class="c1"># will compute spots on the camera</span>
        <span class="c1"># (if HarmonicsRemoval = 0 harmonics still exist)</span>
        <span class="c1"># (if HarmonicsRemoval = 1 harmonics are removed, fundamentals are kept)</span>
        <span class="c1"># (those of lowest energy)</span>
        <span class="k">if</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">indi_H</span> <span class="o">=</span> <span class="n">HKLs_list</span><span class="p">[</span><span class="n">grainindex</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">indi_K</span> <span class="o">=</span> <span class="n">HKLs_list</span><span class="p">[</span><span class="n">grainindex</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">indi_L</span> <span class="o">=</span> <span class="n">HKLs_list</span><span class="p">[</span><span class="n">grainindex</span><span class="p">][:,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">HKLs_list</span><span class="p">[</span><span class="n">grainindex</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;HKLs_list must be a list of array of 3D vectors&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">emsg</span><span class="p">)</span>

            <span class="n">oncam_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">oncam_Qx</span><span class="p">,</span> <span class="n">oncam_Qy</span><span class="p">,</span> <span class="n">oncam_Qz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># print(&#39;onCam_cond&#39;, onCam_cond)</span>
            <span class="n">oncam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_H</span><span class="p">)</span>
            <span class="n">oncam_K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_K</span><span class="p">)</span>
            <span class="n">oncam_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_L</span><span class="p">)</span>
            <span class="n">oncam_HKL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">oncam_H</span><span class="p">,</span> <span class="n">oncam_K</span><span class="p">,</span> <span class="n">oncam_L</span><span class="p">]))</span>

            <span class="c1"># build list of spot objects</span>
            <span class="n">listspot</span> <span class="o">=</span> <span class="n">get2ThetaChi_geometry</span><span class="p">(</span><span class="n">oncam_vec</span><span class="p">,</span>
                                            <span class="n">oncam_HKL</span><span class="p">,</span>
                                            <span class="n">detectordistance</span><span class="o">=</span><span class="n">detectordistance</span><span class="p">,</span>
                                            <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                            <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                                            <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">)</span>
            <span class="c1">#print(&quot;listspot&quot;, listspot)</span>
            <span class="c1"># print(&quot;oncam_HKL&quot;, oncam_HKL.tolist())</span>
            <span class="c1"># Creating list of spot with or without harmonics</span>
            <span class="k">if</span> <span class="n">HarmonicsRemoval</span> <span class="ow">and</span> <span class="n">listspot</span><span class="p">:</span>
                <span class="c1"># ListSpots_Oncam_wo_harmonics[grainindex] = RemoveHarmonics(listspot)</span>
                <span class="c1"># (oncam_HKL_filtered, toremove)</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">toremove</span><span class="p">)</span> <span class="o">=</span> <span class="n">CP</span><span class="o">.</span><span class="n">FilterHarmonics_2</span><span class="p">(</span><span class="n">oncam_HKL</span><span class="p">,</span> <span class="n">return_indices_toremove</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">#print(&#39;toremove&#39;,toremove)</span>
                <span class="n">listspot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listspot</span><span class="p">),</span> <span class="n">toremove</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># feeding final list of spots</span>
            <span class="n">ListSpots_Oncam_wo_harmonics</span><span class="p">[</span><span class="n">grainindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">listspot</span>

            <span class="k">if</span> <span class="n">listspot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">totalnbspots</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">listspot</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fileOK</span><span class="p">:</span>
                <span class="n">IOLT</span><span class="o">.</span><span class="n">Writefile_data_log</span><span class="p">(</span><span class="n">ListSpots_Oncam_wo_harmonics</span><span class="p">[</span><span class="n">grainindex</span><span class="p">],</span>
                                        <span class="n">grainindex</span><span class="p">,</span>
                                        <span class="n">linestowrite</span><span class="o">=</span><span class="n">linestowrite</span><span class="p">)</span>

            <span class="c1"># print &quot;Number of spot in camera w / o harmonics&quot;,len(ListSpots_Oncam_wo_harmonics[grainindex])</span>

        <span class="c1"># (fastcompute = 1) no instantiation of spot object</span>
        <span class="c1"># will return 2theta, chi for each grain</span>
        <span class="c1"># no harmonics removal</span>
        <span class="k">elif</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Oncam2theta</span><span class="p">[</span><span class="n">grainindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">oncam_2theta</span>
            <span class="n">Oncamchi</span><span class="p">[</span><span class="n">grainindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">oncam_chi</span>

            <span class="n">totalnbspots</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oncam_2theta</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;total number of spots for all the </span><span class="si">%d</span><span class="s1"> grain(s) in filterLaueSpots:  &#39;</span><span class="o">%</span><span class="n">nbofgrains</span><span class="p">,</span> <span class="n">totalnbspots</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">totalnbspots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1"># outputs and returns</span>
    <span class="k">if</span> <span class="n">fileOK</span><span class="p">:</span>
        <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">])</span>
        <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;--------------------------------------------------------&quot;</span><span class="p">])</span>
        <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;------------- Simulation Data --------------------------&quot;</span><span class="p">])</span>
        <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;--------------------------------------------------------&quot;</span><span class="p">])</span>
        <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">])</span>
        <span class="n">linestowrite</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;#grain, h, k, l, energy(keV), 2theta (deg), chi (deg), X_Xmas, Y_Xmas, X_JSM, Y_JSM, Xtest, Ytest&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># list of elements which are list of objects of spot class (1 element / grain)</span>
        <span class="k">return</span> <span class="n">ListSpots_Oncam_wo_harmonics</span>
    <span class="k">elif</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># list of elements which are composed by two arrays (2theta, chi) (1 element / grain)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">Oncam2theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">Oncamchi</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">filterLaueSpots_full_np</span><span class="p">(</span><span class="n">veccoord</span><span class="p">,</span> <span class="n">indicemiller</span><span class="p">,</span> <span class="n">onlyXYZ</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">HarmonicsRemoval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                        <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">,</span>
                                                        <span class="n">detectordistance</span><span class="o">=</span><span class="n">DEFAULT_DETECTOR_DISTANCE</span><span class="p">,</span>
                                                        <span class="n">detectordiameter</span><span class="o">=</span><span class="n">DEFAULT_DETECTOR_DIAMETER</span><span class="p">,</span>
                                                        <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                        <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                                                        <span class="n">grainindex</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculates spots data for an individual grain</span>
<span class="sd">    on camera and without harmonics</span>
<span class="sd">    and on CCD camera</span>

<span class="sd">    :param veccoord : list of elements corresponding to 1 grain,</span>
<span class="sd">                    each element is composed by: array of q vector [Qx,Qy,Qz]</span>
<span class="sd">    :param indicemiller : list of Miller indices [h,k,l] array of indices</span>

<span class="sd">    :param HarmonicsRemoval: 1 removes harmonics according to their miller indices</span>
<span class="sd">                            (only for fastcompute = 0)</span>

<span class="sd">    :param fastcompute:  1 output a list for each grain of 2theta spots and a list for each grain of chi spots</span>
<span class="sd">                            (HARMONICS spots are still HERE!)</span>
<span class="sd">                           0 output list for each grain of spots with</span>


<span class="sd">    :param kf_direction: label for detection geometry</span>
<span class="sd">                    (CCD plane with respect to</span>
<span class="sd">                    the incoming beam and sample)</span>
<span class="sd">    :type kf_direction: string</span>

<span class="sd">    :return: tuple of lists of Twtheta Chi Energy Millers if fastcompute=0</span>

<span class="sd">                tuple of lists 2theta, chi          if fastcompute=1</span>

<span class="sd">    .. warning::</span>
<span class="sd">        NOT USED  (only tentatively on matching rate)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">VecX</span> <span class="o">=</span> <span class="n">veccoord</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="n">VecY</span> <span class="o">=</span> <span class="n">veccoord</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="n">VecZ</span> <span class="o">=</span> <span class="n">veccoord</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>

    <span class="n">Vecsquare</span> <span class="o">=</span> <span class="n">VecX</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">VecY</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">VecZ</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1"># correspondinf Ewald sphere radius for each spots</span>
    <span class="c1"># (proportional to photons Energy)</span>
    <span class="n">Rewald</span> <span class="o">=</span> <span class="n">Vecsquare</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">VecX</span><span class="p">)</span>

    <span class="c1"># Kf direction selection</span>
    <span class="k">if</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Z&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># top reflection geometry</span>
        <span class="c1"># VecZ is &gt;0</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">VecZ</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecX</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecY</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Y&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># side reflection geometry (for detector between the GMT hutch door and the sample (beam coming from right to left)</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">VecY</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecX</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecZ</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;Y&lt;0&quot;</span><span class="p">:</span>  <span class="c1"># other side reflection</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">VecY</span><span class="p">)</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="o">-</span><span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecX</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecZ</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;X&gt;0&quot;</span><span class="p">:</span>  <span class="c1"># transmission geometry</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">VecX</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecY</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="o">-</span><span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecZ</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;X&lt;0&quot;</span><span class="p">:</span>  <span class="c1"># back reflection geometry</span>
        <span class="c1"># pos0 = np.where(np.abs(VecX + Rewald) &lt; 0.0000000001)</span>
        <span class="c1"># print(&#39;pos0&#39;, pos0)</span>
        <span class="c1"># print(VecX[pos0])</span>
        <span class="c1"># print(Rewald[pos0])</span>
        <span class="c1"># if VecX +Rewald = 0 then kf is // z axis</span>
        <span class="c1"># peaks are likely not to be intercepted bt detector plane</span>
        <span class="c1"># except if plane is</span>
        <span class="n">ratiod</span> <span class="o">=</span> <span class="n">detectordistance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">VecX</span> <span class="o">+</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecY</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">ratiod</span> <span class="o">*</span> <span class="p">(</span><span class="n">VecZ</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kf_direction</span> <span class="o">==</span> <span class="s2">&quot;4PI&quot;</span><span class="p">:</span>  <span class="c1"># to keep all scattered spots</span>
        <span class="n">Xcam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">VecY</span><span class="p">)</span>
        <span class="n">Ycam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">VecY</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kf_direction</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kf_direction must be defined by a list of two angles !&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xcam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">VecY</span><span class="p">)</span>
            <span class="n">Ycam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">VecY</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown laue geometry code for kf_direction parameter&quot;</span><span class="p">)</span>

    <span class="c1"># print &quot;Xcam, Ycam&quot;,Xcam</span>
    <span class="c1"># print Ycam</span>
    <span class="c1"># ----------------------------------------------------------</span>
    <span class="c1"># Approximate selection of spots in camera accroding to Xcam and Ycam</span>
    <span class="c1"># onCam_cond  conditions</span>
    <span class="c1"># ------------------------------------------------------------</span>

    <span class="c1"># print &quot;******************&quot;</span>
    <span class="c1"># On camera filter</span>
    <span class="c1"># print &quot;detectordiameter&quot;, detectordiameter</span>
    <span class="n">halfCamdiametersquare</span> <span class="o">=</span> <span class="p">(</span><span class="n">detectordiameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="c1"># TODO: should contain Xcam-Xcamcen (mm) and Ycam-Ycamcen with Xcamcen, Ycamcen</span>
    <span class="c1"># given by user</span>
    <span class="n">onCam_cond</span> <span class="o">=</span> <span class="n">Xcam</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Ycam</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">halfCamdiametersquare</span>
    <span class="c1"># resulting arrays</span>
    <span class="n">oncam_vecX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">VecX</span><span class="p">)</span>
    <span class="n">oncam_vecY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">VecY</span><span class="p">)</span>
    <span class="n">oncam_vecZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">VecZ</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">onlyXYZ</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">oncam_vecX</span><span class="p">,</span> <span class="n">oncam_vecY</span><span class="p">,</span> <span class="n">oncam_vecZ</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># creates spot instances which takes some times...</span>
    <span class="c1"># will compute spots on the camera</span>
    <span class="c1"># (if HarmonicsRemoval = 0 harmonics still exist)</span>
    <span class="c1"># (if HarmonicsRemoval = 1 harmonics are removed, fundamentals are kept)</span>
    <span class="c1"># (those of lowest energy)</span>
    <span class="k">if</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">indi_H</span> <span class="o">=</span> <span class="n">indicemiller</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">indi_K</span> <span class="o">=</span> <span class="n">indicemiller</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">indi_L</span> <span class="o">=</span> <span class="n">indicemiller</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

        <span class="n">oncam_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">oncam_vecX</span><span class="p">,</span> <span class="n">oncam_vecY</span><span class="p">,</span> <span class="n">oncam_vecZ</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">oncam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_H</span><span class="p">)</span>
        <span class="n">oncam_K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_K</span><span class="p">)</span>
        <span class="n">oncam_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">indi_L</span><span class="p">)</span>
        <span class="n">oncam_HKL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">oncam_H</span><span class="p">,</span> <span class="n">oncam_K</span><span class="p">,</span> <span class="n">oncam_L</span><span class="p">]))</span>

        <span class="c1"># build list of spot objects</span>
        <span class="n">TwthetaChiEnergyMillers_list_one_grain</span> <span class="o">=</span> <span class="n">get2ThetaChi_geometry_full_np</span><span class="p">(</span>
                                                                <span class="n">oncam_vec</span><span class="p">,</span>
                                                                <span class="n">oncam_HKL</span><span class="p">,</span>
                                                                <span class="n">detectordistance</span><span class="o">=</span><span class="n">detectordistance</span><span class="p">,</span>
                                                                <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                                                <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                                                                <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">)</span>

        <span class="c1">#         print &#39;TwthetaChiEnergy_list_one_grain&#39;, TwthetaChiEnergy_list_one_grain</span>
        <span class="c1"># Creating list of spot with or without harmonics</span>
        <span class="k">if</span> <span class="n">HarmonicsRemoval</span> <span class="ow">and</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># listspot:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Harmonic removal is not implemented and listspot does not exist anymore&quot;</span><span class="p">)</span>
            <span class="c1">#                ListSpots_Oncam_wo_harmonics[i] = RemoveHarmonics(listspot)</span>
            <span class="c1"># (oncam_HKL_filtered, toremove) = CP.FilterHarmonics_2(</span>
            <span class="c1">#     oncam_HKL, return_indices_toremove=1</span>
            <span class="c1"># )</span>
            <span class="c1"># listspot = np.delete(np.array(listspot), toremove).tolist()</span>

        <span class="c1"># print &quot;Number of spot in camera w / o harmonics&quot;,len(ListSpots_Oncam_wo_harmonics[i])</span>

    <span class="c1"># (fastcompute = 1) no instantiation of spot object</span>
    <span class="c1"># will return 2theta, chi for each grain</span>
    <span class="c1"># no harmonics removal</span>
    <span class="k">elif</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="n">oncam_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">onCam_cond</span><span class="p">,</span> <span class="n">Rewald</span><span class="p">)</span>
        <span class="n">oncam_XplusR</span> <span class="o">=</span> <span class="n">oncam_vecX</span> <span class="o">+</span> <span class="n">oncam_R</span>
        <span class="c1"># compute 2theta, chi</span>
        <span class="n">oncam_2theta</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">oncam_XplusR</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">oncam_XplusR</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">oncam_vecY</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">oncam_vecZ</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="o">/</span> <span class="n">DEG</span><span class="p">)</span>
        <span class="c1"># be careful of the of sign</span>
        <span class="n">oncam_chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">oncam_vecY</span> <span class="o">/</span> <span class="n">oncam_vecZ</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEG</span>
        <span class="c1">#         oncam_chi = np.arctan2(1. * oncam_vecY, oncam_vecZ)</span>
        <span class="c1"># TODO: replace by arctan2(1. * oncam_vecY ,oncam_vecZ) ??</span>

        <span class="c1">#        print &quot;oncam_2theta&quot;, oncam_2theta</span>
        <span class="c1">#        print &quot;oncam_chi&quot;, oncam_chi</span>
        <span class="c1">#        print &quot;len(oncam)&quot;, len(oncam_2theta)</span>

    <span class="k">if</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># list spots data</span>
        <span class="k">return</span> <span class="n">TwthetaChiEnergyMillers_list_one_grain</span>
    <span class="k">elif</span> <span class="n">fastcompute</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># list of elements which are composed by two arrays (2theta, chi) (1 element / grain)</span>
        <span class="k">return</span> <span class="n">oncam_2theta</span><span class="p">,</span> <span class="n">oncam_chi</span>


<div class="viewcode-block" id="get2ThetaChi_geometry"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.get2ThetaChi_geometry">[docs]</a><span class="k">def</span> <span class="nf">get2ThetaChi_geometry</span><span class="p">(</span><span class="n">oncam_vec</span><span class="p">,</span> <span class="n">oncam_HKL</span><span class="p">,</span> <span class="n">detectordistance</span><span class="o">=</span><span class="n">DEFAULT_DETECTOR_DISTANCE</span><span class="p">,</span>
                                                                <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                                                                <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    computes list of spots instances from oncam_vec (q 3D vectors)</span>
<span class="sd">    and oncam_HKL (miller indices 3D vectors)</span>

<span class="sd">    :param oncam_vec: q vectors [qx,qy,qz] (corresponding to kf collected on camera)</span>
<span class="sd">    :type oncam_vec: array with 3D elements (shape = (n,3))</span>

<span class="sd">    :param dim: CCD frame dimensions (nb pixels, nb pixels)</span>
<span class="sd">    :type dim: list or tuple of 2 integers</span>

<span class="sd">    :param detectordistance: approximate distance detector sample</span>
<span class="sd">    :param detectordistance: float or integer</span>

<span class="sd">    :param: kf_direction : label for detection geometry</span>
<span class="sd">                    (CCD plane with respect to</span>
<span class="sd">                    the incoming beam and sample)</span>
<span class="sd">    :type: kf_direction: string</span>

<span class="sd">    :param pixelsize: pixel size in mm</span>
<span class="sd">    :type pixelsize: float</span>

<span class="sd">    :return: list of spot instances</span>

<span class="sd">    .. note::</span>
<span class="sd">        USED in lauecore.filterLaueSpots</span>

<span class="sd">    .. todo::</span>
<span class="sd">        * to be replaced by something else not using spot class</span>
<span class="sd">        * put this function in LaueGeometry module ?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oncam_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oncam_HKL</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong input for get2ThetaChi_geometry()&quot;</span><span class="p">)</span>

    <span class="n">listspot</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">options_createspot</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;allattributes&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;pixelsize&quot;</span><span class="p">:</span> <span class="n">pixelsize</span><span class="p">,</span> <span class="s2">&quot;dim&quot;</span><span class="p">:</span> <span class="n">dim</span><span class="p">}</span>

    <span class="n">dictcase</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Z&gt;0&quot;</span><span class="p">:</span> <span class="n">create_spot</span><span class="p">,</span>
                <span class="s2">&quot;Y&gt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_side_pos</span><span class="p">,</span>
                <span class="s2">&quot;Y&lt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_side_neg</span><span class="p">,</span>
                <span class="s2">&quot;X&gt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_front</span><span class="p">,</span>
                <span class="s2">&quot;X&lt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_back</span><span class="p">,</span>
                <span class="s2">&quot;4PI&quot;</span><span class="p">:</span> <span class="n">create_spot_4pi</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">oncam_vec</span><span class="p">,</span> <span class="n">oncam_HKL</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">function_create_spot</span> <span class="o">=</span> <span class="n">dictcase</span><span class="p">[</span><span class="n">kf_direction</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">function_create_spot</span> <span class="o">=</span> <span class="n">create_spot_4pi</span>

        <span class="n">spotcreated</span> <span class="o">=</span> <span class="n">function_create_spot</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">options_createspot</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spotcreated</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">listspot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spotcreated</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">listspot</span></div>


<span class="k">def</span> <span class="nf">get2ThetaChi_geometry_full_np</span><span class="p">(</span><span class="n">oncam_vec</span><span class="p">,</span> <span class="n">oncam_HKL</span><span class="p">,</span> <span class="n">detectordistance</span><span class="o">=</span><span class="n">DEFAULT_DETECTOR_DISTANCE</span><span class="p">,</span>
                                                                <span class="n">pixelsize</span><span class="o">=</span><span class="mf">165.0</span> <span class="o">/</span> <span class="mi">2048</span><span class="p">,</span>
                                                                <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                                                                <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    computes 2theta chi from oncam_vec (only 3D Q vectors corresponding to reflections on camera)</span>
<span class="sd">    and oncam_HKL (miller indices 3D vectors) for all spots of one grain</span>

<span class="sd">    :param oncam_vec: q vectors [qx,qy,qz] (corresponding to kf collected on camera)</span>
<span class="sd">    :type oncam_vec: array with 3D elements (shape = (n,3))</span>

<span class="sd">    :param dim: CCD frame dimensions (nb pixels, nb pixels)</span>
<span class="sd">    :type dim: list or tuple of 2 integers</span>

<span class="sd">    :param detectordistance: approximate distance detector sample</span>
<span class="sd">    :param detectordistance: float or integer</span>

<span class="sd">    :param: kf_direction: label for detection geometry</span>
<span class="sd">                    (CCD plane with respect to</span>
<span class="sd">                    the incoming beam and sample)</span>
<span class="sd">    :type: kf_direction: string</span>

<span class="sd">    :param pixelsize: pixel size in mm</span>
<span class="sd">    :type pixelsize: float</span>

<span class="sd">    :return: list of spot</span>

<span class="sd">    .. note::</span>
<span class="sd">        * USED in lauecore.filterLaueSpots_full_np</span>

<span class="sd">    .. todo::</span>
<span class="sd">        * Only geometry Z&gt;0 (top reflection) and X&gt;0 (transmission) are vectorized by numpy</span>
<span class="sd">        * TODO: put this function obviously in find2thetachi ?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oncam_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oncam_HKL</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong input for get2ThetaChi_geometry_full_np()&quot;</span><span class="p">)</span>

    <span class="c1"># TwthetaChiEnergy_list = []</span>
    <span class="n">options_createspot</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;allattributes&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;pixelsize&quot;</span><span class="p">:</span> <span class="n">pixelsize</span><span class="p">,</span> <span class="s2">&quot;dim&quot;</span><span class="p">:</span> <span class="n">dim</span><span class="p">}</span>

    <span class="n">dictcase</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Z&gt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_np</span><span class="p">,</span>
                <span class="s2">&quot;Y&gt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_side_pos</span><span class="p">,</span>
                <span class="s2">&quot;Y&lt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_side_neg</span><span class="p">,</span>
                <span class="s2">&quot;X&gt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_np</span><span class="p">,</span>
                <span class="s2">&quot;X&lt;0&quot;</span><span class="p">:</span> <span class="n">create_spot_np</span><span class="p">,</span> <span class="c1">#create_spot_back,</span>
                <span class="s2">&quot;4PI&quot;</span><span class="p">:</span> <span class="n">create_spot_4pi</span><span class="p">}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">function_create_spot</span> <span class="o">=</span> <span class="n">dictcase</span><span class="p">[</span><span class="n">kf_direction</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">function_create_spot</span> <span class="o">=</span> <span class="n">create_spot_4pi</span>

    <span class="n">TwthetaChiEnergyMillers_list</span> <span class="o">=</span> <span class="n">function_create_spot</span><span class="p">(</span>
        <span class="n">oncam_vec</span><span class="p">,</span> <span class="n">oncam_HKL</span><span class="p">,</span> <span class="n">detectordistance</span><span class="p">,</span> <span class="o">**</span><span class="n">options_createspot</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TwthetaChiEnergyMillers_list</span>


<span class="k">def</span> <span class="nf">RemoveHarmonics</span><span class="p">(</span><span class="n">listspot</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    removes harmonics present in listspot (list of objects of spot class)</span>

<span class="sd">    .. todo:: NOT USED ANYMORE!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_invdict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># print &quot;len after sorting wtih respect to __hash__()&quot;,len(sorted(listspot, reverse = True))</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">listspot</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># print &quot;elem, elem.__hash__()&quot;,elem.Millers, elem.__hash__()</span>

        <span class="n">_invdict</span><span class="p">[</span><span class="n">elem</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()]</span> <span class="o">=</span> <span class="n">elem</span>
        <span class="n">_oncamsansh</span> <span class="o">=</span> <span class="p">[</span><span class="n">_invdict</span><span class="p">[</span><span class="n">cle</span><span class="p">]</span> <span class="k">for</span> <span class="n">cle</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">_invdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>

    <span class="c1"># print &quot;Number of fundamental spots (RS directions): %d&quot;%len(_oncamsansh)</span>
    <span class="k">return</span> <span class="n">_oncamsansh</span>


<div class="viewcode-block" id="calcSpots_fromHKLlist"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.calcSpots_fromHKLlist">[docs]</a><span class="k">def</span> <span class="nf">calcSpots_fromHKLlist</span><span class="p">(</span><span class="n">UB</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">HKL</span><span class="p">,</span> <span class="n">dictCCD</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    computes all Laue Spots properties on 2D detector from a list of hkl</span>
<span class="sd">    (given structure by B0 matrix, orientation by UB matrix, and detector geometry by dictCCD)</span>

<span class="sd">    :param UB: orientation matrix (rotation -and if any- strain)</span>
<span class="sd">    :type UB: 3x3 array (or list)</span>

<span class="sd">    :param B0: initial a*,b*,c* reciprocal unit cell basis vector in Lauetools frame (x// ki))</span>
<span class="sd">    :type B0: 3x3 array (or list)</span>

<span class="sd">    :param HKL: array of Miller indices</span>
<span class="sd">    :type HKL: array with shape = (n,3)</span>

<span class="sd">    :param dictCCD: dictionnary of CCD properties (with key &#39;CCDparam&#39;, &#39;pixelsize&#39;,&#39;dim&#39;)</span>
<span class="sd">        for &#39;ccdparam&#39; 5 CCD calibration parameters [dd,xcen,ycen,xbet,xgam], pixelsize in mm, and (dim1, dim2)</span>
<span class="sd">    :param dictCCD: dict object</span>

<span class="sd">    :returns: list of arrays H, K, L, Qx, Qy, Qz, X, Y, twthe, chi, Energy</span>

<span class="sd">    Fundamental equation</span>
<span class="sd">    :math:`{\bf q} = UB*B0 * {\bf G^*}`</span>
<span class="sd">    with :math:`{\bf G^*} = h{\bf a^*}+k{\bf b^*}+l{\bf c^*}`</span>

<span class="sd">    .. note::</span>
<span class="sd">        USED in DetectorCalibration.OnWriteResults, and PlotRefineGUI.onWriteFitFile</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">detectorparam</span> <span class="o">=</span> <span class="n">dictCCD</span><span class="p">[</span><span class="s2">&quot;CCDparam&quot;</span><span class="p">]</span>
    <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">dictCCD</span><span class="p">[</span><span class="s2">&quot;pixelsize&quot;</span><span class="p">]</span>
    <span class="c1"># dim = dictCCD[&quot;dim&quot;]</span>
    <span class="k">if</span> <span class="s2">&quot;kf_direction&quot;</span> <span class="ow">in</span> <span class="n">dictCCD</span><span class="p">:</span>
        <span class="n">kf_direction</span> <span class="o">=</span> <span class="n">dictCCD</span><span class="p">[</span><span class="s2">&quot;kf_direction&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kf_direction</span> <span class="o">=</span> <span class="s2">&quot;Z&gt;0&quot;</span>

    <span class="c1"># H,K,L</span>
    <span class="n">tHKL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">HKL</span><span class="p">)</span>

    <span class="c1"># initial lattice rotation and distorsion</span>

    <span class="n">tQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">UB</span><span class="p">,</span> <span class="n">B0</span><span class="p">),</span> <span class="n">tHKL</span><span class="p">)</span>
    <span class="c1"># results are qx,qy,qz</span>

    <span class="c1"># Q**2</span>
    <span class="n">Qsquare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tQ</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># norms of Q vectors</span>
    <span class="n">Qn</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Qsquare</span><span class="p">)</span>

    <span class="n">twthe</span><span class="p">,</span> <span class="n">chi</span> <span class="o">=</span> <span class="n">LTGeo</span><span class="o">.</span><span class="n">from_qunit_to_twchi</span><span class="p">(</span><span class="n">tQ</span> <span class="o">/</span> <span class="n">Qn</span><span class="p">,</span> <span class="n">labXMAS</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">LTGeo</span><span class="o">.</span><span class="n">calc_xycam_from2thetachi</span><span class="p">(</span><span class="n">twthe</span><span class="p">,</span>
                                                <span class="n">chi</span><span class="p">,</span>
                                                <span class="n">detectorparam</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                                <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">)</span>

    <span class="c1"># E = (C)*(-q**2/qx/2)</span>
    <span class="n">Energy</span> <span class="o">=</span> <span class="p">(</span><span class="n">CST_ENERGYKEV</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">Qsquare</span> <span class="o">/</span> <span class="n">tQ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># theoretical values</span>
    <span class="n">H</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">tHKL</span>
    <span class="n">Qx</span><span class="p">,</span> <span class="n">Qy</span><span class="p">,</span> <span class="n">Qz</span> <span class="o">=</span> <span class="n">tQ</span>

    <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Qx</span><span class="p">,</span> <span class="n">Qy</span><span class="p">,</span> <span class="n">Qz</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">twthe</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">Energy</span></div>


<span class="k">def</span> <span class="nf">emptylists</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    builds a list of n empty lists : [[],[],[], ...,[]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))]</span>


<span class="k">def</span> <span class="nf">SimulateLaue_merge</span><span class="p">(</span>
    <span class="n">grains</span><span class="p">,</span>
    <span class="n">emin</span><span class="p">,</span>
    <span class="n">emax</span><span class="p">,</span>
    <span class="n">detectorparameters</span><span class="p">,</span>
    <span class="n">only_2thetachi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">output_nb_spots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">,</span>
    <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">removeharmonics</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">pixelsize</span><span class="o">=</span><span class="mi">165</span> <span class="o">/</span> <span class="mf">2048.0</span><span class="p">,</span>
    <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
    <span class="n">detectordiameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dict_Materials</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates Laue pattern full data from a list of grains and concatenate results data</span>

<span class="sd">    :param grains: list of 4 elements grain parameters</span>

<span class="sd">    :param only_2thetachi: * True, return only concatenated grains data 2theta and chi,</span>
<span class="sd">                           * False, return All_Twicetheta, All_Chi, All_Miller_ind,</span>
<span class="sd">                                    All_posx, All_posy, All_Energy</span>

<span class="sd">    :param output_nb_spots: * True, output a second element (in addition to data)</span>
<span class="sd">                            with list of partial nb of spots per grain</span>
<span class="sd">                            (to know the grain origin of spots)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># use SimulateLaue</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">only_2thetachi</span><span class="p">:</span>
        <span class="n">All_Twicetheta</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">All_Chi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">All_Miller_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">All_posx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">All_posy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">All_Energy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">All_nb_spots</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">grain</span> <span class="ow">in</span> <span class="n">grains</span><span class="p">:</span>
            <span class="p">(</span><span class="n">Twicetheta</span><span class="p">,</span> <span class="n">Chi</span><span class="p">,</span> <span class="n">Miller_ind</span><span class="p">,</span> <span class="n">posx</span><span class="p">,</span> <span class="n">posy</span><span class="p">,</span> <span class="n">Energy</span><span class="p">)</span> <span class="o">=</span> <span class="n">SimulateLaue</span><span class="p">(</span>
                <span class="n">grain</span><span class="p">,</span>
                <span class="n">emin</span><span class="p">,</span>
                <span class="n">emax</span><span class="p">,</span>
                <span class="n">detectorparameters</span><span class="p">,</span>
                <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="n">ResolutionAngstrom</span><span class="p">,</span>
                <span class="n">removeharmonics</span><span class="o">=</span><span class="n">removeharmonics</span><span class="p">,</span>
                <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">detectordiameter</span><span class="o">=</span><span class="n">detectordiameter</span><span class="p">,</span>
                <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>

            <span class="n">nb_spots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Twicetheta</span><span class="p">)</span>

            <span class="n">All_Twicetheta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Twicetheta</span><span class="p">)</span>
            <span class="n">All_Chi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Chi</span><span class="p">)</span>
            <span class="n">All_Miller_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Miller_ind</span><span class="p">)</span>
            <span class="n">All_posx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">posx</span><span class="p">)</span>
            <span class="n">All_posy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">posy</span><span class="p">)</span>
            <span class="n">All_Energy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Energy</span><span class="p">)</span>
            <span class="n">All_nb_spots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nb_spots</span><span class="p">)</span>

        <span class="n">All_Twicetheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">All_Twicetheta</span><span class="p">)</span>
        <span class="n">All_Chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">All_Chi</span><span class="p">)</span>
        <span class="n">All_Miller_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">All_Miller_ind</span><span class="p">)</span>
        <span class="n">All_posx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">All_posx</span><span class="p">)</span>
        <span class="n">All_posy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">All_posy</span><span class="p">)</span>
        <span class="n">All_Energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">All_Energy</span><span class="p">)</span>

        <span class="n">toreturn</span> <span class="o">=</span> <span class="p">(</span><span class="n">All_Twicetheta</span><span class="p">,</span>
                    <span class="n">All_Chi</span><span class="p">,</span>
                    <span class="n">All_Miller_ind</span><span class="p">,</span>
                    <span class="n">All_posx</span><span class="p">,</span>
                    <span class="n">All_posy</span><span class="p">,</span>
                    <span class="n">All_Energy</span><span class="p">)</span>

    <span class="c1"># Use SimulateResult</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">simulparameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">simulparameters</span><span class="p">[</span><span class="s2">&quot;detectordiameter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectordiameter</span>
        <span class="n">simulparameters</span><span class="p">[</span><span class="s2">&quot;kf_direction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kf_direction</span>
        <span class="n">simulparameters</span><span class="p">[</span><span class="s2">&quot;detectordistance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectorparameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">simulparameters</span><span class="p">[</span><span class="s2">&quot;pixelsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixelsize</span>

        <span class="n">All_TwicethetaChi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">All_nb_spots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">grain</span> <span class="ow">in</span> <span class="n">grains</span><span class="p">:</span>
            <span class="n">TwicethetaChi</span> <span class="o">=</span> <span class="n">SimulateResult</span><span class="p">(</span><span class="n">grain</span><span class="p">,</span>
                                            <span class="n">emin</span><span class="p">,</span>
                                            <span class="n">emax</span><span class="p">,</span>
                                            <span class="n">simulparameters</span><span class="p">,</span>
                                            <span class="n">fastcompute</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                            <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>
            <span class="n">nb_spots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TwicethetaChi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">All_TwicethetaChi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TwicethetaChi</span><span class="p">)</span>
            <span class="n">All_nb_spots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nb_spots</span><span class="p">)</span>

        <span class="n">All_TwicethetaChi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">All_TwicethetaChi</span><span class="p">)</span>

        <span class="n">toreturn</span> <span class="o">=</span> <span class="n">All_TwicethetaChi</span>

    <span class="k">if</span> <span class="n">output_nb_spots</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">toreturn</span><span class="p">,</span> <span class="n">All_nb_spots</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">toreturn</span>


<span class="k">def</span> <span class="nf">SimulateLaue_twins</span><span class="p">(</span><span class="n">grainparent</span><span class="p">,</span> <span class="n">twins_operators</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">,</span> <span class="n">detectorparameters</span><span class="p">,</span>
                                                                <span class="n">only_2thetachi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="n">output_nb_spots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">,</span>
                                                                <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">removeharmonics</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                <span class="n">pixelsize</span><span class="o">=</span><span class="mi">165</span> <span class="o">/</span> <span class="mf">2048.0</span><span class="p">,</span>
                                                                <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                                                                <span class="n">detectordiameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                                <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dict_Materials</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates Laue pattern full data for twinned grain</span>

<span class="sd">    :param grainparent: list of 4 elements grain parameter</span>

<span class="sd">    :param twins_operators: list of 3*3 matrices corresponding of Matrices</span>

<span class="sd">    :param output_nb_spots: True, output a second element with list of partial nb of spots per grain</span>

<span class="sd">    .. note:: USED in test only in detectorCalibration...simulate_theo  to simulate 2 twinned crystals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># nb_twins = len(twins_operators)</span>

    <span class="n">Bmat</span><span class="p">,</span> <span class="n">dilat</span><span class="p">,</span> <span class="n">Umat</span><span class="p">,</span> <span class="n">extinction</span> <span class="o">=</span> <span class="n">grainparent</span>

    <span class="n">grains</span> <span class="o">=</span> <span class="p">[</span><span class="n">grainparent</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">twin_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">twins_operators</span><span class="p">):</span>
        <span class="n">twinUmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Umat</span><span class="p">,</span> <span class="n">twin_op</span><span class="p">)</span>
        <span class="n">grains</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Bmat</span><span class="p">,</span> <span class="n">dilat</span><span class="p">,</span> <span class="n">twinUmat</span><span class="p">,</span> <span class="n">extinction</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">SimulateLaue_merge</span><span class="p">(</span><span class="n">grains</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">,</span> <span class="n">detectorparameters</span><span class="p">,</span> <span class="n">only_2thetachi</span><span class="o">=</span><span class="n">only_2thetachi</span><span class="p">,</span>
                                                            <span class="n">output_nb_spots</span><span class="o">=</span><span class="n">output_nb_spots</span><span class="p">,</span>
                                                            <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                                                            <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="n">ResolutionAngstrom</span><span class="p">,</span>
                                                            <span class="n">removeharmonics</span><span class="o">=</span><span class="n">removeharmonics</span><span class="p">,</span>
                                                            <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                                            <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                                                            <span class="n">detectordiameter</span><span class="o">=</span><span class="n">detectordiameter</span><span class="p">,</span>
                                                            <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>


<div class="viewcode-block" id="SimulateLaue"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.SimulateLaue">[docs]</a><span class="k">def</span> <span class="nf">SimulateLaue</span><span class="p">(</span><span class="n">grain</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">,</span> <span class="n">detectorparameters</span><span class="p">,</span> <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">,</span>
                                                            <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                            <span class="n">removeharmonics</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                            <span class="n">pixelsize</span><span class="o">=</span><span class="mi">165</span> <span class="o">/</span> <span class="mf">2048.0</span><span class="p">,</span>
                                                            <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                                                            <span class="n">detectordiameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                            <span class="n">force_extinction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                            <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dict_Materials</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes Laue Pattern spots positions, scattering angles, miller indices</span>
<span class="sd">                            for a SINGLE grain or Xtal</span>

<span class="sd">    :param grain: crystal parameters made of a 4 elements list</span>
<span class="sd">    :param emin: minimum bandpass energy (keV)</span>
<span class="sd">    :param emax: maximum bandpass energy (keV)</span>

<span class="sd">    :param removeharmonics:</span>
<span class="sd">        * 1, removes harmonics spots and keep fondamental spots (or reciprocal direction)</span>
<span class="sd">            (with lowest Miller indices)</span>

<span class="sd">        * 0 keep all spots (including harmonics)</span>

<span class="sd">    :return: single grain data: Twicetheta, Chi, Miller_ind, posx, posy, Energy</span>

<span class="sd">    .. todo::</span>
<span class="sd">        To update to accept kf_direction not only in reflection geometry</span>

<span class="sd">    .. note::</span>
<span class="sd">        USED in detectorCalibration...simulate_theo  for non routine geometry (ie except Z&gt;0 (reflection top) X&gt;0 (transmission)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">detectordiameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">DETECTORDIAMETER</span> <span class="o">=</span> <span class="n">pixelsize</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">DETECTORDIAMETER</span> <span class="o">=</span> <span class="n">detectordiameter</span>
    <span class="c1"># use DEFAULT_TOP_GEOMETRY &lt;=&gt; kf_direction = &#39;Z&gt;0&#39;</span>

    <span class="c1">#     print &quot;grain&quot;, grain</span>

    <span class="n">key_material</span> <span class="o">=</span> <span class="n">grain</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">grain</span> <span class="o">=</span> <span class="n">CP</span><span class="o">.</span><span class="n">Prepare_Grain</span><span class="p">(</span>
        <span class="n">key_material</span><span class="p">,</span> <span class="n">grain</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">force_extinction</span><span class="o">=</span><span class="n">force_extinction</span><span class="p">,</span> <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>

    <span class="c1">#     print &quot;grain&quot;, grain</span>
    <span class="c1">#     print &quot;grain in SimulateResult()&quot;, grain</span>

    <span class="n">Spots2pi</span> <span class="o">=</span> <span class="n">getLaueSpots</span><span class="p">(</span><span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">emax</span><span class="p">,</span>
                            <span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">emin</span><span class="p">,</span>
                            <span class="p">[</span><span class="n">grain</span><span class="p">],</span>
                            <span class="p">[[</span><span class="s2">&quot;&quot;</span><span class="p">]],</span>
                            <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">fileOK</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                            <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="n">ResolutionAngstrom</span><span class="p">,</span>
                            <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>

    <span class="c1">#     print &quot;len Spots2pi&quot;, len(Spots2pi[0][0])</span>

    <span class="c1"># list of spot which are on camera (with harmonics)</span>
    <span class="n">ListofListofSpots</span> <span class="o">=</span> <span class="n">filterLaueSpots</span><span class="p">(</span><span class="n">Spots2pi</span><span class="p">,</span>
                                            <span class="n">fileOK</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">detectordistance</span><span class="o">=</span><span class="n">detectorparameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                            <span class="n">detectordiameter</span><span class="o">=</span><span class="n">DETECTORDIAMETER</span><span class="p">,</span>
                                            <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                                            <span class="n">HarmonicsRemoval</span><span class="o">=</span><span class="n">removeharmonics</span><span class="p">,</span>
                                            <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span>

    <span class="n">ListofSpots</span> <span class="o">=</span> <span class="n">ListofListofSpots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">Twicetheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spot</span><span class="o">.</span><span class="n">Twicetheta</span> <span class="k">for</span> <span class="n">spot</span> <span class="ow">in</span> <span class="n">ListofSpots</span><span class="p">])</span>
    <span class="n">Chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spot</span><span class="o">.</span><span class="n">Chi</span> <span class="k">for</span> <span class="n">spot</span> <span class="ow">in</span> <span class="n">ListofSpots</span><span class="p">])</span>
    <span class="n">Miller_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">spot</span><span class="o">.</span><span class="n">Millers</span><span class="p">)</span> <span class="k">for</span> <span class="n">spot</span> <span class="ow">in</span> <span class="n">ListofSpots</span><span class="p">])</span>
    <span class="n">Energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spot</span><span class="o">.</span><span class="n">EwaldRadius</span> <span class="o">*</span> <span class="n">CST_ENERGYKEV</span> <span class="k">for</span> <span class="n">spot</span> <span class="ow">in</span> <span class="n">ListofSpots</span><span class="p">])</span>

    <span class="n">posx</span><span class="p">,</span> <span class="n">posy</span> <span class="o">=</span> <span class="n">LTGeo</span><span class="o">.</span><span class="n">calc_xycam_from2thetachi</span><span class="p">(</span><span class="n">Twicetheta</span><span class="p">,</span>
                                                <span class="n">Chi</span><span class="p">,</span>
                                                <span class="n">detectorparameters</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                                <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">Twicetheta</span><span class="p">,</span> <span class="n">Chi</span><span class="p">,</span> <span class="n">Miller_ind</span><span class="p">,</span> <span class="n">posx</span><span class="p">,</span> <span class="n">posy</span><span class="p">,</span> <span class="n">Energy</span></div>


<div class="viewcode-block" id="SimulateLaue_full_np"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.SimulateLaue_full_np">[docs]</a><span class="k">def</span> <span class="nf">SimulateLaue_full_np</span><span class="p">(</span><span class="n">grain</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">,</span> <span class="n">detectorparameters</span><span class="p">,</span> <span class="n">kf_direction</span><span class="o">=</span><span class="n">DEFAULT_TOP_GEOMETRY</span><span class="p">,</span>
                                                                <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">removeharmonics</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                <span class="n">pixelsize</span><span class="o">=</span><span class="mi">165</span> <span class="o">/</span> <span class="mf">2048.0</span><span class="p">,</span>
                                                                <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">),</span>
                                                                <span class="n">detectordiameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                                <span class="n">force_extinction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                                <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dict_Materials</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute Laue Pattern spots positions, scattering angles, miller indices</span>
<span class="sd">                            for a SINGLE grain or Xtal using numpy vectorization</span>

<span class="sd">    :param grain:    crystal parameters in a 4 elements list</span>
<span class="sd">    :param emin: minimum bandpass energy (keV)</span>
<span class="sd">    :param emax: maximum bandpass energy (keV)</span>

<span class="sd">    :param removeharmonics: 1, remove harmonics spots and keep fondamental spots</span>
<span class="sd">                            (with lowest Miller indices)</span>

<span class="sd">    :return: single grain data: Twicetheta, Chi, Miller_ind, posx, posy, Energy</span>

<span class="sd">    .. todo::</span>
<span class="sd">        update to accept kf_direction not only in reflection geometry</span>

<span class="sd">    .. note::</span>
<span class="sd">        USED in detectorCalibration...simulate_theo for routine geometry Z&gt;0 (reflection top) X&gt;0 (transmission)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">detectordiameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">DETECTORDIAMETER</span> <span class="o">=</span> <span class="n">pixelsize</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">DETECTORDIAMETER</span> <span class="o">=</span> <span class="n">detectordiameter</span>
    <span class="c1"># use DEFAULT_TOP_GEOMETRY &lt;=&gt; kf_direction = &#39;Z&gt;0&#39;</span>

    <span class="n">key_material</span> <span class="o">=</span> <span class="n">grain</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">grain</span> <span class="o">=</span> <span class="n">CP</span><span class="o">.</span><span class="n">Prepare_Grain</span><span class="p">(</span><span class="n">key_material</span><span class="p">,</span> <span class="n">grain</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                    <span class="n">force_extinction</span><span class="o">=</span><span class="n">force_extinction</span><span class="p">,</span> <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>

    <span class="c1"># print(&quot;grain in SimulateResult()&quot;, grain)</span>

    <span class="n">Qxyz</span><span class="p">,</span> <span class="n">HKL</span> <span class="o">=</span> <span class="n">getLaueSpots</span><span class="p">(</span><span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">emax</span><span class="p">,</span>
                            <span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">emin</span><span class="p">,</span>
                            <span class="p">[</span><span class="n">grain</span><span class="p">],</span>
                            <span class="p">[[</span><span class="s2">&quot;&quot;</span><span class="p">]],</span>
                            <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">fileOK</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                            <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="n">ResolutionAngstrom</span><span class="p">,</span>
                            <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>

    <span class="c1">#     print &quot;Qxyz&quot;, Qxyz</span>
    <span class="c1">#     print &quot;HKL&quot;, HKL</span>

    <span class="c1"># list of spot which are on camera (with harmonics)</span>
    <span class="n">TwthetaChiEnergyMillers_list_one_grain_wo_harmonics</span> <span class="o">=</span> <span class="n">filterLaueSpots_full_np</span><span class="p">(</span>
                                                <span class="n">Qxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                <span class="n">HKL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="n">detectordistance</span><span class="o">=</span><span class="n">detectorparameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                <span class="n">detectordiameter</span><span class="o">=</span><span class="n">DETECTORDIAMETER</span><span class="p">,</span>
                                                <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                                                <span class="n">HarmonicsRemoval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span>

    <span class="c1">#     print &quot;TwthetaChiEnergyMillers_list_one_grain_wo_harmonics&quot;, TwthetaChiEnergyMillers_list_one_grain_wo_harmonics</span>

    <span class="n">Twicetheta</span><span class="p">,</span> <span class="n">Chi</span><span class="p">,</span> <span class="n">Energy</span><span class="p">,</span> <span class="n">Miller_ind</span> <span class="o">=</span> <span class="n">TwthetaChiEnergyMillers_list_one_grain_wo_harmonics</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>

    <span class="c1">#     print &#39;len(Twicetheta)&#39;, len(Twicetheta)</span>
    <span class="c1">#     print &#39;len(Chi)&#39;, len(Chi)</span>
    <span class="c1">#     print &#39;len(Energy)&#39;, len(Energy)</span>
    <span class="c1">#     print &#39;len(Miller_ind)&#39;, len(Miller_ind)</span>

    <span class="n">posx</span><span class="p">,</span> <span class="n">posy</span> <span class="o">=</span> <span class="n">LTGeo</span><span class="o">.</span><span class="n">calc_xycam_from2thetachi</span><span class="p">(</span><span class="n">Twicetheta</span><span class="p">,</span>
                                                <span class="n">Chi</span><span class="p">,</span>
                                                <span class="n">detectorparameters</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span>
                                                <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>


    <span class="k">if</span> <span class="n">removeharmonics</span><span class="p">:</span>
        <span class="c1"># remove harmonics:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">tokeep</span> <span class="o">=</span> <span class="n">GT</span><span class="o">.</span><span class="n">removeClosePoints</span><span class="p">(</span><span class="n">posx</span><span class="p">,</span> <span class="n">posy</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;removeharmonics = 1 in SimulateLaue_full_np() tokeep&#39;</span><span class="p">,</span><span class="n">tokeep</span><span class="p">)</span>

        <span class="n">s_tth</span> <span class="o">=</span> <span class="n">Twicetheta</span><span class="p">[</span><span class="n">tokeep</span><span class="p">]</span>
        <span class="n">s_chi</span> <span class="o">=</span> <span class="n">Chi</span><span class="p">[</span><span class="n">tokeep</span><span class="p">]</span>
        <span class="n">s_miller_ind</span> <span class="o">=</span> <span class="n">Miller_ind</span><span class="p">[</span><span class="n">tokeep</span><span class="p">]</span>
        <span class="n">s_posx</span> <span class="o">=</span> <span class="n">posx</span><span class="p">[</span><span class="n">tokeep</span><span class="p">]</span>
        <span class="n">s_posy</span> <span class="o">=</span> <span class="n">posy</span><span class="p">[</span><span class="n">tokeep</span><span class="p">]</span>
        <span class="n">s_E</span> <span class="o">=</span> <span class="n">Energy</span><span class="p">[</span><span class="n">tokeep</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s_tth</span><span class="p">,</span> <span class="n">s_chi</span><span class="p">,</span> <span class="n">s_miller_ind</span><span class="p">,</span> <span class="n">s_posx</span><span class="p">,</span> <span class="n">s_posy</span><span class="p">,</span> <span class="n">s_E</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Twicetheta</span><span class="p">,</span> <span class="n">Chi</span><span class="p">,</span> <span class="n">Miller_ind</span><span class="p">,</span> <span class="n">posx</span><span class="p">,</span> <span class="n">posy</span><span class="p">,</span> <span class="n">Energy</span></div>


<div class="viewcode-block" id="SimulateResult"><a class="viewcode-back" href="../../Simulation_Module.html#LaueTools.lauecore.SimulateResult">[docs]</a><span class="k">def</span> <span class="nf">SimulateResult</span><span class="p">(</span><span class="n">grain</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">,</span> <span class="n">simulparameters</span><span class="p">,</span>
                    <span class="n">fastcompute</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dict_Materials</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Simulates 2theta chi of Laue Pattern spots for ONE SINGLE grain</span>

<span class="sd">    :param grain: crystal parameters in a 4 elements list</span>
<span class="sd">    :param emin: minimum bandpass energy (keV)</span>
<span class="sd">    :param emax: maximum bandpass energy (keV)</span>

<span class="sd">    :return: 2theta, chi</span>

<span class="sd">    .. warning:: Need of approximate detector distance and diameter to restrict simulation to a limited solid angle</span>

<span class="sd">    .. note::</span>
<span class="sd">        * USED: in AutoindexationGUI.OnStart, LaueToolsGUI.OnCheckOrientationMatrix</span>
<span class="sd">        * USED also IndexingImageMatching, lauecore.SimulateLaue_merge</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">detectordiameter</span> <span class="o">=</span> <span class="n">simulparameters</span><span class="p">[</span><span class="s2">&quot;detectordiameter&quot;</span><span class="p">]</span>
    <span class="n">kf_direction</span> <span class="o">=</span> <span class="n">simulparameters</span><span class="p">[</span><span class="s2">&quot;kf_direction&quot;</span><span class="p">]</span>
    <span class="n">detectordistance</span> <span class="o">=</span> <span class="n">simulparameters</span><span class="p">[</span><span class="s2">&quot;detectordistance&quot;</span><span class="p">]</span>
    <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">simulparameters</span><span class="p">[</span><span class="s2">&quot;pixelsize&quot;</span><span class="p">]</span>

    <span class="c1"># PATCH: redefinition of grain to simulate any unit cell(not only cubic)</span>
    <span class="n">key_material</span> <span class="o">=</span> <span class="n">grain</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">grain</span> <span class="o">=</span> <span class="n">CP</span><span class="o">.</span><span class="n">Prepare_Grain</span><span class="p">(</span><span class="n">key_material</span><span class="p">,</span> <span class="n">grain</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>
    <span class="c1"># -----------------------------------------------------------------------------</span>

    <span class="c1"># print &quot;grain in SimulateResult()&quot;,grain</span>

    <span class="n">spots2pi</span> <span class="o">=</span> <span class="n">getLaueSpots</span><span class="p">(</span><span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">emax</span><span class="p">,</span>
                            <span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">emin</span><span class="p">,</span>
                            <span class="p">[</span><span class="n">grain</span><span class="p">],</span>
                            <span class="p">[[</span><span class="s2">&quot;&quot;</span><span class="p">]],</span>
                            <span class="n">fastcompute</span><span class="o">=</span><span class="n">fastcompute</span><span class="p">,</span>
                            <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="n">ResolutionAngstrom</span><span class="p">,</span>
                            <span class="n">fileOK</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                            <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------------------</span>

    <span class="c1"># array(vec) and array(indices)  of spots exiting the crystal in 2pi steradian</span>
    <span class="c1"># if fastcompute = 0 array(indices) = 0 and TwicethetaChi is a list of spot object</span>
    <span class="c1"># k_direction =(Z&gt;0)</span>
    <span class="c1"># TODO: to be argument if camera is far from preset kf_direction!!</span>
    <span class="c1"># spots2pi = LAUE.generalfabriquespot_fromMat_veryQuick(CST_ENERGYKEV/emax, CST_ENERGYKEV/emin,[grain],1,</span>
    <span class="c1"># fastcompute = fastcompute, fileOK = 0, verbose = 0, kf_direction = &#39;Z&gt;0&#39;)</span>

    <span class="c1"># 2theta, chi of spot which are on camera(without harmonics)</span>
    <span class="n">TwicethetaChi</span> <span class="o">=</span> <span class="n">filterLaueSpots</span><span class="p">(</span><span class="n">spots2pi</span><span class="p">,</span>
                                    <span class="n">fileOK</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">fastcompute</span><span class="o">=</span><span class="n">fastcompute</span><span class="p">,</span>
                                    <span class="n">detectordistance</span><span class="o">=</span><span class="n">detectordistance</span><span class="p">,</span>
                                    <span class="n">detectordiameter</span><span class="o">=</span><span class="n">detectordiameter</span> <span class="o">*</span> <span class="mf">1.2</span><span class="p">,</span>
                                    <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                                    <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">TwicethetaChi</span></div>

<span class="k">def</span> <span class="nf">B_DebyeWaller</span><span class="p">(</span><span class="n">U</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; compute B term of exp Debye waller factor</span>
<span class="sd">    exp - B  (sintheta/lambda)</span>
<span class="sd">    with U mean square displacement</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">U</span>


<span class="k">def</span> <span class="nf">StructureFactorCubic</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">extinctions</span><span class="o">=</span><span class="s2">&quot;dia&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    computes structure factor of cubic</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">extinctions</span> <span class="o">==</span> <span class="s1">&#39;dia&#39;</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span><span class="p">))</span>
                                                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">l</span><span class="p">))</span>
                                                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">k</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">F</span>


<span class="k">def</span> <span class="nf">StructureFactorUO2</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">qvector</span><span class="p">,</span> <span class="n">U_U</span><span class="p">,</span> <span class="n">U_O</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    computes structure factor of CaF2 flurine type structure  SG 225 Fm-3m</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># CaF2 structure</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="c1"># q = 4pi*sintheta/lambda</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">qvector</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">B_U</span> <span class="o">=</span> <span class="n">B_DebyeWaller</span><span class="p">(</span><span class="n">U_U</span><span class="p">)</span>
    <span class="n">B_O</span> <span class="o">=</span> <span class="n">B_DebyeWaller</span><span class="p">(</span><span class="n">U_O</span><span class="p">)</span>
    <span class="n">fu</span> <span class="o">=</span> <span class="n">atomicformfactor</span><span class="p">(</span><span class="n">qvector</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">B_U</span> <span class="o">*</span> <span class="n">sol</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">fo</span> <span class="o">=</span> <span class="n">atomicformfactor</span><span class="p">(</span><span class="n">qvector</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">B_O</span> <span class="o">*</span> <span class="n">sol</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">fu</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">fo</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">h</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span><span class="p">))))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span><span class="p">))</span>
                                                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">h</span><span class="p">))</span>
                                                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">k</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">F</span>


<span class="k">def</span> <span class="nf">atomicformfactor</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="s2">&quot;Ge&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes x-ray atomic scattering factor following</span>
<span class="sd">    http://lampx.tugraz.at/~hadley/ss1/crystaldiffraction/atomicformfactors/formfactors.php</span>

<span class="sd">    :param q: q vector norm in Angst-1</span>
<span class="sd">    :returns: scalar, f(q)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="s2">&quot;Ge&quot;</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mf">16.0816</span><span class="p">,</span> <span class="mf">2.8509</span><span class="p">,</span> <span class="mf">6.3747</span><span class="p">,</span> <span class="mf">0.2516</span><span class="p">,</span> <span class="mf">3.7068</span><span class="p">,</span> <span class="mf">11.4468</span><span class="p">,</span> <span class="mf">3.683</span><span class="p">,</span> <span class="mf">54.7625</span><span class="p">,</span> <span class="mf">2.1313</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">element</span> <span class="o">==</span> <span class="s2">&quot;U&quot;</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mf">5.3715</span><span class="p">,</span> <span class="mf">0.516598</span><span class="p">,</span> <span class="mf">22.5326</span><span class="p">,</span> <span class="mf">3.05053</span><span class="p">,</span> <span class="mf">12.0291</span><span class="p">,</span> <span class="mf">12.5723</span><span class="p">,</span> <span class="mf">4.79840</span><span class="p">,</span> <span class="mf">23.4582</span><span class="p">,</span> <span class="mf">13.2671</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">element</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.04850</span><span class="p">,</span> <span class="mf">13.2771</span><span class="p">,</span> <span class="mf">2.28680</span><span class="p">,</span> <span class="mf">5.70110</span><span class="p">,</span> <span class="mf">1.54630</span><span class="p">,</span> <span class="mf">0.323900</span><span class="p">,</span> <span class="mf">0.867000</span><span class="p">,</span> <span class="mf">32.9089</span><span class="p">,</span> <span class="mf">0.250800</span><span class="p">)</span>

    <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span>
        <span class="n">val</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">simulatepurepattern_np</span><span class="p">(</span><span class="n">grain</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">,</span> <span class="n">kf_direction</span><span class="p">,</span> <span class="n">data_filename</span><span class="p">,</span> <span class="n">PlotLaueDiagram</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                        <span class="n">Plot_Data</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">detectordistance</span><span class="o">=</span><span class="n">DEFAULT_DETECTOR_DISTANCE</span><span class="p">,</span>
                                                        <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">Display_label</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                        <span class="n">HarmonicsRemoval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                        <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dict_Materials</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. warning:: In test. NOT USED anywhere !!???</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">vecind</span> <span class="o">=</span> <span class="n">getLaueSpots</span><span class="p">(</span><span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">emax</span><span class="p">,</span> <span class="n">CST_ENERGYKEV</span> <span class="o">/</span> <span class="n">emin</span><span class="p">,</span> <span class="n">grain</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">fileOK</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">ResolutionAngstrom</span><span class="o">=</span><span class="n">ResolutionAngstrom</span><span class="p">,</span>
                    <span class="n">dictmaterials</span><span class="o">=</span><span class="n">dictmaterials</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(vecind[0])&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vecind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># selecting RR nodes without harmonics (fastcompute = 1 loses the miller indices and RR positions associations for quicker computation)</span>

    <span class="n">oncam_sansh</span> <span class="o">=</span> <span class="n">filterLaueSpots_full_np</span><span class="p">(</span><span class="n">vecind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vecind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">fastcompute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">kf_direction</span><span class="o">=</span><span class="n">kf_direction</span><span class="p">,</span>
                                        <span class="n">detectordistance</span><span class="o">=</span><span class="n">detectordistance</span><span class="p">,</span>
                                        <span class="n">HarmonicsRemoval</span><span class="o">=</span><span class="n">HarmonicsRemoval</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, J.S. Micha, O. Robach., S. Tardif

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>